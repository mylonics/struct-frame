{"config":{"lang":["en"],"separator":"[\\s\\-\\.]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Struct Frame","text":"<p>Struct Frame converts Protocol Buffer (.proto) files into serialization code for multiple languages. It generates C, C++, TypeScript, Python, JavaScript, C#, and GraphQL code from a single source.</p>"},{"location":"#why-struct-frame","title":"Why Struct Frame","text":"<p>Struct Frame offers several advantages over other serialization systems:</p> <ul> <li>Zero-copy encoding/decoding in C/C++: Uses packed structs that map directly to memory. No encoding or decoding step required.</li> <li>Flexible framing: Multiple frame profiles for different scenarios, from zero-overhead trusted links to robust multi-node networks.</li> <li>Nested messages and variable-length arrays: Unlike Mavlink, supports complex message structures with nested messages and variable-length packing for arrays.</li> <li>Smaller and simpler than Protobuf/Cap'n Proto: Lower encoding cost and complexity. No schema evolution overhead.</li> <li>Cross-platform: Generate code for embedded C, server Python, and frontend TypeScript from a single proto definition.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install struct-frame\n</code></pre> <p>The package name is <code>struct-frame</code>, but the Python module uses <code>struct_frame</code>:</p> <pre><code>python -m struct_frame --help\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Create a <code>.proto</code> file:</li> </ol> <pre><code>package example;\n\nmessage Status {\n  option msgid = 1;\n  uint32 id = 1;\n  float value = 2;\n}\n</code></pre> <ol> <li>Generate code:</li> </ol> <pre><code># Python\npython -m struct_frame status.proto --build_py --py_path generated/\n\n# C\npython -m struct_frame status.proto --build_c --c_path generated/\n\n# Multiple languages\npython -m struct_frame status.proto --build_c --build_py --build_ts\n</code></pre> <ol> <li>Use the generated code in your application.</li> </ol>"},{"location":"#quick-language-reference","title":"Quick Language Reference","text":"C++PythonTypeScriptC <pre><code>#include \"example.structframe.hpp\"\n\n// Create a message\nExampleStatus msg;\nmsg.id = 42;\nmsg.value = 3.14f;\n\n// No encoding needed - use directly as bytes\nuint8_t* data = (uint8_t*)&amp;msg;\nsize_t size = sizeof(ExampleStatus);\n</code></pre> <pre><code>from struct_frame.generated.example import ExampleStatus\n\n# Create a message\nmsg = ExampleStatus(id=42, value=3.14)\n\n# Serialize to bytes\ndata = msg.pack()\n</code></pre> <pre><code>import { ExampleStatus } from './example.structframe';\n\n// Create a message\nconst msg = new ExampleStatus();\nmsg.id = 42;\nmsg.value = 3.14;\n\n// Get binary data\nconst data = msg.data();\n</code></pre> <pre><code>#include \"example.structframe.h\"\n\n// Create a message\nExampleStatus msg = { .id = 42, .value = 3.14f };\n\n// Use directly as bytes\nuint8_t* data = (uint8_t*)&amp;msg;\nsize_t size = sizeof(ExampleStatus);\n</code></pre> <p>For detailed examples, see Language Examples.</p>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Complete walkthrough with C++ example</li> <li>Define Messages - Learn proto file syntax</li> <li>Language Examples - See detailed examples for each language</li> <li>Framing Guide - Understand message framing for reliable communication</li> </ul>"},{"location":"#documentation-structure","title":"Documentation Structure","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Installation and quick start guide.</p>"},{"location":"#basic-usage","title":"Basic Usage","text":"<p>Essential information for common use cases.</p>"},{"location":"#extended-features","title":"Extended Features","text":"<p>Detailed information on framing, SDKs, and advanced features.</p>"},{"location":"#reference","title":"Reference","text":"<p>Build integration, testing, and development guides.</p>"},{"location":"404/","title":"Page Not Found","text":"<p>Sorry, the page you are looking for does not exist.</p> <p>Return to Home{ .md-button }</p>"},{"location":"basic-usage/code-generation/","title":"Code Generation","text":"<p>Generate serialization code from proto files using the struct-frame command-line tool.</p>"},{"location":"basic-usage/code-generation/#basic-usage","title":"Basic Usage","text":"<pre><code># Generate Python code\npython -m struct_frame messages.proto --build_py\n\n# Generate C code\npython -m struct_frame messages.proto --build_c\n\n# Generate multiple languages\npython -m struct_frame messages.proto --build_c --build_cpp --build_py --build_ts\n</code></pre>"},{"location":"basic-usage/code-generation/#language-flags","title":"Language Flags","text":"Flag Language Output <code>--build_c</code> C <code>&lt;name&gt;.structframe.h</code> <code>--build_cpp</code> C++ <code>&lt;name&gt;.structframe.hpp</code> <code>--build_ts</code> TypeScript <code>&lt;name&gt;.structframe.ts</code> <code>--build_py</code> Python <code>&lt;name&gt;.py</code> (in <code>struct_frame/generated/</code>) <code>--build_js</code> JavaScript <code>&lt;name&gt;.structframe.js</code> <code>--build_csharp</code> C# <code>&lt;name&gt;.structframe.cs</code> <code>--build_gql</code> GraphQL <code>&lt;name&gt;.structframe.graphql</code>"},{"location":"basic-usage/code-generation/#output-paths","title":"Output Paths","text":"<p>Default output is <code>generated/&lt;language&gt;/</code>. Customize with path options:</p> <pre><code># Custom C output\npython -m struct_frame messages.proto --build_c --c_path src/generated/\n\n# Multiple languages, different paths\npython -m struct_frame messages.proto \\\n  --build_c --c_path firmware/generated/ \\\n  --build_py --py_path server/generated/\n</code></pre>"},{"location":"basic-usage/code-generation/#common-patterns","title":"Common Patterns","text":""},{"location":"basic-usage/code-generation/#single-language","title":"Single Language","text":"<pre><code>python -m struct_frame robot.proto --build_cpp --cpp_path include/\n</code></pre>"},{"location":"basic-usage/code-generation/#embedded-server","title":"Embedded + Server","text":"<pre><code>python -m struct_frame messages.proto \\\n  --build_c --c_path embedded/messages/ \\\n  --build_py --py_path server/messages/\n</code></pre>"},{"location":"basic-usage/code-generation/#frontend-backend","title":"Frontend + Backend","text":"<pre><code>python -m struct_frame api.proto \\\n  --build_ts --ts_path frontend/src/generated/ \\\n  --build_py --py_path backend/generated/\n</code></pre>"},{"location":"basic-usage/code-generation/#all-languages","title":"All Languages","text":"<pre><code>python -m struct_frame messages.proto \\\n  --build_c --build_cpp --build_ts --build_py --build_js --build_csharp --build_gql\n</code></pre>"},{"location":"basic-usage/code-generation/#generated-files","title":"Generated Files","text":"<p>Each language generates:</p> <ul> <li>Message/struct definitions</li> <li>Serialization code (where applicable)</li> <li>Frame parsing utilities (if using framing)</li> <li>SDK files (if <code>--sdk</code> flag used)</li> </ul> <p>See CLI Reference for complete details.</p>"},{"location":"basic-usage/framing-details/","title":"Framing Details","text":"<p>This page covers the technical details of the framing system.</p>"},{"location":"basic-usage/framing-details/#frame-components","title":"Frame Components","text":"<p>Frames consist of two parts:</p> <ol> <li>Header: Determines sync bytes and addressing</li> <li>Payload: Determines length encoding and checksum</li> </ol>"},{"location":"basic-usage/framing-details/#header-types","title":"Header Types","text":""},{"location":"basic-usage/framing-details/#basic-header-2-bytes","title":"Basic Header (2 bytes)","text":"<p><pre><code>[0x90] [0x70 + PayloadType]\n</code></pre> Two-byte sync for reliable synchronization. Recommended for most applications.</p>"},{"location":"basic-usage/framing-details/#tiny-header-1-byte","title":"Tiny Header (1 byte)","text":"<p><pre><code>[0x70 + PayloadType]\n</code></pre> Single-byte sync for bandwidth-limited scenarios.</p>"},{"location":"basic-usage/framing-details/#none-header-0-bytes","title":"None Header (0 bytes)","text":"<p><pre><code>(no header)\n</code></pre> For trusted links where synchronization isn't needed.</p>"},{"location":"basic-usage/framing-details/#payload-types","title":"Payload Types","text":""},{"location":"basic-usage/framing-details/#minimal","title":"Minimal","text":"<p><pre><code>[MSG_ID] [PAYLOAD...]\n</code></pre> 1 byte overhead. Requires message length lookup. No checksum or length field.</p>"},{"location":"basic-usage/framing-details/#default","title":"Default","text":"<p><pre><code>[LENGTH] [MSG_ID] [PAYLOAD...] [CRC_HI] [CRC_LO]\n</code></pre> 4 bytes overhead. Includes length (1 byte, max 255) and Fletcher-16 checksum.</p>"},{"location":"basic-usage/framing-details/#extended","title":"Extended","text":"<p><pre><code>[LENGTH_HI] [LENGTH_LO] [MSG_ID] [PAYLOAD...] [CRC_HI] [CRC_LO]\n</code></pre> 5 bytes overhead. 16-bit length field (max 65535 bytes).</p>"},{"location":"basic-usage/framing-details/#extendedmultisystemstream","title":"ExtendedMultiSystemStream","text":"<p><pre><code>[LENGTH_HI] [LENGTH_LO] [SRC] [DST] [SEQ] [MSG_ID] [PAYLOAD...] [CRC_HI] [CRC_LO]\n</code></pre> 8 bytes overhead. Adds source/destination addresses and sequence numbers for multi-node networks.</p>"},{"location":"basic-usage/framing-details/#frame-profiles","title":"Frame Profiles","text":"<p>Profiles combine header + payload types:</p> Profile Header Payload Total Overhead Standard Basic Default 6 bytes Sensor Tiny Minimal 2 bytes IPC None Minimal 1 byte Bulk Basic Extended 8 bytes Network Basic ExtendedMultiSystemStream 11 bytes"},{"location":"basic-usage/framing-details/#checksum-fletcher-16","title":"Checksum (Fletcher-16)","text":"<p>The Default and Extended payload types use Fletcher-16 checksum.</p> <p>Magic Numbers: - Basic frame start: <code>0x90</code> followed by <code>0x70 + PayloadType</code> - Tiny frame start: <code>0x70 + PayloadType</code> - Payload type base value: <code>0x70</code></p> <p>The checksum algorithm:</p> <pre><code>For each byte in [LENGTH, MSG_ID, PAYLOAD]:\n    sum1 = (sum1 + byte) mod 255\n    sum2 = (sum2 + sum1) mod 255\nchecksum = (sum2 &lt;&lt; 8) | sum1\n</code></pre>"},{"location":"basic-usage/framing-details/#parser-state-machine","title":"Parser State Machine","text":"<p>The parser implements a state machine:</p> <pre><code>IDLE \u2192 wait for start byte(s)\nHEADER \u2192 read header bytes\nPAYLOAD \u2192 read length, msg_id, data\nCHECKSUM \u2192 verify CRC\nCOMPLETE \u2192 return message\n</code></pre> <p>For Minimal payloads, the parser requires a message length callback to determine payload size.</p>"},{"location":"basic-usage/framing-details/#usage-in-c","title":"Usage in C++","text":"<pre><code>#include \"FrameProfiles.hpp\"\n\nusing namespace FrameParsers;\n\n// Using profiles\nuint8_t buffer[1024];\nProfileStandardWriter writer(buffer, sizeof(buffer));\nProfileStandardAccumulatingReader reader;\n\n// Encode\nwriter.write(msg);\nsend_data(writer.buffer(), writer.size());\n\n// Decode (streaming)\nwhile (receiving) {\n    if (auto result = reader.push_byte(read_byte())) {\n        handle_message(result.msg_id, result.msg_data, result.msg_len);\n    }\n}\n\n// Decode (buffer)\nreader.add_data(buffer, buffer_size);\nwhile (auto result = reader.next()) {\n    handle_message(result.msg_id, result.msg_data, result.msg_len);\n}\n</code></pre>"},{"location":"basic-usage/framing-details/#usage-in-python","title":"Usage in Python","text":"<pre><code>from struct_frame_parser import Parser, HeaderType, PayloadType\n\n# Create parser with specific frame types\nparser = Parser(\n    enabled_headers=[HeaderType.BASIC, HeaderType.TINY],\n    enabled_payloads=[PayloadType.DEFAULT, PayloadType.EXTENDED]\n)\n\n# Encode\nframe = parser.encode(\n    msg_id=42,\n    msg=b\"payload data\",\n    header_type=HeaderType.BASIC,\n    payload_type=PayloadType.DEFAULT\n)\n\n# Decode (byte-by-byte)\nfor byte in incoming_data:\n    result = parser.parse_byte(byte)\n    if result.valid:\n        handle_message(result)\n</code></pre>"},{"location":"basic-usage/framing-details/#custom-profiles","title":"Custom Profiles","text":"<p>Create custom frame formats by combining header and payload types:</p> C++Python <pre><code>// Custom: Tiny header with Extended payload\nusing CustomConfig = FrameConfig&lt;\n    HeaderTiny,\n    PayloadExtended\n&gt;;\n\nFrameEncoderWithCrc&lt;CustomConfig&gt; encoder;\nBufferParserWithCrc&lt;CustomConfig&gt; parser;\n</code></pre> <pre><code>from struct_frame_parser import create_custom_profile, HeaderType, PayloadType\n\ncustom = create_custom_profile(\n    \"TinyExtended\",\n    HeaderType.TINY,\n    PayloadType.EXTENDED\n)\n</code></pre>"},{"location":"basic-usage/framing/","title":"Framing","text":"<p>Framing wraps messages with headers and checksums for reliable communication over serial links, network sockets, or any byte stream.</p>"},{"location":"basic-usage/framing/#why-framing","title":"Why Framing","text":"<p>When sending data over a communication channel, you need to:</p> <ol> <li>Identify message boundaries</li> <li>Validate message integrity</li> <li>Route messages by type</li> </ol> <p>Framing solves these problems by adding structure around your message data.</p>"},{"location":"basic-usage/framing/#standard-profiles","title":"Standard Profiles","text":"<p>Use these pre-configured profiles for common scenarios:</p> Profile Overhead Max Payload Use Case Standard 6 bytes 255 bytes General serial/UART Sensor 2 bytes N/A Low-bandwidth sensors IPC 1 byte N/A Trusted board-to-board Bulk 8 bytes 64 KB Firmware/file transfer Network 11 bytes 64 KB Multi-node networks"},{"location":"basic-usage/framing/#quick-decision-guide","title":"Quick Decision Guide","text":"<pre><code>Do you need routing between nodes? \u2192 Network\nIs it a trusted internal link (SPI)? \u2192 IPC\nAre you bandwidth-limited (radio)? \u2192 Sensor\nSending large files (&gt; 255 bytes)? \u2192 Bulk\nOtherwise \u2192 Standard (recommended)\n</code></pre>"},{"location":"basic-usage/framing/#basic-frame-structure","title":"Basic Frame Structure","text":"<p>The Standard profile (recommended for most uses):</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 START1 \u2502 START2 \u2502 LENGTH \u2502 MSG_ID \u2502 PAYLOAD \u2502  CRC1   \u2502  CRC2   \u2502\n\u2502  0x90  \u2502  0x71  \u2502 1 byte \u2502 1 byte \u2502 N bytes \u2502 1 byte  \u2502 1 byte  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <ul> <li>Start bytes: Sync markers to find frame boundaries</li> <li>Length: Payload size (0-255)</li> <li>MSG_ID: Message type identifier</li> <li>Payload: Your message data</li> <li>CRC: Fletcher-16 checksum for error detection</li> </ul>"},{"location":"basic-usage/framing/#usage-example","title":"Usage Example","text":"PythonC++ <pre><code>from struct_frame_parser import Parser, HeaderType, PayloadType\n\nparser = Parser()\n\n# Encode\nframe = parser.encode_basic(msg_id=42, msg=b\"data\")\n\n# Decode\nfor byte in frame:\n    result = parser.parse_byte(byte)\n    if result.valid:\n        print(f\"Message {result.msg_id}: {result.msg_data}\")\n</code></pre> <pre><code>#include \"FrameProfiles.hpp\"\n\nusing namespace StructFrame;\n\n// Encode\nuint8_t buffer[1024];\nProfileStandardWriter writer(buffer, sizeof(buffer));\nwriter.write(msg);\n\n// Decode\nProfileStandardAccumulatingReader reader;\nreader.add_data(buffer, buffer_size);\nwhile (auto result = reader.next()) {\n    // Process message - result is valid due to operator bool()\n}\n</code></pre> <p>For more details, see Framing Details.</p>"},{"location":"basic-usage/language-examples/","title":"Language Examples","text":"<p>This page shows how to use generated code in each language with the standardized serialize/deserialize API.</p>"},{"location":"basic-usage/language-examples/#proto-definition","title":"Proto Definition","text":"<p>Examples use this proto file:</p> <pre><code>package example;\n\nmessage Status {\n  option msgid = 1;\n  uint32 id = 1;\n  float value = 2;\n}\n</code></pre> <p>Generate code: <pre><code>python -m struct_frame status.proto --build_c --build_cpp --build_ts --build_py --build_js --build_csharp\n</code></pre></p>"},{"location":"basic-usage/language-examples/#using-frame-profiles","title":"Using Frame Profiles","text":"<p>Frame profiles provide complete framing and parsing functionality. This is the recommended approach for most applications.</p>"},{"location":"basic-usage/language-examples/#python-with-profiles","title":"Python with Profiles","text":"<pre><code>from generated.example import ExampleStatus\nfrom generated.frame_profiles import (\n    ProfileStandardWriter, \n    ProfileStandardAccumulatingReader\n)\n\n# Create and serialize a message\nmsg = ExampleStatus(id=42, value=3.14)\n\n# Encode with frame profile\nwriter = ProfileStandardWriter(1024)\nbytes_written = writer.write(msg)\nframe_data = writer.data()\n\n# Parse received frames\nreader = ProfileStandardAccumulatingReader()\nreader.add_data(frame_data)\n\n# Deserialize using FrameMsgInfo\nresult = reader.next()\nif result:\n    decoded_msg = ExampleStatus.deserialize(result)  # Pass FrameMsgInfo directly\n    print(f\"ID: {decoded_msg.id}, Value: {decoded_msg.value}\")\n</code></pre>"},{"location":"basic-usage/language-examples/#typescript-with-profiles","title":"TypeScript with Profiles","text":"<pre><code>import { ExampleStatus } from './generated/example.structframe';\nimport { \n    ProfileStandardWriter, \n    ProfileStandardAccumulatingReader \n} from './generated/frame-profiles';\n\n// Create and serialize a message\nconst msg = new ExampleStatus();\nmsg.id = 42;\nmsg.value = 3.14;\n\n// Encode with frame profile\nconst writer = new ProfileStandardWriter(1024);\nwriter.write(msg);\nconst frameData = writer.data();\n\n// Parse received frames\nconst reader = new ProfileStandardAccumulatingReader();\nreader.addData(frameData);\n\n// Deserialize using FrameMsgInfo\nconst result = reader.next();\nif (result) {\n    const decodedMsg = ExampleStatus.deserialize(result);  // Pass FrameMsgInfo directly\n    console.log(`ID: ${decodedMsg.id}, Value: ${decodedMsg.value}`);\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#c-with-profiles","title":"C++ with Profiles","text":"<pre><code>#include \"example.structframe.hpp\"\n#include \"FrameProfiles.hpp\"\n\n// Create and serialize a message\nExampleStatus msg;\nmsg.id = 42;\nmsg.value = 3.14f;\n\n// Encode with frame profile\nuint8_t buffer[1024];\nFrameParsers::ProfileStandardWriter writer(buffer, sizeof(buffer));\nwriter.write(msg);\n\n// Parse received frames\nFrameParsers::ProfileStandardAccumulatingReader reader;\nreader.add_data(buffer, writer.size());\n\n// Deserialize using FrameMsgInfo\nif (auto result = reader.next()) {\n    ExampleStatus decoded_msg;\n    decoded_msg.deserialize(result);  // Pass FrameMsgInfo directly\n    std::cout &lt;&lt; \"ID: \" &lt;&lt; decoded_msg.id &lt;&lt; \", Value: \" &lt;&lt; decoded_msg.value &lt;&lt; std::endl;\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#c-with-profiles_1","title":"C# with Profiles","text":"<pre><code>using StructFrame;\n\n// Create and serialize a message\nvar msg = new ExampleStatus {\n    Id = 42,\n    Value = 3.14f\n};\n\n// Encode with frame profile\nvar writer = new ProfileStandardWriter(1024);\nwriter.Write(msg);\nvar frameData = writer.Data();\n\n// Parse received frames\nvar reader = new ProfileStandardAccumulatingReader();\nreader.AddData(frameData);\n\n// Deserialize using FrameMsgInfo\nvar result = reader.Next();\nif (result != null) {\n    var decodedMsg = ExampleStatus.Deserialize(result);  // Pass FrameMsgInfo directly\n    Console.WriteLine($\"ID: {decodedMsg.Id}, Value: {decodedMsg.Value}\");\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#javascript-with-profiles","title":"JavaScript with Profiles","text":"<pre><code>const { ExampleStatus } = require('./generated/example.structframe');\nconst { \n    ProfileStandardWriter, \n    ProfileStandardAccumulatingReader \n} = require('./generated/frame-profiles');\n\n// Create and serialize a message\nconst msg = new ExampleStatus();\nmsg.id = 42;\nmsg.value = 3.14;\n\n// Encode with frame profile\nconst writer = new ProfileStandardWriter(1024);\nwriter.write(msg);\nconst frameData = writer.data();\n\n// Parse received frames\nconst reader = new ProfileStandardAccumulatingReader();\nreader.addData(frameData);\n\n// Deserialize using FrameMsgInfo\nconst result = reader.next();\nif (result) {\n    const decodedMsg = ExampleStatus.deserialize(result);  // Pass FrameMsgInfo directly\n    console.log(`ID: ${decodedMsg.id}, Value: ${decodedMsg.value}`);\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#direct-message-serialization","title":"Direct Message Serialization","text":"<p>For cases where you need direct access to message bytes without framing:</p>"},{"location":"basic-usage/language-examples/#python","title":"Python","text":"<pre><code>from generated.example import ExampleStatus\n\n# Create a message\nmsg = ExampleStatus(id=42, value=3.14)\n\n# Serialize to bytes\ndata = msg.serialize()\n\n# Send data over serial, network, etc.\n# ...\n\n# Deserialize from bytes\nreceived = ExampleStatus.deserialize(data)\nprint(f\"ID: {received.id}, Value: {received.value}\")\n</code></pre>"},{"location":"basic-usage/language-examples/#typescript","title":"TypeScript","text":"<pre><code>import { ExampleStatus } from './generated/example.structframe';\n\n// Create a message\nconst msg = new ExampleStatus();\nmsg.id = 42;\nmsg.value = 3.14;\n\n// Serialize to buffer\nconst data = msg.serialize();\n\n// Send data over network, etc.\n// ...\n\n// Deserialize from buffer\nconst received = ExampleStatus.deserialize(data);\nconsole.log(`ID: ${received.id}, Value: ${received.value}`);\n</code></pre>"},{"location":"basic-usage/language-examples/#javascript","title":"JavaScript","text":"<pre><code>const { ExampleStatus } = require('./generated/example.structframe');\n\n// Create a message\nconst msg = new ExampleStatus();\nmsg.id = 42;\nmsg.value = 3.14;\n\n// Serialize to buffer\nconst data = msg.serialize();\n\n// Send data over network, etc.\n// ...\n\n// Deserialize from buffer\nconst received = ExampleStatus.deserialize(data);\nconsole.log(`ID: ${received.id}, Value: ${received.value}`);\n</code></pre>"},{"location":"basic-usage/language-examples/#c","title":"C++","text":"<pre><code>#include \"example.structframe.hpp\"\n#include &lt;iostream&gt;\n\nint main() {\n    // Create a message\n    ExampleStatus msg;\n    msg.id = 42;\n    msg.value = 3.14f;\n\n    // Serialize to buffer\n    uint8_t buffer[1024];\n    msg.serialize(buffer);\n    size_t size = sizeof(ExampleStatus);\n\n    // Send data over serial, network, etc.\n    // ...\n\n    // Deserialize from buffer\n    ExampleStatus received;\n    received.deserialize(buffer, size);\n    std::cout &lt;&lt; \"ID: \" &lt;&lt; received.id &lt;&lt; \", Value: \" &lt;&lt; received.value &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#c_1","title":"C","text":"<pre><code>using StructFrame;\n\nclass Program {\n    static void Main() {\n        // Create a message\n        var msg = new ExampleStatus {\n            Id = 42,\n            Value = 3.14f\n        };\n\n        // Serialize to bytes\n        byte[] data = msg.Serialize();\n\n        // Send data over network, etc.\n        // ...\n\n        // Deserialize from bytes\n        var received = ExampleStatus.Deserialize(data);\n        Console.WriteLine($\"ID: {received.Id}, Value: {received.Value}\");\n    }\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#communication-examples","title":"Communication Examples","text":""},{"location":"basic-usage/language-examples/#serial-communication-python","title":"Serial Communication (Python)","text":"<pre><code>import serial\nfrom generated.example import ExampleStatus\nfrom generated.frame_profiles import ProfileStandardAccumulatingReader\n\n# Setup serial connection\nser = serial.Serial('/dev/ttyUSB0', 115200)\nreader = ProfileStandardAccumulatingReader()\n\nwhile True:\n    if ser.in_waiting:\n        # Read available data\n        data = ser.read(ser.in_waiting)\n        reader.add_data(data)\n\n        # Process all complete frames\n        while True:\n            result = reader.next()\n            if result is None or not result.valid:\n                break\n\n            # Deserialize using FrameMsgInfo\n            msg = ExampleStatus.deserialize(result)\n            print(f\"Received: ID={msg.id}, Value={msg.value}\")\n</code></pre>"},{"location":"basic-usage/language-examples/#streaming-parser-c","title":"Streaming Parser (C++)","text":"<pre><code>#include \"example.structframe.hpp\"\n#include \"FrameProfiles.hpp\"\n\n// Byte-by-byte streaming parser for UART/serial\nFrameParsers::ProfileStandardAccumulatingReader reader;\n\nvoid on_byte_received(uint8_t byte) {\n    if (auto result = reader.push_byte(byte)) {\n        // Complete message received - result is valid due to operator bool()\n        ExampleStatus msg;\n        msg.deserialize(result);\n        std::cout &lt;&lt; \"ID: \" &lt;&lt; msg.id &lt;&lt; std::endl;\n    }\n}\n</code></pre>"},{"location":"basic-usage/language-examples/#tcp-socket-typescript","title":"TCP Socket (TypeScript)","text":"<pre><code>import * as net from 'net';\nimport { ExampleStatus } from './generated/example.structframe';\nimport { ProfileStandardAccumulatingReader } from './generated/frame-profiles';\n\nconst client = net.createConnection({ port: 8080 });\nconst reader = new ProfileStandardAccumulatingReader();\n\nclient.on('data', (data: Buffer) =&gt; {\n    reader.addData(data);\n\n    let result;\n    while ((result = reader.next()) &amp;&amp; result.valid) {\n        const msg = ExampleStatus.deserialize(result);\n        console.log(`ID: ${msg.id}, Value: ${msg.value}`);\n    }\n});\n</code></pre>"},{"location":"basic-usage/language-examples/#websocket-javascript","title":"WebSocket (JavaScript)","text":"<pre><code>const { ExampleStatus } = require('./generated/example.structframe');\nconst { ProfileStandardAccumulatingReader } = require('./generated/frame-profiles');\nconst WebSocket = require('ws');\n\nconst ws = new WebSocket('ws://localhost:8080');\nconst reader = new ProfileStandardAccumulatingReader();\n\nws.on('message', (data) =&gt; {\n    reader.addData(Buffer.from(data));\n\n    let result;\n    while ((result = reader.next()) &amp;&amp; result.valid) {\n        const msg = ExampleStatus.deserialize(result);\n        console.log(`ID: ${msg.id}, Value: ${msg.value}`);\n    }\n});\n</code></pre>"},{"location":"basic-usage/language-examples/#frame-profiles","title":"Frame Profiles","text":"<p>Different profiles for different use cases:</p> <ul> <li>ProfileStandard: General purpose (Basic header + Default payload)</li> <li>ProfileSensor: Low-bandwidth sensors (Tiny header + Minimal payload)</li> <li>ProfileIPC: Trusted inter-process (No header + Minimal payload)</li> <li>ProfileBulk: Large data transfers (Basic header + Extended payload)</li> <li>ProfileNetwork: Multi-system networks (Basic header + Extended Multi-System Stream payload)</li> </ul> <p>All profiles support the same API - just change the class name!</p>"},{"location":"basic-usage/language-examples/#arrays","title":"Arrays","text":"<p>Example with arrays:</p> <pre><code>message SensorData {\n  option msgid = 2;\n  repeated float readings = 1 [max_size=10];\n}\n</code></pre> <p>Creating messages with arrays works the same way across languages:</p> CC++PythonTypeScriptC# <pre><code>ExampleSensorData data;\ndata.readings_count = 3;\ndata.readings[0] = 1.1f;\ndata.readings[1] = 2.2f;\ndata.readings[2] = 3.3f;\n\n// Serialize/deserialize works the same as simple messages\n// Just use msg.serialize() / deserialize(data)\n</code></pre> <pre><code>ExampleSensorData data;\ndata.readings_count = 3;\ndata.readings[0] = 1.1f;\ndata.readings[1] = 2.2f;\ndata.readings[2] = 3.3f;\n\n// Serialize/deserialize works the same as simple messages\n// Just use msg.serialize() / deserialize(data)\n</code></pre> <pre><code>data = ExampleSensorData()\ndata.readings_count = 3\ndata.readings[0] = 1.1\ndata.readings[1] = 2.2\ndata.readings[2] = 3.3\n\n# Serialize/deserialize works the same as simple messages\n# Just use msg.serialize() / deserialize(data)\n</code></pre> <pre><code>const data = new ExampleSensorData();\ndata.readings_count = 3;\ndata.readings[0] = 1.1;\ndata.readings[1] = 2.2;\ndata.readings[2] = 3.3;\n\n// Serialize/deserialize works the same as simple messages\n// Just use msg.serialize() / deserialize(data)\n</code></pre> <pre><code>var data = new ExampleSensorData {\n    ReadingsCount = 3\n};\ndata.Readings[0] = 1.1f;\ndata.Readings[1] = 2.2f;\ndata.Readings[2] = 3.3f;\n\n// Serialize/deserialize works the same as simple messages\n// Just use msg.Serialize() / Deserialize(data)\n</code></pre>"},{"location":"basic-usage/language-examples/#nested-messages","title":"Nested Messages","text":"<p>Example with nested messages:</p> <pre><code>message Position {\n  double lat = 1;\n  double lon = 2;\n}\n\nmessage Vehicle {\n  option msgid = 3;\n  uint32 id = 1;\n  Position pos = 2;\n}\n</code></pre> <p>Nested messages are accessed naturally in all languages:</p> CC++PythonTypeScriptC# <pre><code>ExampleVehicle v;\nv.id = 1;\nv.pos.lat = 37.7749;\nv.pos.lon = -122.4194;\n\n// Serialize/deserialize works the same - nested messages are handled automatically\n</code></pre> <pre><code>ExampleVehicle v;\nv.id = 1;\nv.pos.lat = 37.7749;\nv.pos.lon = -122.4194;\n\n// Serialize/deserialize works the same - nested messages are handled automatically\n</code></pre> <pre><code>v = ExampleVehicle(id=1)\nv.pos.lat = 37.7749\nv.pos.lon = -122.4194\n\n# Serialize/deserialize works the same - nested messages are handled automatically\n</code></pre> <pre><code>const v = new ExampleVehicle();\nv.id = 1;\nv.pos.lat = 37.7749;\nv.pos.lon = -122.4194;\n\n// Serialize/deserialize works the same - nested messages are handled automatically\n</code></pre> <pre><code>var v = new ExampleVehicle {\n    Id = 1,\n    Pos = new ExamplePosition {\n        Lat = 37.7749,\n        Lon = -122.4194\n    }\n};\n\n// Serialize/deserialize works the same - nested messages are handled automatically\n</code></pre>"},{"location":"basic-usage/language-examples/#key-takeaways","title":"Key Takeaways","text":"<ol> <li>Consistent API: All languages use <code>serialize()</code> / <code>deserialize()</code> (case varies by language convention)</li> <li>Frame Profiles: Use ProfileStandardWriter/Reader for complete framing and parsing</li> <li>FrameMsgInfo: Pass frame parser results directly to <code>deserialize()</code> - no manual extraction needed</li> <li>Variable Messages: Transparent handling - same API for fixed and variable-length messages</li> <li>Arrays &amp; Nested Messages: Automatically handled by serialize/deserialize</li> </ol>"},{"location":"basic-usage/message-definitions/","title":"Message Definitions","text":"<p>Messages are defined in Protocol Buffer (.proto) files. Struct Frame uses these definitions to generate serialization code for each target language.</p>"},{"location":"basic-usage/message-definitions/#why-proto-files","title":"Why Proto Files","text":"<p>Proto files provide: - Language-neutral message definitions - Type safety across language boundaries - Familiar syntax for developers who know Protocol Buffers - Tooling support (syntax highlighting, linting)</p> <p>Struct Frame uses proto syntax but generates different code than Google's Protocol Buffers. Messages are fixed-size packed structs, not variable-length encoded.</p>"},{"location":"basic-usage/message-definitions/#packages","title":"Packages","text":"<p>Packages group related messages and prevent name collisions:</p> <pre><code>package sensor_system;\n\nmessage SensorReading {\n  option msgid = 1;\n  float value = 1;\n}\n</code></pre> <p>Generated code uses the package name as a prefix or namespace depending on language.</p>"},{"location":"basic-usage/message-definitions/#messages","title":"Messages","text":"<p>Messages define the structure of data to be serialized:</p> <pre><code>message DeviceStatus {\n  option msgid = 1;\n  uint32 device_id = 1;\n  float battery = 2;\n  bool online = 3;\n}\n</code></pre>"},{"location":"basic-usage/message-definitions/#message-options","title":"Message Options","text":"<p>msgid (required for top-level messages)</p> <pre><code>message Heartbeat {\n  option msgid = 42;\n  uint64 timestamp = 1;\n}\n</code></pre> <p>Message IDs must be unique within a package (range 0-255).</p> <p>variable (optional, enables variable-length encoding)</p> <pre><code>message SensorData {\n  option msgid = 1;\n  option variable = true;  // Encode only used bytes\n  repeated uint8 readings = 1 [max_size=100];\n}\n</code></pre> <p>With variable encoding, arrays and strings only transmit actual used bytes instead of the full max_size. This reduces bandwidth when fields are partially filled.</p> <p>pkgid (optional package-level option)</p> <pre><code>package sensors;\noption pkgid = 5;\n</code></pre> <p>Enables extended message addressing with 16-bit message IDs (256 packages \u00d7 256 messages = 65,536 total).</p>"},{"location":"basic-usage/message-definitions/#data-types","title":"Data Types","text":"Type Size Description int8 1 byte Signed -128 to 127 uint8 1 byte Unsigned 0 to 255 int16 2 bytes Signed -32768 to 32767 uint16 2 bytes Unsigned 0 to 65535 int32 4 bytes Signed integer uint32 4 bytes Unsigned integer int64 8 bytes Signed large integer uint64 8 bytes Unsigned large integer float 4 bytes IEEE 754 single precision double 8 bytes IEEE 754 double precision bool 1 byte true or false <p>All types use little-endian byte order.</p>"},{"location":"basic-usage/message-definitions/#strings","title":"Strings","text":"<p>Strings require a size specification.</p> <p>Fixed-size string</p> <pre><code>string device_name = 1 [size=16];\n</code></pre> <p>Always uses 16 bytes, padded with nulls if shorter.</p> <p>Variable-size string</p> <pre><code>string description = 1 [max_size=256];\n</code></pre> <p>Stores up to 256 characters plus a 1-byte length prefix.</p>"},{"location":"basic-usage/message-definitions/#arrays","title":"Arrays","text":"<p>All repeated fields must specify a size. Arrays can contain primitive types, enums, strings, or nested messages.</p> <p>Fixed arrays</p> <pre><code>repeated float matrix = 1 [size=9];  // Always 9 floats (3x3 matrix)\n</code></pre> <p>Bounded arrays (variable count)</p> <pre><code>repeated int32 readings = 1 [max_size=100];  // 0-100 integers\n</code></pre> <p>Includes a 1-byte count prefix.</p> <p>String arrays</p> <pre><code>repeated string names = 1 [max_size=10, element_size=32];\n</code></pre> <p>Array of up to 10 strings, each up to 32 characters.</p> <p>Arrays of nested messages</p> <pre><code>message Waypoint {\n  double lat = 1;\n  double lon = 2;\n}\n\nmessage Route {\n  option msgid = 5;\n  string name = 1 [size=32];\n  repeated Waypoint waypoints = 2 [max_size=20];\n}\n</code></pre> <p>Array of up to 20 waypoint messages. Each Waypoint is embedded inline.</p>"},{"location":"basic-usage/message-definitions/#enums","title":"Enums","text":"<pre><code>enum SensorType {\n  TEMPERATURE = 0;\n  HUMIDITY = 1;\n  PRESSURE = 2;\n}\n\nmessage SensorReading {\n  option msgid = 1;\n  SensorType type = 1;\n  float value = 2;\n}\n</code></pre> <p>Enums are stored as uint8 (1 byte).</p>"},{"location":"basic-usage/message-definitions/#enum-to-string-conversion","title":"Enum to String Conversion","text":"<p>Enums can be converted to strings using language built-in features or generated helper functions.</p> <p>C (generated helper function) <pre><code>SerializationTestSensorType type = SENSOR_TYPE_TEMPERATURE;\nconst char* type_str = SerializationTestSensorType_to_string(type);\n// Returns: \"TEMPERATURE\"\n</code></pre></p> <p>C++ (generated helper function) <pre><code>SerializationTestSensorType type = SerializationTestSensorType::TEMPERATURE;\nconst char* type_str = SerializationTestSensorType_to_string(type);\n// Returns: \"TEMPERATURE\"\n</code></pre></p> <p>Python (built-in Enum) <pre><code>from sensor_system import SerializationTestSensorType\n\ntype = SerializationTestSensorType.TEMPERATURE\n# Use the built-in .name property\ntype_str = type.name\n# Returns: \"TEMPERATURE\"\n</code></pre></p> <p>TypeScript (built-in reverse mapping) <pre><code>import { SerializationTestSensorType } from './sensor_system.structframe';\n\nconst type = SerializationTestSensorType.TEMPERATURE;\n// TypeScript numeric enums support reverse mapping\nconst typeStr = SerializationTestSensorType[type];\n// Returns: \"TEMPERATURE\"\n</code></pre></p> <p>JavaScript (Object.keys lookup) <pre><code>const { SerializationTestSensorType } = require('./sensor_system.structframe');\n\nconst type = SerializationTestSensorType.TEMPERATURE;\n// Find the key by value\nconst typeStr = Object.keys(SerializationTestSensorType).find(\n  key =&gt; SerializationTestSensorType[key] === type\n);\n// Returns: \"TEMPERATURE\"\n</code></pre></p> <p>C# (built-in ToString) <pre><code>using StructFrame.SensorSystem;\n\nSerializationTestSensorType type = SerializationTestSensorType.TEMPERATURE;\n// Use the built-in enum ToString method\nstring typeStr = type.ToString();\n// Returns: \"TEMPERATURE\"\n</code></pre></p>"},{"location":"basic-usage/message-definitions/#nested-messages","title":"Nested Messages","text":"<pre><code>message Position {\n  double lat = 1;\n  double lon = 2;\n}\n\nmessage Vehicle {\n  option msgid = 1;\n  uint32 id = 1;\n  Position pos = 2;\n}\n</code></pre> <p>Nested messages are embedded inline.</p>"},{"location":"basic-usage/message-definitions/#import-statements","title":"Import Statements","text":"<p>Import proto definitions from other files:</p> <pre><code>// types.proto\npackage common;\n\nmessage Position {\n  double lat = 1;\n  double lon = 2;\n}\n</code></pre> <pre><code>// vehicle.proto\nimport \"types.proto\";\n\npackage fleet;\n\nmessage Vehicle {\n  option msgid = 1;\n  uint32 id = 1;\n  common.Position pos = 2;\n}\n</code></pre>"},{"location":"basic-usage/message-definitions/#flatten-option","title":"Flatten Option","text":"<p>Flatten nested message fields into the parent (Python/GraphQL only):</p> <pre><code>message Status {\n  Position pos = 1 [flatten=true];\n  float battery = 2;\n}\n</code></pre> <p>Access: <code>status.lat</code> instead of <code>status.pos.lat</code></p>"},{"location":"basic-usage/message-definitions/#oneof-union-types","title":"Oneof (Union Types)","text":"<p>The <code>oneof</code> construct creates a union type where only one of the fields can be populated at a time. All fields within the <code>oneof</code> share the same memory, with the total size equal to the largest field.</p>"},{"location":"basic-usage/message-definitions/#basic-oneof","title":"Basic Oneof","text":"<pre><code>message SensorReading {\n  option msgid = 10;\n  uint32 timestamp = 1;\n\n  oneof value {\n    float temperature = 2;\n    int32 pressure = 3;\n    uint16 humidity = 4;\n  }\n}\n</code></pre> <p>Memory Layout: - The <code>value</code> union occupies 4 bytes (size of the largest type: <code>float</code> or <code>int32</code>) - Only one field (<code>temperature</code>, <code>pressure</code>, or <code>humidity</code>) should be set at a time - A <code>uint8</code> field order discriminator is automatically generated (stores 1, 2, or 3 based on which field is active)</p>"},{"location":"basic-usage/message-definitions/#oneof-with-message-types","title":"Oneof with Message Types","text":"<p>When all fields in a <code>oneof</code> are messages with <code>msgid</code>, an auto-discriminator using message IDs is generated:</p> <pre><code>message CommandA {\n  option msgid = 100;\n  uint8 param1 = 1;\n}\n\nmessage CommandB {\n  option msgid = 101;\n  uint16 param1 = 1;\n  uint16 param2 = 2;\n}\n\nmessage CommandWrapper {\n  option msgid = 200;\n  uint32 sequence = 1;\n\n  oneof command {\n    CommandA cmd_a = 2;\n    CommandB cmd_b = 3;\n  }\n}\n</code></pre> <p>Memory Layout: - <code>command_discriminator</code> (uint16_t) - auto-generated, stores the message ID of the active field - <code>command</code> union - size of the largest message type</p>"},{"location":"basic-usage/message-definitions/#discriminator-option","title":"Discriminator Option","text":"<p>You can control discriminator behavior with the <code>discriminator</code> option inside a <code>oneof</code>:</p> <pre><code>oneof payload {\n  option discriminator = field_order;  // or: msgid, none, auto\n  CmdA cmd_a = 1;\n  CmdB cmd_b = 2;\n}\n</code></pre> Option Discriminator Type Size Description <code>auto</code> (default) Depends on fields varies Uses <code>msgid</code> if all fields are messages with msgid, otherwise <code>field_order</code> <code>msgid</code> Message ID uint16 (2 bytes) Forces use of message IDs. Error if any field lacks msgid <code>field_order</code> Field order (1-based) uint8 (1 byte) Uses declaration order: 1st field = 1, 2nd = 2, etc. <code>none</code> No discriminator 0 bytes Disables discriminator. Application must track active field"},{"location":"basic-usage/message-definitions/#default-auto-discriminator-behavior","title":"Default Auto-Discriminator Behavior","text":"Oneof Field Types Default Discriminator Size All messages with <code>msgid</code> msgid (uint16) 2 bytes Mixed or all primitives/enums field_order (uint8) 1 byte <p>Examples:</p> <pre><code>// Auto: Uses msgid discriminator (uint16) - all fields have msgid\noneof command {\n  CommandA cmd_a = 1;  // msgid = 100\n  CommandB cmd_b = 2;  // msgid = 101\n}\n\n// Auto: Uses field_order discriminator (uint8) - primitives don't have msgid\noneof value {\n  float temperature = 1;  // discriminator = 1\n  int32 pressure = 2;     // discriminator = 2\n}\n\n// Explicit: Force field_order even with messages that have msgid\noneof payload {\n  option discriminator = field_order;\n  CommandA cmd_a = 1;  // discriminator = 1\n  CommandB cmd_b = 2;  // discriminator = 2\n}\n\n// Explicit: Disable discriminator entirely\noneof data {\n  option discriminator = none;\n  uint32 integer_val = 1;\n  float float_val = 2;\n}\n</code></pre>"},{"location":"basic-usage/message-definitions/#using-discriminators","title":"Using Discriminators","text":"<p>With msgid discriminator: <pre><code>// C++ - check which message is active by message ID\nif (wrapper.command_discriminator == CommandA::MSG_ID) {\n    // Access wrapper.command.cmd_a\n}\n</code></pre></p> <p>With field_order discriminator:</p> <p>For <code>field_order</code> discriminators, a typed enum is generated named <code>{MessageName}{OneofName}Field</code>:</p> <pre><code>// C++ - use the generated enum for type-safe discriminator checks\nif (sensor.value_discriminator == SensorValueField::TEMPERATURE) {\n    // temperature is active\n} else if (sensor.value_discriminator == SensorValueField::PRESSURE) {\n    // pressure is active\n}\n</code></pre>"},{"location":"basic-usage/message-definitions/#multiple-oneofs","title":"Multiple Oneofs","text":"<p>A message can contain multiple <code>oneof</code> fields:</p> <pre><code>message MultiUnionMessage {\n  option msgid = 50;\n\n  oneof input {\n    float analog_value = 1;\n    bool digital_value = 2;\n  }\n\n  oneof output {\n    uint16 pwm_duty = 3;\n    bool relay_state = 4;\n  }\n}\n</code></pre> <p>Each <code>oneof</code> is independent and contributes its own union size to the message.</p>"},{"location":"basic-usage/message-definitions/#envelope-messages-oneof-with-is_envelope","title":"Envelope Messages (Oneof with is_envelope)","text":"<p>Envelope messages are container messages that wrap other messages for unified handling. They use the <code>is_envelope</code> option along with a <code>oneof</code> field to contain different message types.</p>"},{"location":"basic-usage/message-definitions/#why-envelope-messages","title":"Why Envelope Messages?","text":"<p>Envelope messages are useful when:</p> <ul> <li>You have multiple command/response types but want a single message ID for routing</li> <li>You need envelope-level metadata (sequence numbers, timestamps, priorities)</li> <li>You want type-safe wrappers with SDK helper methods</li> <li>You're implementing a command/response protocol with multiple operation types</li> </ul>"},{"location":"basic-usage/message-definitions/#defining-envelope-messages","title":"Defining Envelope Messages","text":"<pre><code>// Individual command messages (each must have a msgid)\nmessage ADCCommand {\n  option msgid = 112;\n  uint8 channel = 1;\n  uint16 sample_rate = 2;\n  bool enable = 3;\n}\n\nmessage DACCommand {\n  option msgid = 113;\n  uint8 channel = 1;\n  uint16 output_value = 2;\n  bool enable = 3;\n}\n\n// Envelope message\nmessage CommandEnvelope {\n  option msgid = 200;\n  option is_envelope = true;  // Enables envelope helper methods\n\n  // Envelope-level fields (metadata)\n  uint32 sequence_number = 1;\n  uint8 priority = 2;\n  bool run_immediately = 3;\n\n  // Union of all command types - exactly one will be populated\n  oneof command {\n    ADCCommand adc = 5;\n    DACCommand dac = 6;\n  }\n}\n</code></pre>"},{"location":"basic-usage/message-definitions/#validation-rules","title":"Validation Rules","text":"<p>Envelope messages have these requirements:</p> <ul> <li>Must have <code>option is_envelope = true</code></li> <li>Must have exactly one <code>oneof</code> field</li> <li>All types in the <code>oneof</code> must be message types (not primitives or enums)</li> <li>If using <code>msgid</code> discriminator (auto or explicit), all message types must have <code>msgid</code></li> </ul>"},{"location":"basic-usage/message-definitions/#discriminator-behavior","title":"Discriminator Behavior","text":"<p>Envelope messages use the same discriminator system as regular <code>oneof</code> fields (see Discriminator Options above), but with the following defaults:</p> Discriminator Mode When Used Size Value <code>msgid</code> (default) All inner messages have <code>msgid</code> 2 bytes (uint16) Message ID of wrapped payload <code>field_order</code> Any inner message lacks <code>msgid</code> 1 byte (uint8) 1-based field order index <p>You can explicitly set the discriminator mode on the oneof:</p> <pre><code>message CommandEnvelope {\n  option is_envelope = true;\n\n  oneof command {\n    option discriminator = \"field_order\";  // Force field_order even if all have msgid\n    ADCCommand adc = 5;\n    DACCommand dac = 6;\n  }\n}\n</code></pre> <p>Wire Format: <pre><code>[envelope fields...] [discriminator (1-2 bytes)] [union payload (max field size)]\n</code></pre></p> <p>The discriminator is automatically set by the <code>wrap()</code> method and read during deserialization.</p>"},{"location":"basic-usage/message-definitions/#generated-sdk-helper-methods","title":"Generated SDK Helper Methods","text":"<p>The SDK generates convenient helper methods for envelope messages:</p> <p>C++ (msgid discriminator) <pre><code>// Wrap a command into an envelope - template ensures type safety\nEnvelopeTestADCCommand adc_cmd{.channel = 1, .sample_rate = 1000, .enable = true};\nauto envelope = EnvelopeTestCommandEnvelope::wrap(\n    42,      // sequence_number\n    1,       // priority\n    true,    // run_immediately\n    adc_cmd  // payload (type validated at compile-time via T::MSG_ID)\n);\n\n// Only valid payload types are accepted - invalid types cause compile error:\n// auto bad = EnvelopeTestCommandEnvelope::wrap(42, 1, true, some_other_msg); // Won't compile!\n\n// Get payload message ID to determine which type was wrapped\nuint16_t payload_id = envelope.getPayloadMessageId();\n\n// Access the wrapped payload directly via the oneof field\nif (payload_id == EnvelopeTestADCCommand::MSG_ID) {\n    auto&amp; adc = envelope.command.adc;\n    // Use adc.channel, adc.sample_rate, etc.\n}\n</code></pre></p> <p>C++ (field_order discriminator) <pre><code>// Separate wrap() overloads for each payload type\nauto envelope = MyEnvelope::wrap(42, 1, true, adc_cmd);  // Sets discriminator to 1\nauto envelope2 = MyEnvelope::wrap(42, 1, true, dac_cmd); // Sets discriminator to 2\n\n// Get field order (1-based) of the wrapped payload\nuint8_t field_order = envelope.getPayloadFieldOrder();\n</code></pre></p> <p>Python <pre><code># Wrap a command into an envelope\nadc_cmd = EnvelopeTestADCCommand(channel=1, sample_rate=1000, enable=True)\nenvelope = EnvelopeTestCommandEnvelope.wrap(\n    payload=adc_cmd,  # Runtime type check ensures valid payload\n    sequence_number=42,\n    priority=1,\n    run_immediately=True\n)\n\n# Invalid payload types raise TypeError:\n# envelope = EnvelopeTestCommandEnvelope.wrap(some_other_msg, ...)  # TypeError!\n\n# Unwrap - returns the correct message type based on discriminator\npayload = envelope.unwrap()\nif payload:\n    print(f\"Got payload: {type(payload).__name__}\")\n\n# Get discriminator value (method name depends on discriminator type)\npayload_id = envelope.get_payload_message_id()  # For msgid discriminator\n# field_order = envelope.get_payload_field_order()  # For field_order discriminator\n</code></pre></p> <p>TypeScript <pre><code>// Wrap a command into an envelope - union type ensures type safety\nconst adcCmd = new EnvelopeTestADCCommand();\nadcCmd.channel = 1;\nadcCmd.sample_rate = 1000;\nadcCmd.enable = true;\n\n// payload type is: EnvelopeTestADCCommand | EnvelopeTestDACCommand | ...\nconst envelope = EnvelopeTestCommandEnvelope.wrap(adcCmd, 42, 1, true);\n\n// Get payload message ID to determine which type was wrapped\nconst payloadId = envelope.getPayloadMessageId();\n</code></pre></p> <p>C# <pre><code>// Wrap a command into an envelope - overloads provide type safety\nvar adcCmd = new EnvelopeTestADCCommand { Channel = 1, SampleRate = 1000, Enable = true };\nvar envelope = EnvelopeTestCommandEnvelope.Wrap(adcCmd, 42, 1, true);\n\n// Get payload message ID to determine which type was wrapped\nvar payloadId = envelope.GetPayloadMessageId();\n</code></pre></p>"},{"location":"basic-usage/message-definitions/#validation-rules_1","title":"Validation Rules","text":"<p>The generator enforces:</p> <ul> <li>Message IDs unique within package (0-255)</li> <li>Package IDs unique across packages (0-255)</li> <li>Field numbers unique within message</li> <li>All arrays must have size or max_size</li> <li>All strings must have size or max_size</li> <li>String arrays need both max_size and element_size</li> <li>Array max_size limited to 255 (count fits in 1 byte)</li> <li>Envelope messages must have exactly one oneof field</li> <li>Envelope oneof fields must be message types (not primitives/enums)</li> <li>Envelope oneof using <code>msgid</code> discriminator must have messages with msgid</li> </ul>"},{"location":"basic-usage/message-definitions/#complete-example","title":"Complete Example","text":"<pre><code>package robot_control;\n\nenum RobotState {\n  IDLE = 0;\n  MOVING = 1;\n  ERROR = 2;\n}\n\nmessage Position {\n  double lat = 1;\n  double lon = 2;\n  float altitude = 3;\n}\n\nmessage RobotStatus {\n  option msgid = 1;\n\n  uint32 robot_id = 1;\n  string name = 2 [size=16];\n  RobotState state = 3;\n  Position current_pos = 4;\n  float battery_percent = 5;\n  repeated float joint_angles = 6 [size=6];\n  string error_msg = 7 [max_size=128];\n}\n</code></pre>"},{"location":"extended-features/cpp-sdk/","title":"C++ SDK","text":"<p>The C++ SDK provides transport layers and message routing with an observer/subscriber pattern.</p>"},{"location":"extended-features/cpp-sdk/#installation","title":"Installation","text":""},{"location":"extended-features/cpp-sdk/#full-sdk-with-network-transports","title":"Full SDK (with network transports)","text":"<pre><code>python -m struct_frame messages.proto --build_cpp --cpp_path generated/ --sdk\n</code></pre> <p>Includes ASIO for UDP, TCP, Serial, and WebSocket transports.</p>"},{"location":"extended-features/cpp-sdk/#embedded-sdk-no-external-dependencies","title":"Embedded SDK (no external dependencies)","text":"<pre><code>python -m struct_frame messages.proto --build_cpp --cpp_path generated/ --sdk_embedded\n</code></pre> <p>Minimal footprint for embedded systems. Serial transport only.</p>"},{"location":"extended-features/cpp-sdk/#observer-pattern","title":"Observer Pattern","text":"<p>Subscribe to messages using function pointers:</p> <pre><code>#include \"struct_frame_sdk/sdk_embedded.hpp\"\n#include \"messages.sf.hpp\"\n\nvoid handle_status(const StatusMessage&amp; msg, uint8_t msgId) {\n    std::cout &lt;&lt; \"Status: \" &lt;&lt; msg.value &lt;&lt; std::endl;\n}\n\nint main() {\n    // Create SDK\n    StructFrame::SDK sdk;\n\n    // Subscribe to messages\n    sdk.subscribe&lt;StatusMessage&gt;(handle_status);\n\n    // Process incoming data\n    sdk.process_byte(byte);\n}\n</code></pre>"},{"location":"extended-features/cpp-sdk/#transports-full-sdk","title":"Transports (Full SDK)","text":""},{"location":"extended-features/cpp-sdk/#serial","title":"Serial","text":"<pre><code>#include \"struct_frame_sdk/transports/serial.hpp\"\n\nStructFrame::SerialTransport serial(\"/dev/ttyUSB0\", 115200);\nserial.connect();\nserial.send(message_id, data, size);\n</code></pre>"},{"location":"extended-features/cpp-sdk/#udp","title":"UDP","text":"<pre><code>#include \"struct_frame_sdk/transports/udp.hpp\"\n\nStructFrame::UDPTransport udp(\"192.168.1.100\", 8080);\nudp.connect();\nudp.send(message_id, data, size);\n</code></pre>"},{"location":"extended-features/cpp-sdk/#tcp","title":"TCP","text":"<pre><code>#include \"struct_frame_sdk/transports/tcp.hpp\"\n\nStructFrame::TCPTransport tcp(\"192.168.1.100\", 8080);\ntcp.connect();\ntcp.send(message_id, data, size);\n</code></pre>"},{"location":"extended-features/cpp-sdk/#frame-profiles","title":"Frame Profiles","text":"<p>Use predefined frame profiles:</p> <pre><code>#include \"FrameProfiles.hpp\"\n\nusing namespace FrameParsers;\n\n// Standard profile (recommended)\nuint8_t buffer[1024];\nProfileStandardWriter writer(buffer, sizeof(buffer));\nProfileStandardAccumulatingReader reader;\n\n// Sensor profile (minimal overhead)\nProfileSensorWriter sensor_writer(buffer, sizeof(buffer));\nProfileSensorAccumulatingReader sensor_reader(get_message_info);\n</code></pre> <p>See Framing Details for more profiles.</p>"},{"location":"extended-features/csharp-sdk/","title":"C# SDK","text":"<p>The C# SDK provides async/await-based transport layers for .NET applications using C# 11+ static abstract interface members.</p>"},{"location":"extended-features/csharp-sdk/#requirements","title":"Requirements","text":"<ul> <li>.NET 7.0+ (required for static abstract interface members)</li> <li>For serial port support: <code>System.IO.Ports</code> NuGet package</li> </ul>"},{"location":"extended-features/csharp-sdk/#installation","title":"Installation","text":"<p>Generate with SDK:</p> <pre><code>python -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --sdk\n</code></pre> <p>Generate with auto-generated <code>.csproj</code> file for immediate building:</p> <pre><code>python -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --generate_csproj\n</code></pre>"},{"location":"extended-features/csharp-sdk/#csproj-generation-options","title":".csproj Generation Options","text":"<p>The generator can create a <code>.csproj</code> file that allows immediate <code>dotnet build</code>:</p> <pre><code># Basic .csproj generation (excludes SDK, no dependencies needed)\npython -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --generate_csproj\n\n# With custom namespace\npython -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --generate_csproj --csharp_namespace MyApp.Protocol\n\n# With custom target framework\npython -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --generate_csproj --target_framework net7.0\n\n# Full SDK with .csproj (includes System.IO.Ports dependency)\npython -m struct_frame messages.proto --build_csharp --csharp_path Generated/ --sdk --generate_csproj\n</code></pre>"},{"location":"extended-features/csharp-sdk/#basic-usage","title":"Basic Usage","text":"<p>The SDK client uses the unified <code>FrameProfiles</code> infrastructure for encoding and parsing:</p> <pre><code>using StructFrame;\nusing StructFrame.Sdk;\n\n// Configure the SDK with required parameters\nvar config = new StructFrameSdkConfig(\n    transport: new TcpTransport(\"192.168.1.100\", 8080),\n    getMessageInfo: MessageDefinitions.GetMessageInfo,\n    profile: Profiles.Standard,  // optional, default is Standard\n    debug: true                  // optional, default is false\n);\n\nvar sdk = new StructFrameSdk(config);\nawait sdk.ConnectAsync();\n\n// Subscribe to messages - type-safe with compile-time dispatch\nsdk.Subscribe&lt;SensorDataMessage&gt;(msg =&gt; {\n    Console.WriteLine($\"Sensor value: {msg.Value}, ID: {msg.GetMsgId()}\");\n});\n\n// Send messages (uses IStructFrameMessage interface)\nvar command = new CommandMessage { Action = 1 };\nawait sdk.SendAsync(command);\n\n// Handle unregistered message types\nsdk.UnhandledMessage += frame =&gt; {\n    Console.WriteLine($\"Unknown message ID: {frame.MsgId}\");\n};\n</code></pre>"},{"location":"extended-features/csharp-sdk/#generated-sdk-interface","title":"Generated SDK Interface","text":"<p>When you generate with <code>--sdk</code>, a type-safe <code>SdkInterface</code> class is generated for each package. This provides convenience methods for sending and subscribing to specific message types:</p> <pre><code>using StructFrame;\nusing StructFrame.Sdk;\nusing StructFrame.MyPackage.Sdk;\n\n// Create the base SDK\nvar config = new StructFrameSdkConfig(\n    transport: new TcpTransport(\"192.168.1.100\", 8080),\n    getMessageInfo: MessageDefinitions.GetMessageInfo\n);\nvar sdk = new StructFrameSdk(config);\n\n// Create the package-specific interface\nvar myPackageSdk = new MyPackageSdkInterface(sdk);\n\n// Type-safe subscribe methods for each message\nmyPackageSdk.SubscribeSensorData(msg =&gt; {\n    Console.WriteLine($\"Sensor: {msg.Value}\");\n});\n\nmyPackageSdk.SubscribeStatusUpdate(msg =&gt; {\n    Console.WriteLine($\"Status: {msg.Code}\");\n});\n\n// Type-safe send methods for each message\nawait myPackageSdk.SendCommand(new MyPackageCommand { Action = 1 });\n\n// Or send with individual field values\nawait myPackageSdk.SendCommand(action: 1);\n\n// Access underlying SDK for advanced usage\nawait myPackageSdk.Sdk.ConnectAsync();\n</code></pre>"},{"location":"extended-features/csharp-sdk/#message-interface","title":"Message Interface","text":"<p>Generated messages implement <code>IStructFrameMessage&lt;T&gt;</code> which provides:</p> <pre><code>public interface IStructFrameMessage&lt;TSelf&gt; : IStructFrameMessage \n    where TSelf : IStructFrameMessage&lt;TSelf&gt;\n{\n    /// &lt;summary&gt;\n    /// Deserialize a message from frame info (static abstract)\n    /// &lt;/summary&gt;\n    static abstract TSelf Deserialize(FrameMsgInfo frame);\n}\n\npublic interface IStructFrameMessage\n{\n    ushort GetMsgId();\n    int GetSize();\n    byte[] Serialize();\n    (byte Magic1, byte Magic2) GetMagicNumbers();\n}\n</code></pre> <p>This enables compile-time dispatch for deserialization without reflection:</p> <pre><code>// The SDK internally calls T.Deserialize(frame) directly\nsdk.Subscribe&lt;SensorDataMessage&gt;(msg =&gt; {\n    // msg is already deserialized - no reflection needed\n});\n</code></pre>"},{"location":"extended-features/csharp-sdk/#message-registry","title":"Message Registry","text":"<p>The generated code includes a <code>MessageDefinitions</code> class that provides:</p>"},{"location":"extended-features/csharp-sdk/#message-lookup-by-id","title":"Message Lookup by ID","text":"<pre><code>using StructFrame.MyPackage;\n\n// Get message info by ID (required for SDK configuration)\nvar info = MessageDefinitions.GetMessageInfo(SensorDataMessage.MsgId);\nConsole.WriteLine($\"Size: {info?.Size}, Magic: {info?.Magic1:X2}{info?.Magic2:X2}\");\n</code></pre>"},{"location":"extended-features/csharp-sdk/#enumerate-all-messages","title":"Enumerate All Messages","text":"<pre><code>// Get all registered message types\nforeach (var entry in MessageDefinitions.GetAllMessages())\n{\n    Console.WriteLine($\"Message: {entry.Name} (ID: {entry.Id}, Size: {entry.MaxSize})\");\n}\n</code></pre>"},{"location":"extended-features/csharp-sdk/#transports","title":"Transports","text":""},{"location":"extended-features/csharp-sdk/#tcp","title":"TCP","text":"<pre><code>using StructFrame.Sdk;\n\nvar transport = new TcpTransport(\"192.168.1.100\", 8080);\nawait transport.ConnectAsync();\nawait transport.SendAsync(data);\n</code></pre>"},{"location":"extended-features/csharp-sdk/#udp","title":"UDP","text":"<pre><code>using StructFrame.Sdk;\n\nvar transport = new UdpTransport(\"192.168.1.100\", 8080);\nawait transport.ConnectAsync();\nawait transport.SendAsync(data);\n</code></pre>"},{"location":"extended-features/csharp-sdk/#serial","title":"Serial","text":"<p>The serial transport uses <code>System.IO.Ports.SerialPort.BaseStream</code> for reliable async reading, which is more robust than the event-based <code>DataReceived</code> approach.</p> <pre><code>using StructFrame.Sdk;\n\nvar config = new SerialTransportConfig\n{\n    PortName = \"COM3\",\n    BaudRate = 115200,\n    DataBits = 8,\n    Parity = System.IO.Ports.Parity.None,\n    StopBits = System.IO.Ports.StopBits.One\n};\n\nvar transport = new SerialTransport(config);\nawait transport.ConnectAsync();\nawait transport.SendAsync(data);\n</code></pre>"},{"location":"extended-features/csharp-sdk/#asyncawait-patterns","title":"Async/Await Patterns","text":"<pre><code>public async Task RunAsync()\n{\n    var config = new StructFrameSdkConfig(\n        transport: new TcpTransport(\"localhost\", 8080),\n        getMessageInfo: MessageDefinitions.GetMessageInfo\n    );\n\n    var sdk = new StructFrameSdk(config);\n\n    sdk.Subscribe&lt;StatusMessage&gt;(HandleStatus);\n\n    await sdk.ConnectAsync();\n\n    // SDK handles incoming data automatically via transport events\n    // Send messages as needed\n    await sdk.SendAsync(new CommandMessage { Action = 1 });\n}\n\nvoid HandleStatus(StatusMessage msg)\n{\n    Console.WriteLine($\"Received status: {msg.Code}\");\n}\n</code></pre>"},{"location":"extended-features/csharp-sdk/#envelope-message-support","title":"Envelope Message Support","text":"<p>When you have envelope messages (messages with <code>is_envelope = true</code>), the SDK generates convenient helper methods:</p> <pre><code>using StructFrame.MyPackage.Sdk;\n\n// Create the SDK interface\nvar sdk = new MyPackageSdkInterface(baseSdk);\n\n// Send a payload wrapped in an envelope - multiple overloads available:\n\n// Overload 1: Pass the message object plus envelope fields\nvar adcCmd = new ADCCommand { Channel = 1, SampleRate = 1000, Enable = true };\nawait sdk.SendADCCommandViaCommandEnvelope(adcCmd, sequenceNumber: 42, priority: 1, runImmediately: true);\n\n// Overload 2: Pass all fields flat (payload fields + envelope fields)\nawait sdk.SendADCCommandViaCommandEnvelope(\n    channel: 1,\n    sampleRate: 1000,\n    enable: true,\n    sequenceNumber: 42,\n    priority: 1,\n    runImmediately: true\n);\n</code></pre> <p>The naming convention is <code>Send{PayloadType}Via{EnvelopeName}</code>. This pattern:</p> <ul> <li>Automatically wraps the payload in the envelope message</li> <li>Sets the discriminator field correctly (msgid or field_order)</li> <li>Handles serialization and framing</li> <li>Works with both <code>msgid</code> and <code>field_order</code> discriminator types</li> </ul>"},{"location":"extended-features/csharp-sdk/#net-platform-support","title":".NET Platform Support","text":"<p>The SDK requires .NET 7.0+ due to the use of C# 11 static abstract interface members:</p> <ul> <li>.NET 7.0+</li> <li>.NET 8.0+</li> <li>.NET 9.0+</li> </ul>"},{"location":"extended-features/custom-features/","title":"Extended Features","text":"<p>This page covers advanced scenarios for special use cases.</p>"},{"location":"extended-features/custom-features/#package-ids-for-extended-addressing","title":"Package IDs for Extended Addressing","text":"<p>Package IDs enable 16-bit message addressing for large systems.</p> <p>When to use: - Systems with more than 255 messages - Multi-package systems requiring namespace separation</p> <p>Frame compatibility: Use Extended or ExtendedMultiSystemStream payload types with package IDs.</p> <p>Message ID encoding: - Without pkgid: 8-bit (0-255) - With pkgid: 16-bit = <code>(package_id &lt;&lt; 8) | msg_id</code></p> <p>See Message Definitions for usage details.</p>"},{"location":"extended-features/custom-features/#minimal-frames-bandwidth-limited-scenarios","title":"Minimal Frames (Bandwidth-Limited Scenarios)","text":"<p>Minimal frames remove length and checksum fields for lowest overhead.</p> <p>Requirements: - All messages must be fixed-size (no max_size, only size) - Parser needs message length lookup function</p> <p>The generator creates a <code>get_msg_info</code> function automatically:</p> PythonC++ <pre><code>from struct_frame.frame_profiles import get_profile, Profile\nfrom messages import get_msg_info\n\n# Get minimal profile\nprofile = get_profile(Profile.SENSOR)  # TinyMinimal\n\n# Parser uses auto-generated get_msg_info\nparser = profile.create_parser(get_msg_info)\n</code></pre> <pre><code>#include \"FrameProfiles.hpp\"\n#include \"messages.structframe.hpp\"\n\n// Use sensor profile with minimal frames\nProfileSensorAccumulatingReader reader(get_msg_info);\n</code></pre> <p>See Framing for more on minimal frames.</p>"},{"location":"extended-features/custom-features/#large-messages","title":"Large Messages","text":"<p>For messages &gt; 255 bytes, use Extended payload type:</p> <pre><code>python -m struct_frame large.proto --build_c\n</code></pre> <p>Use BasicExtended or Network frame profile when encoding.</p>"},{"location":"extended-features/custom-features/#variable-length-encoding","title":"Variable-Length Encoding","text":"<p>Use <code>option variable = true;</code> for efficient encoding of messages with variable-length arrays or strings:</p> <pre><code>message LogEntry {\n  option msgid = 10;\n  option variable = true;\n  uint64 timestamp = 1;\n  string message = 2 [max_size=256];\n  repeated uint8 data = 3 [max_size=128];\n}\n</code></pre> <p>Only used bytes are transmitted instead of full max_size. See Message Definitions for details.</p>"},{"location":"extended-features/python-sdk/","title":"Python SDK","text":"<p>The Python SDK provides both synchronous and asynchronous interfaces for message communication.</p>"},{"location":"extended-features/python-sdk/#installation","title":"Installation","text":"<p>Generate with SDK:</p> <pre><code>python -m struct_frame messages.proto --build_py --py_path generated/ --sdk\n</code></pre>"},{"location":"extended-features/python-sdk/#parser-usage","title":"Parser Usage","text":"<pre><code>from struct_frame_parser import Parser, HeaderType, PayloadType\nfrom messages_sf import Status\n\n# Create parser\nparser = Parser()\n\n# Encode\nframe = parser.encode_basic(msg_id=1, msg=Status(value=42).to_bytes())\n\n# Decode\nfor byte in frame:\n    result = parser.parse_byte(byte)\n    if result.valid:\n        msg = Status.from_bytes(result.msg_data)\n        print(f\"Status: {msg.value}\")\n</code></pre>"},{"location":"extended-features/python-sdk/#message-router","title":"Message Router","text":"<pre><code>from struct_frame_sdk import MessageRouter\nfrom messages_sf import Status\n\nrouter = MessageRouter()\n\n# Subscribe to messages\n@router.subscribe(Status)\ndef handle_status(msg: Status):\n    print(f\"Status: {msg.value}\")\n\n# Process incoming data\nrouter.process_byte(byte)\n</code></pre>"},{"location":"extended-features/python-sdk/#transports","title":"Transports","text":""},{"location":"extended-features/python-sdk/#serial","title":"Serial","text":"<pre><code>import serial\nfrom struct_frame_sdk.transports import SerialTransport\n\ntransport = SerialTransport('/dev/ttyUSB0', 115200)\ntransport.connect()\ntransport.send(msg_id, data)\n</code></pre>"},{"location":"extended-features/python-sdk/#socket","title":"Socket","text":"<pre><code>import socket\nfrom struct_frame_sdk.transports import SocketTransport\n\ntransport = SocketTransport('192.168.1.100', 8080)\ntransport.connect()\ntransport.send(msg_id, data)\n</code></pre>"},{"location":"extended-features/python-sdk/#async-support","title":"Async Support","text":"<pre><code>import asyncio\nfrom struct_frame_sdk.async_transports import AsyncSerialTransport\n\nasync def main():\n    transport = AsyncSerialTransport('/dev/ttyUSB0', 115200)\n    await transport.connect()\n    await transport.send(msg_id, data)\n\nasyncio.run(main())\n</code></pre>"},{"location":"extended-features/sdk-overview/","title":"SDK Overview","text":"<p>The SDK provides high-level abstractions for message communication, including transport layers and message routing.</p>"},{"location":"extended-features/sdk-overview/#what-the-sdk-provides","title":"What the SDK Provides","text":"<ul> <li>Transport abstractions (UDP, TCP, Serial, WebSocket)</li> <li>Message routing and handlers</li> <li>Observer/subscriber patterns</li> <li>Asynchronous I/O (where supported)</li> </ul>"},{"location":"extended-features/sdk-overview/#when-to-use-the-sdk","title":"When to Use the SDK","text":"<p>Use the SDK when: - Building applications that communicate over networks or serial - Need transport abstraction (switch between UDP/TCP/Serial easily) - Want message routing and handler registration</p> <p>Use code generation only when: - Implementing custom communication protocols - Working in resource-constrained environments - Need full control over message handling</p>"},{"location":"extended-features/sdk-overview/#sdk-availability","title":"SDK Availability","text":"Language SDK Transports C++ \u2713 Serial, UDP, TCP, WebSocket (via ASIO) TypeScript/JavaScript \u2713 UDP, TCP, WebSocket, Serial Python \u2713 Serial, sockets, WebSocket C# \u2713 UDP, TCP, Serial C - N/A"},{"location":"extended-features/sdk-overview/#generating-with-sdk","title":"Generating with SDK","text":"<pre><code># C++ with full SDK (includes ASIO)\npython -m struct_frame messages.proto --build_cpp --sdk\n\n# C++ embedded SDK (no external dependencies)\npython -m struct_frame messages.proto --build_cpp --sdk_embedded\n\n# TypeScript with SDK\npython -m struct_frame messages.proto --build_ts --sdk\n\n# Python with SDK\npython -m struct_frame messages.proto --build_py --sdk\n</code></pre>"},{"location":"extended-features/sdk-overview/#language-specific-guides","title":"Language-Specific Guides","text":"<ul> <li>C++ SDK</li> <li>TypeScript/JavaScript SDK</li> <li>Python SDK</li> <li>C# SDK</li> </ul>"},{"location":"extended-features/typescript-sdk/","title":"TypeScript/JavaScript SDK","text":"<p>The TypeScript/JavaScript SDK provides promise-based transport layers for Node.js and browser environments.</p>"},{"location":"extended-features/typescript-sdk/#installation","title":"Installation","text":"<p>Generate with SDK:</p> <pre><code>python -m struct_frame messages.proto --build_ts --ts_path src/generated/ --sdk\n</code></pre>"},{"location":"extended-features/typescript-sdk/#basic-usage","title":"Basic Usage","text":"<pre><code>import { MessageRouter } from './generated/ts/struct_frame_sdk';\nimport { Status } from './generated/ts/messages.sf';\n\nconst router = new MessageRouter();\n\n// Subscribe to messages\nrouter.subscribe(Status, (msg: Status) =&gt; {\n    console.log(`Status: ${msg.value}`);\n});\n\n// Process incoming data\nrouter.processByte(byte);\n</code></pre>"},{"location":"extended-features/typescript-sdk/#transports","title":"Transports","text":""},{"location":"extended-features/typescript-sdk/#udp","title":"UDP","text":"<pre><code>import { UDPTransport } from './generated/ts/struct_frame_sdk/transports';\n\nconst transport = new UDPTransport('192.168.1.100', 8080);\nawait transport.connect();\nawait transport.send(msgId, data);\n</code></pre>"},{"location":"extended-features/typescript-sdk/#tcp","title":"TCP","text":"<pre><code>import { TCPTransport } from './generated/ts/struct_frame_sdk/transports';\n\nconst transport = new TCPTransport('192.168.1.100', 8080);\nawait transport.connect();\nawait transport.send(msgId, data);\n</code></pre>"},{"location":"extended-features/typescript-sdk/#websocket","title":"WebSocket","text":"<pre><code>import { WebSocketTransport } from './generated/ts/struct_frame_sdk/transports';\n\nconst transport = new WebSocketTransport('ws://localhost:8080');\nawait transport.connect();\nawait transport.send(msgId, data);\n</code></pre>"},{"location":"extended-features/typescript-sdk/#serial-nodejs-only","title":"Serial (Node.js only)","text":"<pre><code>import { SerialTransport } from './generated/ts/struct_frame_sdk/transports';\n\nconst transport = new SerialTransport('/dev/ttyUSB0', 115200);\nawait transport.connect();\nawait transport.send(msgId, data);\n</code></pre>"},{"location":"extended-features/typescript-sdk/#browser-vs-nodejs","title":"Browser vs Node.js","text":"<p>The SDK works in both environments:</p> <ul> <li>Node.js: Full support including Serial transport</li> <li>Browser: WebSocket and (with polyfills) UDP/TCP</li> </ul> <pre><code>// Detect environment\nif (typeof window === 'undefined') {\n    // Node.js\n    import { SerialTransport } from './struct_frame_sdk/transports';\n} else {\n    // Browser\n    import { WebSocketTransport } from './struct_frame_sdk/transports';\n}\n</code></pre>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>Install via pip:</p> <pre><code>pip install struct-frame\n</code></pre> <p>The package name is <code>struct-frame</code>, but the Python module uses <code>struct_frame</code>:</p> <pre><code>python -m struct_frame --help\n</code></pre>"},{"location":"getting-started/installation/#language-specific-requirements","title":"Language-Specific Requirements","text":"<p>Depending on which languages you plan to use:</p> <ul> <li>C: GCC or compatible C compiler</li> <li>C++: G++ with C++17 support or later</li> <li>TypeScript/JavaScript: Node.js and npm</li> <li>Python: Python 3.8 or later (already required for code generation)</li> <li>C#: .NET SDK</li> <li>GraphQL: Any GraphQL server implementation</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide shows you how to create a simple message, generate code, and use it in C++.</p>"},{"location":"getting-started/quick-start/#1-create-a-proto-file","title":"1. Create a Proto File","text":"<p>Create a file called <code>status.proto</code>:</p> <pre><code>package example;\n\nmessage Status {\n  option msgid = 1;\n  uint32 id = 1;\n  float value = 2;\n}\n</code></pre>"},{"location":"getting-started/quick-start/#2-generate-code","title":"2. Generate Code","text":"<p>Generate C++ code from the proto file:</p> <pre><code>python -m struct_frame status.proto --build_cpp --cpp_path generated/\n</code></pre> <p>This creates <code>generated/example.structframe.hpp</code> (note: package name is prefixed to the message name).</p>"},{"location":"getting-started/quick-start/#3-use-the-generated-code","title":"3. Use the Generated Code","text":"<p>Here's a simple C++ example that encodes and parses a message:</p> <pre><code>#include \"example.structframe.hpp\"\n#include &lt;iostream&gt;\n\nint main() {\n    // Create and populate a message (note: ExampleStatus, not Status)\n    ExampleStatus status;\n    status.id = 42;\n    status.value = 3.14f;\n\n    // The message is already in binary format - no encoding needed!\n    // Just get a pointer to the struct\n    uint8_t* buffer = (uint8_t*)&amp;status;\n    size_t size = sizeof(ExampleStatus);\n\n    // Send buffer over serial, network, etc.\n    // ...\n\n    // On the receiving side, cast the buffer back to the struct\n    ExampleStatus* received = (ExampleStatus*)buffer;\n    std::cout &lt;&lt; \"ID: \" &lt;&lt; received-&gt;id &lt;&lt; std::endl;\n    std::cout &lt;&lt; \"Value: \" &lt;&lt; received-&gt;value &lt;&lt; std::endl;\n\n    return 0;\n}\n</code></pre> <p>Compile and run: <pre><code>g++ -std=c++17 -I generated/ main.cpp -o main\n./main\n</code></pre></p> <p>That's it! The C/C++ implementation uses packed structs that map directly to memory, so there's no encoding or decoding overhead.</p>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Message Definitions - Learn how to write proto files</li> <li>Language Examples - See examples for other languages</li> <li>Framing - Add framing for reliable communication</li> </ul>"},{"location":"reference/build-integration/","title":"Build Integration","text":"<p>Integrate code generation into your build system so generated code automatically reflects changes to proto files.</p>"},{"location":"reference/build-integration/#make-cc","title":"Make (C/C++)","text":"<pre><code>PROTO_FILES := $(wildcard proto/*.proto)\nGENERATED_DIR := generated\n\ngenerated/c/%.sf.h: proto/%.proto\n    python -m struct_frame $&lt; --build_c --c_path generated/c/\n\ngenerated/py/%.sf.py: proto/%.proto\n    python -m struct_frame $&lt; --build_py --py_path generated/py/\n\nall: $(PROTO_FILES:proto/%.proto=generated/c/%.sf.h)\n</code></pre>"},{"location":"reference/build-integration/#cmake-cc","title":"CMake (C/C++)","text":"<pre><code>find_package(Python3 REQUIRED)\n\nset(PROTO_FILES\n    proto/messages.proto\n)\n\nforeach(PROTO_FILE ${PROTO_FILES})\n    get_filename_component(PROTO_NAME ${PROTO_FILE} NAME_WE)\n    set(GENERATED_HEADER \"${CMAKE_BINARY_DIR}/generated/c/${PROTO_NAME}.sf.h\")\n\n    add_custom_command(\n        OUTPUT ${GENERATED_HEADER}\n        COMMAND ${Python3_EXECUTABLE} -m struct_frame\n            ${CMAKE_SOURCE_DIR}/${PROTO_FILE}\n            --build_c --c_path ${CMAKE_BINARY_DIR}/generated/c/\n        DEPENDS ${PROTO_FILE}\n    )\n    list(APPEND GENERATED_HEADERS ${GENERATED_HEADER})\nendforeach()\n\nadd_custom_target(generate_structs DEPENDS ${GENERATED_HEADERS})\n</code></pre>"},{"location":"reference/build-integration/#npm-scripts-typescript","title":"npm scripts (TypeScript)","text":"<p>Add to <code>package.json</code>:</p> <pre><code>{\n  \"scripts\": {\n    \"generate\": \"python -m struct_frame proto/messages.proto --build_ts --ts_path src/generated/\",\n    \"build\": \"npm run generate &amp;&amp; tsc\",\n    \"watch\": \"tsc --watch\"\n  }\n}\n</code></pre>"},{"location":"reference/build-integration/#python-setuptools","title":"Python setuptools","text":"<p>Add to <code>setup.py</code>:</p> <pre><code>from setuptools import setup\nfrom setuptools.command.build_py import build_py\nimport subprocess\n\nclass BuildWithGenerate(build_py):\n    def run(self):\n        subprocess.run([\n            'python', '-m', 'struct_frame', 'proto/messages.proto',\n            '--build_py', '--py_path', 'src/generated/'\n        ])\n        super().run()\n\nsetup(\n    cmdclass={'build_py': BuildWithGenerate},\n    # ...\n)\n</code></pre>"},{"location":"reference/build-integration/#net-c","title":".NET (C#)","text":"<p>Add to <code>.csproj</code> file:</p> <pre><code>&lt;Target Name=\"GenerateStructFrame\" BeforeTargets=\"BeforeBuild\"&gt;\n  &lt;Exec Command=\"python -m struct_frame proto/messages.proto --build_csharp --csharp_path $(ProjectDir)Generated/\" /&gt;\n&lt;/Target&gt;\n</code></pre>"},{"location":"reference/cli-reference/","title":"CLI Reference","text":""},{"location":"reference/cli-reference/#basic-usage","title":"Basic Usage","text":"<pre><code>python -m struct_frame [proto_file] [options]\n</code></pre>"},{"location":"reference/cli-reference/#code-generation-flags","title":"Code Generation Flags","text":"Flag Description <code>--build_c</code> Generate C code <code>--build_cpp</code> Generate C++ code <code>--build_ts</code> Generate TypeScript code <code>--build_py</code> Generate Python code <code>--build_js</code> Generate JavaScript code <code>--build_gql</code> Generate GraphQL schema <code>--build_csharp</code> Generate C# code"},{"location":"reference/cli-reference/#output-path-options","title":"Output Path Options","text":"Flag Description Default <code>--c_path PATH</code> Output directory for C <code>generated/c/</code> <code>--cpp_path PATH</code> Output directory for C++ <code>generated/cpp/</code> <code>--ts_path PATH</code> Output directory for TypeScript <code>generated/ts/</code> <code>--py_path PATH</code> Output directory for Python <code>generated/py/</code> <code>--js_path PATH</code> Output directory for JavaScript <code>generated/js/</code> <code>--gql_path PATH</code> Output directory for GraphQL <code>generated/gql/</code> <code>--csharp_path PATH</code> Output directory for C# <code>generated/csharp/</code>"},{"location":"reference/cli-reference/#sdk-options","title":"SDK Options","text":"Flag Description <code>--sdk</code> Include full SDK with network transports (C++, Python, TypeScript) <code>--sdk_embedded</code> Include embedded SDK without external dependencies (C++ only)"},{"location":"reference/cli-reference/#examples","title":"Examples","text":"<p>Generate C code: <pre><code>python -m struct_frame messages.proto --build_c\n</code></pre></p> <p>Generate multiple languages: <pre><code>python -m struct_frame messages.proto --build_c --build_cpp --build_py\n</code></pre></p> <p>Custom output paths: <pre><code>python -m struct_frame messages.proto --build_c --c_path src/generated/\n</code></pre></p> <p>Generate with SDK: <pre><code>python -m struct_frame messages.proto --build_cpp --sdk\n</code></pre></p>"},{"location":"reference/cli-reference/#generated-files","title":"Generated Files","text":""},{"location":"reference/cli-reference/#c","title":"C","text":"<ul> <li><code>&lt;name&gt;.structframe.h</code> - Message definitions</li> <li>Frame utilities (frame_base.h, frame_headers.h, frame_profiles.h, etc.)</li> </ul>"},{"location":"reference/cli-reference/#c_1","title":"C++","text":"<ul> <li><code>&lt;name&gt;.structframe.hpp</code> - Message definitions</li> <li>Frame utilities (frame_base.hpp, frame_headers.hpp, frame_profiles.hpp, etc.)</li> <li><code>struct_frame_sdk/</code> - SDK files (if <code>--sdk</code> or <code>--sdk_embedded</code> used)</li> </ul>"},{"location":"reference/cli-reference/#typescript","title":"TypeScript","text":"<ul> <li><code>&lt;name&gt;.structframe.ts</code> - Message definitions and classes</li> <li>Frame utilities (frame-base.ts, frame-headers.ts, frame-profiles.ts, etc.)</li> <li><code>struct_frame_sdk/</code> - SDK files (if <code>--sdk</code> used)</li> </ul>"},{"location":"reference/cli-reference/#python","title":"Python","text":"<ul> <li><code>struct_frame/generated/&lt;name&gt;.py</code> - Message definitions and classes</li> <li>Frame utilities (init.py, frame_base.py, frame_profiles.py, etc.)</li> <li><code>struct_frame_sdk/</code> - SDK files (if <code>--sdk</code> used)</li> </ul>"},{"location":"reference/cli-reference/#javascript","title":"JavaScript","text":"<ul> <li><code>&lt;name&gt;.structframe.js</code> - Message definitions and classes</li> <li>Frame parsing utilities</li> </ul>"},{"location":"reference/cli-reference/#graphql","title":"GraphQL","text":"<ul> <li><code>&lt;name&gt;.structframe.graphql</code> - GraphQL schema definitions</li> </ul>"},{"location":"reference/cli-reference/#c_2","title":"C","text":"<ul> <li><code>&lt;name&gt;.structframe.cs</code> - Message definitions and classes</li> <li>Frame parsing utilities</li> </ul>"},{"location":"reference/development/","title":"Development","text":""},{"location":"reference/development/#setting-up-development-environment","title":"Setting Up Development Environment","text":"<p>Clone the repository and install dependencies:</p> <pre><code>git clone https://github.com/mylonics/struct-frame.git\ncd struct-frame\n\n# Install Python dependencies\npip install proto-schema-parser\n\n# Install Node.js dependencies (for TypeScript tests)\nnpm install\n</code></pre>"},{"location":"reference/development/#running-from-source","title":"Running from Source","text":"<pre><code># Using PYTHONPATH\nPYTHONPATH=src python src/main.py examples/test.proto --build_py\n\n# Or install in editable mode\npip install -e .\npython -m struct_frame examples/test.proto --build_py\n</code></pre>"},{"location":"reference/development/#project-structure","title":"Project Structure","text":"<pre><code>struct-frame/\n  src/\n    main.py                 # CLI entry point\n    struct_frame/\n      generate.py           # Proto parsing and validation\n      c_gen.py              # C code generator\n      cpp_gen.py            # C++ code generator\n      ts_gen.py             # TypeScript code generator\n      py_gen.py             # Python code generator\n      js_gen.py             # JavaScript code generator\n      gql_gen.py            # GraphQL code generator\n      csharp_gen.py         # C# code generator\n      boilerplate/          # Runtime library templates\n        c/\n        cpp/\n        ts/\n        py/\n        js/\n        csharp/\n  tests/\n    run_tests.py            # Test runner entry point\n    proto/                  # Test proto definitions\n    c/, cpp/, py/, ts/      # Language-specific tests\n  examples/                 # Example proto files\n  docs/                     # Documentation\n</code></pre>"},{"location":"reference/development/#code-generation-pipeline","title":"Code Generation Pipeline","text":"<ol> <li>Parsing: Read proto file using proto-schema-parser</li> <li>Validation: Check schema (unique IDs, field numbers, required options)</li> <li>Generation: Language-specific generators produce output files</li> <li>Boilerplate: Runtime libraries are copied to output directories</li> </ol>"},{"location":"reference/development/#making-changes","title":"Making Changes","text":""},{"location":"reference/development/#modifying-generators","title":"Modifying Generators","text":"<p>Each language has a generator in <code>src/struct_frame/&lt;lang&gt;_gen.py</code>. Generators must implement:</p> <ul> <li>Type mapping from proto types to target language types</li> <li>Message struct/class generation</li> <li>Enum generation</li> <li>Array handling (fixed and bounded)</li> <li>String handling</li> <li>Serialization/deserialization code</li> </ul>"},{"location":"reference/development/#adding-a-new-target-language","title":"Adding a New Target Language","text":"<ol> <li>Create <code>&lt;lang&gt;_gen.py</code> in <code>src/struct_frame/</code></li> <li>Implement the generator class</li> <li>Add boilerplate files to <code>src/struct_frame/boilerplate/&lt;lang&gt;/</code></li> <li>Add CLI flag in <code>src/main.py</code></li> <li>Add tests in <code>tests/&lt;lang&gt;/</code></li> <li>Update <code>tests/test_config.json</code></li> </ol>"},{"location":"reference/development/#building-for-release","title":"Building for Release","text":"<pre><code># Update version in pyproject.toml\npip install --upgrade build twine\npython -m build\npython -m twine upload dist/*\n</code></pre>"},{"location":"reference/development/#common-development-tasks","title":"Common Development Tasks","text":""},{"location":"reference/development/#regenerate-all-examples","title":"Regenerate All Examples","text":"<pre><code>PYTHONPATH=src python src/main.py examples/generic_robot.proto \\\n    --build_c --build_cpp --build_ts --build_py --build_gql\n</code></pre>"},{"location":"reference/development/#run-quick-validation","title":"Run Quick Validation","text":"<pre><code># Generate and check for errors\nPYTHONPATH=src python src/main.py examples/array_test.proto --build_py\n\n# Import generated code\npython -c \"import sys; sys.path.insert(0, 'generated/py'); import array_test_sf\"\n</code></pre>"},{"location":"reference/development/#code-style","title":"Code Style","text":"<ul> <li>Python: Follow existing style in codebase</li> <li>C: See <code>.clang-format</code></li> <li>Generated code should be readable and debuggable</li> </ul>"},{"location":"reference/testing/","title":"Testing","text":""},{"location":"reference/testing/#running-tests","title":"Running Tests","text":"<p>From the project root:</p> <pre><code># Run all tests\npython test_all.py\n\n# Or use the test runner directly\npython tests/run_tests.py\n</code></pre>"},{"location":"reference/testing/#test-runner-options","title":"Test Runner Options","text":"<pre><code>python tests/run_tests.py [options]\n\nOptions:\n  --verbose, -v       Show detailed output\n  --skip-lang LANG    Skip a language (c, cpp, py, ts, js, csharp, gql)\n  --only-generate     Generate code only, skip tests\n  --check-tools       Check tool availability only\n  --clean             Clean generated and compiled files\n</code></pre> <p>Examples:</p> <pre><code># Skip TypeScript tests\npython tests/run_tests.py --skip-lang ts\n\n# Only check if compilers are installed\npython tests/run_tests.py --check-tools\n\n# Generate code without running tests\npython tests/run_tests.py --only-generate\n</code></pre>"},{"location":"reference/testing/#test-prerequisites","title":"Test Prerequisites","text":"<p>Python 3.8+ with: <pre><code>pip install proto-schema-parser\n</code></pre></p> <p>C tests: GCC <pre><code># Ubuntu/Debian\nsudo apt install gcc\n\n# macOS\nxcode-select --install\n</code></pre></p> <p>C++ tests: G++ with C++14 support <pre><code># Ubuntu/Debian\nsudo apt install g++\n\n# macOS\nxcode-select --install\n</code></pre></p> <p>TypeScript/JavaScript tests: Node.js + npm <pre><code># Ubuntu/Debian\nsudo apt install nodejs npm\n\n# macOS\nbrew install node\n\n# Then install dependencies\ncd tests/ts &amp;&amp; npm install\n</code></pre></p> <p>C# tests: .NET SDK 8.0+ <pre><code># Ubuntu/Debian\nsudo apt install dotnet-sdk-8.0\n\n# macOS\nbrew install dotnet-sdk\n</code></pre></p>"},{"location":"reference/testing/#test-types","title":"Test Types","text":""},{"location":"reference/testing/#basic-types-test","title":"Basic Types Test","text":"<p>Validates serialization of primitive types (integers, floats, booleans, strings).</p>"},{"location":"reference/testing/#array-operations-test","title":"Array Operations Test","text":"<p>Validates array serialization (fixed arrays, bounded arrays, nested arrays).</p>"},{"location":"reference/testing/#cross-platform-compatibility","title":"Cross-Platform Compatibility","text":"<p>Tests interoperability between languages. Produces a compatibility matrix showing which language pairs can exchange data.</p>"},{"location":"reference/testing/#adding-a-new-test","title":"Adding a New Test","text":"<ol> <li>Add test to <code>tests/test_suites.json</code></li> <li>Create test files in <code>tests/&lt;lang&gt;/</code></li> <li>Follow test output format:</li> <li>Print <code>[TEST START] &lt;Language&gt; &lt;Test Name&gt;</code></li> <li>Print <code>[TEST END] &lt;Language&gt; &lt;Test Name&gt;: PASS</code> or <code>FAIL</code></li> <li>Exit with code 0 on success, 1 on failure</li> </ol>"},{"location":"reference/testing/#ci-integration","title":"CI Integration","text":"<p>GitHub Actions runs tests on every push to main and every pull request. Artifacts are available for download for 5 days after each run.</p>"},{"location":"theme_overrides/","title":"Mylonics MkDocs Theme","text":"<p>A custom MkDocs Material theme override for Mylonics documentation sites.</p>"},{"location":"theme_overrides/#features","title":"Features","text":"<ul> <li>Custom K2D font branding for header</li> <li>Styled header with gray color scheme</li> <li>SEO optimizations (Open Graph, Twitter Cards, structured data)</li> <li>Clean minimal design matching mylonics.com</li> </ul>"},{"location":"theme_overrides/#usage","title":"Usage","text":""},{"location":"theme_overrides/#as-a-git-submodule","title":"As a Git Submodule","text":"<p>Add this theme to your MkDocs project as a submodule:</p> <pre><code>git submodule add https://github.com/mylonics/mylonics-mkdocs-theme docs/theme_overrides\n</code></pre> <p>Then in your <code>mkdocs.yml</code>:</p> <pre><code>theme:\n  name: material\n  custom_dir: docs/theme_overrides\n</code></pre>"},{"location":"theme_overrides/#updating-the-theme","title":"Updating the Theme","text":"<p>To update to the latest version:</p> <pre><code>git submodule update --remote docs/theme_overrides\n</code></pre>"},{"location":"theme_overrides/#cloning-a-project-with-this-submodule","title":"Cloning a Project with this Submodule","text":"<p>When cloning a project that uses this theme:</p> <pre><code>git clone --recurse-submodules &lt;your-repo-url&gt;\n</code></pre> <p>Or if already cloned:</p> <pre><code>git submodule init\ngit submodule update\n</code></pre>"},{"location":"theme_overrides/#customization","title":"Customization","text":"<p>The theme extends Material for MkDocs with these overrides:</p> <ul> <li><code>main.html</code> - Custom meta tags, fonts, and SEO structured data</li> <li><code>partials/header.html</code> - Custom header with page.title display</li> <li><code>assets/stylesheets/extra.css</code> - Custom styling</li> </ul>"},{"location":"theme_overrides/#requirements","title":"Requirements","text":"<ul> <li>MkDocs &gt;= 1.5.0</li> <li>mkdocs-material &gt;= 9.0.0</li> </ul>"},{"location":"theme_overrides/#license","title":"License","text":"<p>MIT License - Copyright (c) 2025 Mylonics</p>"}]}