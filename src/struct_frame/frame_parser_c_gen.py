#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
C Frame Parser Generator

Generates C code for frame parsers based on frame format definitions.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class FrameParserCGen:
    """Generates C code for frame parsers"""
    
    @staticmethod
    def generate_header(formats):
        """Generate the complete frame parser header file"""
        yield '/* Automatically generated frame parser header */\n'
        yield '/* Generated by %s at %s. */\n\n' % (version, time.asctime())
        yield '#pragma once\n\n'
        yield '#include <stdbool.h>\n'
        yield '#include <stddef.h>\n'
        yield '#include <stdint.h>\n'
        yield '#include <string.h>\n\n'
        
        # Generate frame format enum
        yield '/* Frame format type enumeration */\n'
        yield 'typedef enum FrameFormatType {\n'
        for i, fmt in enumerate(formats):
            enum_name = camel_to_upper_snake(fmt.name)
            yield f'    FRAME_FORMAT_{enum_name} = {i},\n'
        yield '} FrameFormatType;\n\n'
        
        # Generate checksum function
        yield '/*===========================================================================\n'
        yield ' * Checksum Calculation\n'
        yield ' *===========================================================================*/\n\n'
        yield '''typedef struct frame_checksum {
    uint8_t byte1;
    uint8_t byte2;
} frame_checksum_t;

/**
 * Calculate Fletcher-16 checksum over the given data
 */
static inline frame_checksum_t frame_fletcher_checksum(const uint8_t* data, size_t length) {
    frame_checksum_t ck = {0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = (uint8_t)(ck.byte1 + data[i]);
        ck.byte2 = (uint8_t)(ck.byte2 + ck.byte1);
    }
    return ck;
}

'''
        
        # Generate common result type
        yield '''/* Parse result */
typedef struct frame_msg_info {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
} frame_msg_info_t;

'''
        
        # Generate individual frame format code
        for fmt in formats:
            yield from FrameParserCGen.generate_format(fmt)
            yield '\n'
            
    @staticmethod
    def generate_format(fmt):
        """Generate C code for a single frame format"""
        name = fmt.name
        prefix = camel_to_snake(name)
        PREFIX = camel_to_upper_snake(name)
        
        # Skip formats without start bytes (they need external sync)
        # But still generate encode/decode helpers
        
        yield f'/*===========================================================================\n'
        yield f' * {name} Frame Format\n'
        yield f' *===========================================================================*/\n\n'
        
        # Generate constants
        yield f'/* {name} constants */\n'
        
        # Start bytes
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            yield f'#define {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}    0x{sb_value:02X}\n'
            
        yield f'#define {PREFIX}_HEADER_SIZE    {fmt.header_size}  /* '
        parts = []
        for sb_name, sb_value in fmt.start_bytes:
            parts.append(f'{sb_name}')
        parts.append('msg_id')
        if fmt.has_length:
            parts.append(f'length({fmt.length_bytes})')
        yield ' + '.join(parts) + ' */\n'
        
        yield f'#define {PREFIX}_FOOTER_SIZE    {fmt.footer_size}  /* '
        if fmt.has_crc:
            yield f'crc({fmt.crc_bytes} bytes)'
        else:
            yield 'no footer'
        yield ' */\n'
        
        yield f'#define {PREFIX}_OVERHEAD       ({PREFIX}_HEADER_SIZE + {PREFIX}_FOOTER_SIZE)\n\n'
        
        # Generate parser state enum
        yield f'/* {name} parser states */\n'
        yield f'typedef enum {prefix}_parser_state {{\n'
        
        # State machine states
        if fmt.start_bytes:
            for i in range(len(fmt.start_bytes)):
                yield f'    {PREFIX}_LOOKING_FOR_START{i + 1 if len(fmt.start_bytes) > 1 else ""} = {i},\n'
            state_idx = len(fmt.start_bytes)
        else:
            state_idx = 0
            
        yield f'    {PREFIX}_GETTING_MSG_ID = {state_idx},\n'
        state_idx += 1
        
        if fmt.has_length:
            yield f'    {PREFIX}_GETTING_LENGTH = {state_idx},\n'
            state_idx += 1
            
        yield f'    {PREFIX}_GETTING_PAYLOAD = {state_idx}\n'
        yield f'}} {prefix}_parser_state_t;\n\n'
        
        # Generate parser structure
        yield f'/* {name} parser state structure */\n'
        yield f'typedef struct {prefix}_parser {{\n'
        yield f'    {prefix}_parser_state_t state;\n'
        yield f'    uint8_t* buffer;\n'
        yield f'    size_t buffer_max_size;\n'
        yield f'    size_t buffer_index;\n'
        yield f'    size_t packet_size;\n'
        yield f'    uint8_t msg_id;\n'
        if fmt.has_length:
            yield f'    size_t msg_length;  /* From length field */\n'
            if fmt.length_bytes == 2:
                yield f'    uint8_t length_lo;  /* Low byte for 16-bit length */\n'
        yield f'    /* User-provided function to get message length from msg_id (for non-length frames) */\n'
        yield f'    bool (*get_msg_length)(uint8_t msg_id, size_t* length);\n'
        yield f'}} {prefix}_parser_t;\n\n'
        
        # Generate encode buffer structure
        yield f'/* {name} encode buffer structure */\n'
        yield f'typedef struct {prefix}_encode_buffer {{\n'
        yield f'    uint8_t* data;\n'
        yield f'    size_t max_size;\n'
        yield f'    size_t size;\n'
        yield f'    bool in_progress;\n'
        yield f'    size_t reserved_msg_size;\n'
        yield f'}} {prefix}_encode_buffer_t;\n\n'
        
        # Generate init function
        yield f'/**\n'
        yield f' * Initialize a {name} parser\n'
        yield f' */\n'
        yield f'static inline void {prefix}_parser_init({prefix}_parser_t* parser,\n'
        yield f'                                        uint8_t* buffer, size_t buffer_size,\n'
        yield f'                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {{\n'
        if fmt.start_bytes:
            yield f'    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'    parser->buffer = buffer;\n'
        yield f'    parser->buffer_max_size = buffer_size;\n'
        yield f'    parser->buffer_index = 0;\n'
        yield f'    parser->packet_size = 0;\n'
        yield f'    parser->msg_id = 0;\n'
        if fmt.has_length:
            yield f'    parser->msg_length = 0;\n'
            if fmt.length_bytes == 2:
                yield f'    parser->length_lo = 0;\n'
        yield f'    parser->get_msg_length = get_msg_length;\n'
        yield f'}}\n\n'
        
        # Generate reset function
        yield f'/**\n'
        yield f' * Reset {name} parser state\n'
        yield f' */\n'
        yield f'static inline void {prefix}_parser_reset({prefix}_parser_t* parser) {{\n'
        if fmt.start_bytes:
            yield f'    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'    parser->buffer_index = 0;\n'
        yield f'    parser->packet_size = 0;\n'
        yield f'    parser->msg_id = 0;\n'
        if fmt.has_length:
            yield f'    parser->msg_length = 0;\n'
        yield f'}}\n\n'
        
        # Generate parse_byte function
        yield f'/**\n'
        yield f' * Parse a single byte with {name} format\n'
        yield f' * Returns frame_msg_info_t with valid=true when a complete valid message is received\n'
        yield f' */\n'
        yield f'static inline frame_msg_info_t {prefix}_parse_byte({prefix}_parser_t* parser, uint8_t byte) {{\n'
        yield f'    frame_msg_info_t result = {{false, 0, 0, NULL}};\n\n'
        yield f'    switch (parser->state) {{\n'
        
        # Generate state machine cases
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                state_name = f'{PREFIX}_LOOKING_FOR_START{i + 1 if len(fmt.start_bytes) > 1 else ""}'
                yield f'        case {state_name}:\n'
                yield f'            if (byte == {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}) {{\n'
                yield f'                parser->buffer[{i}] = byte;\n'
                yield f'                parser->buffer_index = {i + 1};\n'
                
                if i + 1 < len(fmt.start_bytes):
                    next_state = f'{PREFIX}_LOOKING_FOR_START{i + 2}'
                else:
                    next_state = f'{PREFIX}_GETTING_MSG_ID'
                yield f'                parser->state = {next_state};\n'
                
                yield f'            }}'
                
                # Handle case where we see start byte 1 while looking for start byte 2
                # This code only runs when len(fmt.start_bytes) > 1 (i.e., i > 0 is only possible with 2+ start bytes)
                if i > 0:
                    yield f' else if (byte == {PREFIX}_START_BYTE1) {{\n'
                    yield f'                parser->buffer[0] = byte;\n'
                    yield f'                parser->buffer_index = 1;\n'
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START2;\n'
                    yield f'            }} else {{\n'
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START1;\n'
                    yield f'            }}\n'
                else:
                    yield '\n'
                yield f'            break;\n\n'
        
        # MSG_ID state
        yield f'        case {PREFIX}_GETTING_MSG_ID:\n'
        yield f'            parser->buffer[parser->buffer_index++] = byte;\n'
        yield f'            parser->msg_id = byte;\n'
        
        if fmt.has_length:
            yield f'            parser->state = {PREFIX}_GETTING_LENGTH;\n'
        else:
            yield f'            {{\n'
            yield f'                size_t msg_length = 0;\n'
            yield f'                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {{\n'
            yield f'                    parser->packet_size = {PREFIX}_OVERHEAD + msg_length;\n'
            yield f'                    if (parser->packet_size <= parser->buffer_max_size) {{\n'
            yield f'                        parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
            yield f'                    }} else {{\n'
            if fmt.start_bytes:
                yield f'                        parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
            else:
                yield f'                        parser->state = {PREFIX}_GETTING_MSG_ID;\n'
            yield f'                    }}\n'
            yield f'                }} else {{\n'
            if fmt.start_bytes:
                yield f'                    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
            else:
                yield f'                    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
            yield f'                }}\n'
            yield f'            }}\n'
        yield f'            break;\n\n'
        
        # LENGTH state (if applicable)
        if fmt.has_length:
            yield f'        case {PREFIX}_GETTING_LENGTH:\n'
            yield f'            parser->buffer[parser->buffer_index++] = byte;\n'
            if fmt.length_bytes == 1:
                yield f'            parser->msg_length = byte;\n'
                yield f'            parser->packet_size = {PREFIX}_OVERHEAD + parser->msg_length;\n'
                yield f'            if (parser->packet_size <= parser->buffer_max_size) {{\n'
                yield f'                parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
                yield f'            }} else {{\n'
                if fmt.start_bytes:
                    yield f'                parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
                else:
                    yield f'                parser->state = {PREFIX}_GETTING_MSG_ID;\n'
                yield f'            }}\n'
            else:
                # 16-bit length
                yield f'            if (parser->buffer_index == {len(fmt.start_bytes) + 2}) {{\n'
                yield f'                parser->length_lo = byte;\n'
                yield f'            }} else {{\n'
                yield f'                parser->msg_length = parser->length_lo | ((size_t)byte << 8);\n'
                yield f'                parser->packet_size = {PREFIX}_OVERHEAD + parser->msg_length;\n'
                yield f'                if (parser->packet_size <= parser->buffer_max_size) {{\n'
                yield f'                    parser->state = {PREFIX}_GETTING_PAYLOAD;\n'
                yield f'                }} else {{\n'
                if fmt.start_bytes:
                    yield f'                    parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
                else:
                    yield f'                    parser->state = {PREFIX}_GETTING_MSG_ID;\n'
                yield f'                }}\n'
                yield f'            }}\n'
            yield f'            break;\n\n'
        
        # PAYLOAD state
        yield f'        case {PREFIX}_GETTING_PAYLOAD:\n'
        yield f'            if (parser->buffer_index < parser->buffer_max_size) {{\n'
        yield f'                parser->buffer[parser->buffer_index++] = byte;\n'
        yield f'            }}\n\n'
        yield f'            if (parser->buffer_index >= parser->packet_size) {{\n'
        
        if fmt.has_crc:
            yield f'                /* Validate checksum */\n'
            yield f'                size_t msg_length = parser->packet_size - {PREFIX}_OVERHEAD;\n'
            yield f'                frame_checksum_t ck = frame_fletcher_checksum(\n'
            yield f'                    parser->buffer + {len(fmt.start_bytes)}, msg_length + 1'
            if fmt.has_length:
                yield f' + {fmt.length_bytes}'
            yield f');\n\n'
            yield f'                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&\n'
            yield f'                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {{\n'
            yield f'                    result.valid = true;\n'
            yield f'                    result.msg_id = parser->msg_id;\n'
            yield f'                    result.msg_len = msg_length;\n'
            yield f'                    result.msg_data = parser->buffer + {PREFIX}_HEADER_SIZE;\n'
            yield f'                }}\n'
        else:
            yield f'                result.valid = true;\n'
            yield f'                result.msg_id = parser->msg_id;\n'
            yield f'                result.msg_len = parser->packet_size - {PREFIX}_OVERHEAD;\n'
            yield f'                result.msg_data = parser->buffer + {PREFIX}_HEADER_SIZE;\n'
        
        if fmt.start_bytes:
            yield f'                parser->state = {PREFIX}_LOOKING_FOR_START{"1" if len(fmt.start_bytes) > 1 else ""};\n'
        else:
            yield f'                parser->state = {PREFIX}_GETTING_MSG_ID;\n'
        yield f'            }}\n'
        yield f'            break;\n'
        
        yield f'    }}\n\n'
        yield f'    return result;\n'
        yield f'}}\n\n'
        
        # Generate encode function
        yield f'/**\n'
        yield f' * Encode a message with {name} format\n'
        yield f' * Returns the number of bytes written, or 0 on failure\n'
        yield f' */\n'
        yield f'static inline size_t {prefix}_encode(uint8_t* buffer, size_t buffer_size,\n'
        yield f'                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {{\n'
        yield f'    size_t total_size = {PREFIX}_OVERHEAD + msg_size;\n'
        yield f'    if (buffer_size < total_size) {{\n'
        yield f'        return 0;\n'
        yield f'    }}\n\n'
        
        # Write header
        idx = 0
        for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
            yield f'    buffer[{idx}] = {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""};\n'
            idx += 1
        yield f'    buffer[{idx}] = msg_id;\n'
        idx += 1
        
        if fmt.has_length:
            if fmt.length_bytes == 1:
                yield f'    buffer[{idx}] = (uint8_t)msg_size;\n'
            else:
                yield f'    buffer[{idx}] = (uint8_t)(msg_size & 0xFF);\n'
                yield f'    buffer[{idx + 1}] = (uint8_t)((msg_size >> 8) & 0xFF);\n'
            idx += fmt.length_bytes
        
        yield f'\n    /* Write message data */\n'
        yield f'    if (msg_size > 0 && msg != NULL) {{\n'
        yield f'        memcpy(buffer + {PREFIX}_HEADER_SIZE, msg, msg_size);\n'
        yield f'    }}\n\n'
        
        if fmt.has_crc:
            yield f'    /* Calculate checksum */\n'
            yield f'    frame_checksum_t ck = frame_fletcher_checksum(buffer + {len(fmt.start_bytes)}, msg_size + 1'
            if fmt.has_length:
                yield f' + {fmt.length_bytes}'
            yield f');\n'
            yield f'    buffer[{PREFIX}_HEADER_SIZE + msg_size] = ck.byte1;\n'
            yield f'    buffer[{PREFIX}_HEADER_SIZE + msg_size + 1] = ck.byte2;\n'
        
        yield f'\n    return total_size;\n'
        yield f'}}\n\n'
        
        # Generate validate_packet function
        yield f'/**\n'
        yield f' * Validate a complete {name} packet in a buffer\n'
        yield f' */\n'
        yield f'static inline frame_msg_info_t {prefix}_validate_packet(const uint8_t* buffer, size_t length) {{\n'
        yield f'    frame_msg_info_t result = {{false, 0, 0, NULL}};\n\n'
        yield f'    if (length < {PREFIX}_OVERHEAD) {{\n'
        yield f'        return result;\n'
        yield f'    }}\n\n'
        
        # Check start bytes
        if fmt.start_bytes:
            for i, (sb_name, sb_value) in enumerate(fmt.start_bytes):
                yield f'    if (buffer[{i}] != {PREFIX}_START_BYTE{i + 1 if len(fmt.start_bytes) > 1 else ""}) {{\n'
                yield f'        return result;\n'
                yield f'    }}\n'
        
        yield f'\n    size_t msg_length = length - {PREFIX}_OVERHEAD;\n\n'
        
        if fmt.has_crc:
            yield f'    /* Validate checksum */\n'
            yield f'    frame_checksum_t ck = frame_fletcher_checksum(buffer + {len(fmt.start_bytes)}, msg_length + 1'
            if fmt.has_length:
                yield f' + {fmt.length_bytes}'
            yield f');\n'
            yield f'    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {{\n'
            yield f'        result.valid = true;\n'
            yield f'        result.msg_id = buffer[{len(fmt.start_bytes)}];\n'
            yield f'        result.msg_len = msg_length;\n'
            yield f'        result.msg_data = (uint8_t*)(buffer + {PREFIX}_HEADER_SIZE);\n'
            yield f'    }}\n'
        else:
            yield f'    result.valid = true;\n'
            yield f'    result.msg_id = buffer[{len(fmt.start_bytes)}];\n'
            yield f'    result.msg_len = msg_length;\n'
            yield f'    result.msg_data = (uint8_t*)(buffer + {PREFIX}_HEADER_SIZE);\n'
        
        yield f'\n    return result;\n'
        yield f'}}\n\n'


def generate_c_frame_parsers(formats):
    """Generate C frame parser code from frame format definitions"""
    return ''.join(FrameParserCGen.generate_header(formats))
