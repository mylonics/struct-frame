#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;
"""
C# SDK Interface Generator for struct-frame.

This module generates a high-level SDK interface class that provides
type-safe send and subscribe methods for each message type. The generated
interface wraps a StructFrameSdk instance and provides convenience methods
for each message in the package.
"""

from struct_frame import version, pascalCase
import time


def get_csharp_field_type(field, package_name):
    """Get the C# type for a field"""
    from struct_frame.csharp_gen import csharp_types
    
    type_name = field.fieldType
    
    # Handle basic type resolution
    if type_name in csharp_types:
        base_type = csharp_types[type_name]
    else:
        # Use the package where the type is defined
        type_pkg = getattr(field, 'type_package', None) if hasattr(field, 'type_package') else None
        type_pkg = type_pkg if type_pkg else getattr(field, 'package', package_name)
        if field.isEnum:
            base_type = f'{pascalCase(type_pkg)}{type_name}'
        else:
            base_type = f'{pascalCase(type_pkg)}{type_name}'
    
    # Handle arrays
    if field.is_array:
        if field.fieldType == "string":
            # String arrays are byte[] in C#
            return "byte[]"
        else:
            if field.isEnum:
                return "byte[]"
            else:
                return f"{base_type}[]"
    
    # Handle regular strings
    elif field.fieldType == "string":
        return "byte[]"
    
    # Handle regular fields
    else:
        return base_type


class SdkInterfaceGen:
    """Generates C# SDK interface class for message sending and subscribing"""
    
    @staticmethod
    def generate(package):
        """Generate the SDK interface class for a package"""
        yield '// Automatically generated SDK Interface for C#\n'
        yield f'// Generated by {version} at {time.asctime()}.\n\n'
        
        yield 'using System;\n'
        yield 'using System.Threading.Tasks;\n'
        yield 'using StructFrame;\n'
        yield 'using StructFrame.Sdk;\n'
        
        # Collect referenced packages for using directives
        referenced_packages = set()
        for key, msg in package.messages.items():
            for field_name, field in msg.fields.items():
                if field.type_package and field.type_package != package.name:
                    referenced_packages.add(field.type_package)
        
        # Add using directives for referenced packages
        if referenced_packages:
            for ref_pkg in sorted(referenced_packages):
                yield f'using StructFrame.{pascalCase(ref_pkg)};\n'
        
        yield f'using StructFrame.{pascalCase(package.name)};\n'
        yield '\n'
        
        namespace_name = pascalCase(package.name)
        yield f'namespace StructFrame.{namespace_name}.Sdk\n'
        yield '{\n'
        
        # Generate the SDK interface class
        yield '    /// <summary>\n'
        yield f'    /// High-level SDK interface for {package.name} messages\n'
        yield '    /// Provides type-safe send and subscribe methods for each message type\n'
        yield '    /// </summary>\n'
        yield f'    public class {namespace_name}SdkInterface\n'
        yield '    {\n'
        yield '        private readonly StructFrameSdk _sdk;\n'
        yield '\n'
        
        # Constructor
        yield '        /// <summary>\n'
        yield f'        /// Initialize the {namespace_name} SDK Interface\n'
        yield '        /// </summary>\n'
        yield '        /// <param name="sdk">The StructFrameSdk instance to use for communication</param>\n'
        yield f'        public {namespace_name}SdkInterface(StructFrameSdk sdk)\n'
        yield '        {\n'
        yield '            _sdk = sdk ?? throw new ArgumentNullException(nameof(sdk));\n'
        yield '        }\n'
        yield '\n'
        
        # Expose underlying SDK for advanced usage
        yield '        /// <summary>\n'
        yield '        /// The underlying StructFrameSdk instance\n'
        yield '        /// </summary>\n'
        yield '        public StructFrameSdk Sdk => _sdk;\n'
        yield '\n'
        
        # Find envelope messages for later use
        envelope_msgs = {key: msg for key, msg in package.messages.items() if msg.is_envelope}
        
        # Generate send and subscribe methods for each message with msgid
        for key, msg in package.sortedMessages().items():
            if msg.id:  # Only generate for messages with a message ID
                yield from SdkInterfaceGen._generate_send_methods(msg, package.name)
                yield from SdkInterfaceGen._generate_subscribe_method(msg, package.name)
        
        # Generate envelope helper methods and send-via-envelope methods
        for key, envelope_msg in envelope_msgs.items():
            yield from SdkInterfaceGen._generate_envelope_helper(envelope_msg, package.name)
            yield from SdkInterfaceGen._generate_envelope_send_methods(envelope_msg, package)
        
        yield '    }\n'
        yield '}\n'
    
    @staticmethod
    def _generate_subscribe_method(msg, package_name):
        """Generate subscribe method for a single message"""
        struct_name = f'{pascalCase(package_name)}{msg.name}'
        method_name = f'Subscribe{msg.name}'
        
        yield '        /// <summary>\n'
        yield f'        /// Subscribe to {msg.name} messages\n'
        yield '        /// </summary>\n'
        yield f'        /// <param name="handler">Handler to call when {msg.name} message is received</param>\n'
        yield '        /// <returns>Action to unsubscribe</returns>\n'
        yield f'        public Action {method_name}(MessageHandler<{struct_name}> handler)\n'
        yield '        {\n'
        yield f'            return _sdk.Subscribe<{struct_name}>(handler);\n'
        yield '        }\n'
        yield '\n'
    
    @staticmethod
    def _generate_send_methods(msg, package_name):
        """Generate send methods for a single message"""
        struct_name = f'{pascalCase(package_name)}{msg.name}'
        method_name = f'Send{msg.name}'
        
        # Method 1: Send with struct reference
        yield '        /// <summary>\n'
        yield f'        /// Send {msg.name} message\n'
        yield '        /// </summary>\n'
        yield f'        /// <param name="message">The {msg.name} message to send</param>\n'
        yield f'        /// <param name="seq">Sequence number (optional)</param>\n'
        yield f'        /// <param name="sysId">System ID (optional)</param>\n'
        yield f'        /// <param name="compId">Component ID (optional)</param>\n'
        yield f'        public async Task {method_name}({struct_name} message, byte seq = 0, byte sysId = 0, byte compId = 0)\n'
        yield '        {\n'
        yield '            await _sdk.SendAsync(message, seq, sysId, compId);\n'
        yield '        }\n'
        yield '\n'
        
        # Method 2: Send with individual fields (only if message has fields)
        if msg.fields:
            yield '        /// <summary>\n'
            yield f'        /// Send {msg.name} message with individual field values\n'
            yield '        /// </summary>\n'
            
            # Generate parameters
            params = []
            for field_name, field in msg.fields.items():
                csharp_type = get_csharp_field_type(field, package_name)
                param_name = pascalCase(field.name).lower()
                
                # Add parameter with comment
                yield f'        /// <param name="{param_name}">{field.name}</param>\n'
                params.append(f'{csharp_type} {param_name}')
            
            param_str = ', '.join(params)
            yield f'        public async Task {method_name}({param_str})\n'
            yield '        {\n'
            yield f'            var message = new {struct_name}();\n'
            
            # Assign each field
            for field_name, field in msg.fields.items():
                param_name = pascalCase(field.name).lower()
                struct_field_name = pascalCase(field.name)
                
                # Handle different field types
                if field.is_array:
                    if field.fieldType == "string":
                        # String arrays
                        if field.size_option is not None:
                            # Fixed string array
                            yield f'            message.{struct_field_name} = {param_name};\n'
                        elif field.max_size is not None:
                            # Variable string array - use integer division
                            yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length / {field.element_size}, {field.max_size});\n'
                            yield f'            message.{struct_field_name}Data = {param_name};\n'
                    else:
                        # Non-string arrays
                        if field.size_option is not None:
                            # Fixed array
                            yield f'            message.{struct_field_name} = {param_name};\n'
                        elif field.max_size is not None:
                            # Variable array
                            yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length, {field.max_size});\n'
                            yield f'            message.{struct_field_name}Data = {param_name};\n'
                elif field.fieldType == "string":
                    # Regular strings
                    if field.size_option is not None:
                        # Fixed string
                        yield f'            message.{struct_field_name} = {param_name};\n'
                    elif field.max_size is not None:
                        # Variable string
                        yield f'            message.{struct_field_name}Length = (byte)Math.Min({param_name}.Length, {field.max_size});\n'
                        yield f'            message.{struct_field_name}Data = {param_name};\n'
                else:
                    # Regular fields
                    yield f'            message.{struct_field_name} = {param_name};\n'
            
            yield f'            await {method_name}(message);\n'
            yield '        }\n'
            yield '\n'

    @staticmethod
    def _generate_envelope_helper(envelope_msg, package_name):
        """Generate the private helper method for sending messages via an envelope"""
        from struct_frame.csharp_gen import EnumCSharpGen, csharp_types
        
        envelope_type = f'{pascalCase(package_name)}{envelope_msg.name}'
        
        # Get the single oneof (envelope validation ensures exactly one exists)
        oneof_name = list(envelope_msg.oneofs.keys())[0]
        oneof = envelope_msg.oneofs[oneof_name]
        
        # Get enum name for field_order discriminators
        enum_name = None
        if oneof.auto_discriminator and oneof.discriminator_type == "field_order":
            enum_name = EnumCSharpGen.get_discriminator_enum_name(oneof, envelope_msg.name)
        
        # Collect envelope fields (non-oneof, non-complex fields)
        envelope_fields = []
        for f_name, f in envelope_msg.fields.items():
            if f.is_array or f.fieldType == "string":
                continue
            csharp_type = csharp_types.get(f.fieldType)
            if csharp_type is None:
                type_pkg = f.type_package if f.type_package else f.package
                csharp_type = f'{pascalCase(type_pkg)}{f.fieldType}'
            envelope_fields.append((f_name, f, csharp_type))
        
        # Helper 1: Basic helper with default envelope field values
        yield '        /// <summary>\n'
        yield f'        /// Helper to wrap a message in a {envelope_msg.name} envelope and send it\n'
        yield '        /// </summary>\n'
        
        # Generate helper with appropriate discriminator parameter type
        if oneof.auto_discriminator and oneof.discriminator_type == "field_order":
            yield f'        private async Task SendAs{envelope_msg.name}<T>(T message, Action<{envelope_type}, T> setField, {enum_name} discriminator, byte seq = 0, byte sysId = 0, byte compId = 0) where T : class, IStructFrameMessage\n'
        else:
            yield f'        private async Task SendAs{envelope_msg.name}<T>(T message, Action<{envelope_type}, T> setField, byte seq = 0, byte sysId = 0, byte compId = 0) where T : class, IStructFrameMessage\n'
        
        yield '        {\n'
        yield f'            var envelope = new {envelope_type}();\n'
        
        # Initialize envelope fields with defaults
        for f_name, f, csharp_type in envelope_fields:
            # Set reasonable defaults for common envelope field patterns
            field_name = pascalCase(f_name)
            if 'immediate' in f_name.lower() or 'run' in f_name.lower():
                yield f'            envelope.{field_name} = true;\n'
        
        # Set the discriminator based on discriminator type
        if oneof.auto_discriminator:
            if oneof.discriminator_type == "msgid":
                yield f'            envelope.{pascalCase(oneof_name)}Discriminator = message.GetMsgId();\n'
            else:  # field_order
                yield f'            envelope.{pascalCase(oneof_name)}Discriminator = discriminator;\n'
        
        yield '            setField(envelope, message);\n'
        yield '            await _sdk.SendAsync(envelope, seq, sysId, compId);\n'
        yield '        }\n'
        yield '\n'
        
        # Helper 2: Overload with envelope field configuration callback
        if envelope_fields:
            yield '        /// <summary>\n'
            yield f'        /// Helper to wrap a message in a {envelope_msg.name} envelope with custom field values and send it\n'
            yield '        /// </summary>\n'
            
            if oneof.auto_discriminator and oneof.discriminator_type == "field_order":
                yield f'        private async Task SendAs{envelope_msg.name}<T>(T message, Action<{envelope_type}, T> setField, {enum_name} discriminator, Action<{envelope_type}> configureEnvelope, byte seq = 0, byte sysId = 0, byte compId = 0) where T : class, IStructFrameMessage\n'
            else:
                yield f'        private async Task SendAs{envelope_msg.name}<T>(T message, Action<{envelope_type}, T> setField, Action<{envelope_type}> configureEnvelope, byte seq = 0, byte sysId = 0, byte compId = 0) where T : class, IStructFrameMessage\n'
            
            yield '        {\n'
            yield f'            var envelope = new {envelope_type}();\n'
            yield '            configureEnvelope(envelope);\n'
            
            # Set the discriminator based on discriminator type
            if oneof.auto_discriminator:
                if oneof.discriminator_type == "msgid":
                    yield f'            envelope.{pascalCase(oneof_name)}Discriminator = message.GetMsgId();\n'
                else:  # field_order
                    yield f'            envelope.{pascalCase(oneof_name)}Discriminator = discriminator;\n'
            
            yield '            setField(envelope, message);\n'
            yield '            await _sdk.SendAsync(envelope, seq, sysId, compId);\n'
            yield '        }\n'
            yield '\n'
    
    @staticmethod
    def _generate_envelope_send_methods(envelope_msg, package):
        """Generate send methods for each message type that can be wrapped in the envelope"""
        from struct_frame.csharp_gen import EnumCSharpGen, csharp_types
        
        package_name = package.name
        envelope_type = f'{pascalCase(package_name)}{envelope_msg.name}'
        
        # Get the single oneof
        oneof_name = list(envelope_msg.oneofs.keys())[0]
        oneof = envelope_msg.oneofs[oneof_name]
        
        # Get enum name for field_order discriminators
        enum_name = None
        if oneof.auto_discriminator and oneof.discriminator_type == "field_order":
            enum_name = EnumCSharpGen.get_discriminator_enum_name(oneof, envelope_msg.name)
        
        # Collect envelope fields (non-oneof, non-complex fields) for the overload
        envelope_fields = []
        for f_name, f in envelope_msg.fields.items():
            if f.is_array or f.fieldType == "string":
                continue
            csharp_type = csharp_types.get(f.fieldType)
            if csharp_type is None:
                type_pkg = f.type_package if f.type_package else f.package
                csharp_type = f'{pascalCase(type_pkg)}{f.fieldType}'
            envelope_fields.append((f_name, f, csharp_type))
        
        # Generate a send method for each payload type in the oneof
        for idx, (field_name, field) in enumerate(oneof.fields.items()):
            # Get the payload type name
            type_pkg = field.type_package if field.type_package else field.package
            payload_type = f'{pascalCase(type_pkg)}{field.fieldType}'
            
            # Method name like Send{PayloadType}Via{EnvelopeName}
            method_name = f'Send{field.fieldType}Via{envelope_msg.name}'
            
            # Try to find the payload message definition to get its fields
            payload_msg = None
            payload_fields = []
            # Look in the same package first
            if field.fieldType in package.messages:
                payload_msg = package.messages[field.fieldType]
            
            if payload_msg and payload_msg.fields:
                for pf_name, pf in payload_msg.fields.items():
                    pf_csharp_type = get_csharp_field_type(pf, type_pkg)
                    payload_fields.append((pf_name, pf, pf_csharp_type))
            
            # Method 1: Overload with message object and envelope fields as parameters
            if envelope_fields:
                yield '        /// <summary>\n'
                yield f'        /// Send {field.fieldType} message wrapped in a {envelope_msg.name} envelope with custom envelope field values\n'
                yield '        /// </summary>\n'
                yield f'        /// <param name="message">The {field.fieldType} message to send</param>\n'
                for f_name, f, csharp_type in envelope_fields:
                    yield f'        /// <param name="{f_name}">{envelope_msg.name} envelope field: {f_name}</param>\n'
                yield '        /// <param name="seq">Sequence number (optional)</param>\n'
                yield '        /// <param name="sysId">System ID (optional)</param>\n'
                yield '        /// <param name="compId">Component ID (optional)</param>\n'
                
                # Build parameter list
                env_params = ', '.join([f'{csharp_type} {f_name}' for f_name, f, csharp_type in envelope_fields])
                yield f'        public async Task {method_name}({payload_type} message, {env_params}, byte seq = 0, byte sysId = 0, byte compId = 0)\n'
                yield '        {\n'
                
                # Build the configure action
                field_assignments = '; '.join([f'env.{pascalCase(f_name)} = {f_name}' for f_name, f, csharp_type in envelope_fields])
                
                if oneof.auto_discriminator and oneof.discriminator_type == "field_order":
                    enum_entry = pascalCase(field_name)
                    yield f'            await SendAs{envelope_msg.name}(message, (env, msg) => env.{pascalCase(field_name)} = msg, {enum_name}.{enum_entry}, env => {{ {field_assignments}; }}, seq, sysId, compId);\n'
                else:
                    yield f'            await SendAs{envelope_msg.name}(message, (env, msg) => env.{pascalCase(field_name)} = msg, env => {{ {field_assignments}; }}, seq, sysId, compId);\n'
                
                yield '        }\n'
                yield '\n'
            
            # Method 2: Overload with individual payload fields AND envelope fields as parameters
            if payload_fields and envelope_fields:
                yield '        /// <summary>\n'
                yield f'        /// Send {field.fieldType} message wrapped in a {envelope_msg.name} envelope with individual field values\n'
                yield '        /// </summary>\n'
                
                # Document payload fields
                for pf_name, pf, pf_csharp_type in payload_fields:
                    param_name = pascalCase(pf_name).lower()
                    yield f'        /// <param name="{param_name}">{field.fieldType} field: {pf_name}</param>\n'
                
                # Document envelope fields
                for f_name, f, csharp_type in envelope_fields:
                    yield f'        /// <param name="{f_name}">{envelope_msg.name} envelope field: {f_name}</param>\n'
                
                yield '        /// <param name="seq">Sequence number (optional)</param>\n'
                yield '        /// <param name="sysId">System ID (optional)</param>\n'
                yield '        /// <param name="compId">Component ID (optional)</param>\n'
                
                # Build parameter list: payload fields first, then envelope fields
                payload_params = ', '.join([f'{pf_csharp_type} {pascalCase(pf_name).lower()}' for pf_name, pf, pf_csharp_type in payload_fields])
                env_params = ', '.join([f'{csharp_type} {f_name}' for f_name, f, csharp_type in envelope_fields])
                yield f'        public async Task {method_name}({payload_params}, {env_params}, byte seq = 0, byte sysId = 0, byte compId = 0)\n'
                yield '        {\n'
                yield f'            var message = new {payload_type}();\n'
                
                # Assign each payload field
                for pf_name, pf, pf_csharp_type in payload_fields:
                    param_name = pascalCase(pf_name).lower()
                    struct_field_name = pascalCase(pf_name)
                    
                    # Handle different field types
                    if pf.is_array:
                        if pf.fieldType == "string":
                            if pf.size_option is not None:
                                yield f'            message.{struct_field_name} = {param_name};\n'
                            elif pf.max_size is not None:
                                yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length / {pf.element_size}, {pf.max_size});\n'
                                yield f'            message.{struct_field_name}Data = {param_name};\n'
                        else:
                            if pf.size_option is not None:
                                yield f'            message.{struct_field_name} = {param_name};\n'
                            elif pf.max_size is not None:
                                yield f'            message.{struct_field_name}Count = (byte)Math.Min({param_name}.Length, {pf.max_size});\n'
                                yield f'            message.{struct_field_name}Data = {param_name};\n'
                    elif pf.fieldType == "string":
                        if pf.size_option is not None:
                            yield f'            message.{struct_field_name} = {param_name};\n'
                        elif pf.max_size is not None:
                            yield f'            message.{struct_field_name}Length = (byte)Math.Min({param_name}.Length, {pf.max_size});\n'
                            yield f'            message.{struct_field_name}Data = {param_name};\n'
                    else:
                        yield f'            message.{struct_field_name} = {param_name};\n'
                
                # Call the message overload
                env_args = ', '.join([f_name for f_name, f, csharp_type in envelope_fields])
                yield f'            await {method_name}(message, {env_args}, seq, sysId, compId);\n'
                yield '        }\n'
                yield '\n'


def generate_csharp_sdk_interface(package):
    """Generate C# SDK interface code from a package"""
    return ''.join(SdkInterfaceGen.generate(package))
