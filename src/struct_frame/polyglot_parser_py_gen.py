#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
Python Polyglot Parser Generator

Generates Python code for polyglot parsers that can handle multiple frame types
in the same stream. The parser cascades from Basic → Tiny → None/Payload types.
"""

from struct_frame import version
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class PolyglotParserPyGen:
    """Generates Python code for polyglot parsers"""

    @staticmethod
    def generate_polyglot_parser(formats):
        """Generate a polyglot parser that can handle multiple frame formats"""
        yield '# Automatically generated polyglot frame parser\n'
        yield f'# Generated by {version} at {time.asctime()}.\n\n'
        yield 'from enum import Enum\n'
        yield 'from typing import Union, Optional, Callable\n'
        yield 'from dataclasses import dataclass\n'
        yield 'try:\n'
        yield '    from .frame_base import (\n'
        yield '        FrameFormatType,\n'
        yield '        FrameMsgInfo,\n'
        yield '        FrameParserConfig,\n'
        yield '        GenericParserState,\n'
        yield '    )\n'
        yield 'except ImportError:\n'
        yield '    from frame_base import (\n'
        yield '        FrameFormatType,\n'
        yield '        FrameMsgInfo,\n'
        yield '        FrameParserConfig,\n'
        yield '        GenericParserState,\n'
        yield '    )\n\n'

        # Import all frame format configs with try/except for relative imports
        for fmt in formats:
            snake_name = camel_to_snake(fmt.name)
            yield 'try:\n'
            yield f'    from .{snake_name} import {fmt.name}, {fmt.name}Config\n'
            yield 'except ImportError:\n'
            yield f'    from {snake_name} import {fmt.name}, {fmt.name}Config\n'
        
        yield '\n\n'
        
        # Generate payload type to format mapping
        yield '# =============================================================================\n'
        yield '# Polyglot Parser - Parse Multiple Frame Types in Same Stream\n'
        yield '# =============================================================================\n\n'
        
        # Create start byte mapping
        yield '# Map start bytes to frame formats\n'
        yield 'BASIC_START_BYTE1 = 0x90\n'
        yield 'TINY_START_BYTE_BASE = 0x70  # Tiny frames: 0x70 + payload_type\n\n'
        
        # Group formats by frame type
        basic_formats = [f for f in formats if f.name.startswith('Basic')]
        tiny_formats = [f for f in formats if f.name.startswith('Tiny')]
        none_formats = [f for f in formats if f.name.startswith('None')]
        
        # Create payload type mappings
        yield '# Payload type to format mapping\n'
        yield 'PAYLOAD_TYPE_TO_TINY_FORMAT = {\n'
        for fmt in tiny_formats:
            if fmt.start_bytes:
                start_byte = fmt.start_bytes[0][1]
                payload_type = start_byte - 0x70
                yield f'    {payload_type}: {fmt.name},  # 0x{start_byte:02X}\n'
        yield '}\n\n'
        
        yield 'PAYLOAD_TYPE_TO_BASIC_FORMAT = {\n'
        for fmt in basic_formats:
            if len(fmt.start_bytes) >= 2:
                start_byte2 = fmt.start_bytes[1][1]
                payload_type = start_byte2 - 0x70
                yield f'    {payload_type}: {fmt.name},  # 0x90 0x{start_byte2:02X}\n'
        yield '}\n\n'
        
        yield 'PAYLOAD_TYPE_TO_NONE_FORMAT = {\n'
        for i, fmt in enumerate(none_formats):
            yield f'    {i}: {fmt.name},\n'
        yield '}\n\n'
        
        # Generate polyglot parser result class
        yield '@dataclass\n'
        yield 'class PolyglotParserResult:\n'
        yield '    """Result from polyglot parser with frame type information"""\n'
        yield '    valid: bool = False\n'
        yield '    frame_type: Optional[str] = None  # "basic", "tiny", "none"\n'
        yield '    payload_type: Optional[int] = None\n'
        yield '    format_name: Optional[str] = None\n'
        yield '    msg_id: int = 0\n'
        yield '    msg_len: int = 0\n'
        yield '    msg_data: bytes = b\'\'\n\n'
        yield '    @classmethod\n'
        yield '    def from_frame_msg_info(cls, info: FrameMsgInfo, frame_type: str,\n'
        yield '                           payload_type: int, format_name: str):\n'
        yield '        """Create from FrameMsgInfo"""\n'
        yield '        return cls(\n'
        yield '            valid=info.valid,\n'
        yield '            frame_type=frame_type,\n'
        yield '            payload_type=payload_type,\n'
        yield '            format_name=format_name,\n'
        yield '            msg_id=info.msg_id,\n'
        yield '            msg_len=info.msg_len,\n'
        yield '            msg_data=info.msg_data\n'
        yield '        )\n\n\n'
        
        # Generate polyglot parser state
        yield 'class PolyglotParserState(Enum):\n'
        yield '    """Parser state for polyglot parser"""\n'
        yield '    LOOKING_FOR_START = 0\n'
        yield '    DETECTED_BASIC = 1\n'
        yield '    DETECTED_TINY = 2\n'
        yield '    PARSING_NONE = 3\n\n\n'
        
        # Generate the polyglot parser class
        yield 'class PolyglotParser:\n'
        yield '    """\n'
        yield '    Polyglot frame parser that can detect and parse multiple frame types.\n'
        yield '    \n'
        yield '    The parser cascades through frame types:\n'
        yield '    1. Check for Basic frame (0x90 start byte)\n'
        yield '    2. Check for Tiny frame (0x70-0x78 start byte)\n'
        yield '    3. Fall back to None frame (direct payload)\n'
        yield '    \n'
        yield '    The second start byte (Basic) or single start byte (Tiny) encodes the\n'
        yield '    payload type (0x70 + payload_type_offset).\n'
        yield '    """\n\n'
        
        # Constructor
        yield '    def __init__(self, get_msg_length: Callable[[int], int] = None,\n'
        yield '                 enable_basic: bool = True,\n'
        yield '                 enable_tiny: bool = True,\n'
        yield '                 enable_none: bool = True,\n'
        yield '                 default_none_format: Optional[str] = None):\n'
        yield '        """\n'
        yield '        Initialize polyglot parser.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            get_msg_length: Callback to get message length from msg_id\n'
        yield '            enable_basic: Enable Basic frame parsing (default: True)\n'
        yield '            enable_tiny: Enable Tiny frame parsing (default: True)\n'
        yield '            enable_none: Enable None frame parsing (default: True)\n'
        yield '            default_none_format: Default format for None frames\n'
        yield '        """\n'
        yield '        self.get_msg_length = get_msg_length\n'
        yield '        self.enable_basic = enable_basic\n'
        yield '        self.enable_tiny = enable_tiny\n'
        yield '        self.enable_none = enable_none\n'
        yield '        self.default_none_format = default_none_format\n'
        yield '        \n'
        yield '        # Active parsers (created on-demand)\n'
        yield '        self.active_parser = None\n'
        yield '        self.active_parser_type = None  # "basic", "tiny", "none"\n'
        yield '        self.active_payload_type = None\n'
        yield '        \n'
        yield '        self.reset()\n\n'
        
        # Reset method
        yield '    def reset(self):\n'
        yield '        """Reset parser state"""\n'
        yield '        self.state = PolyglotParserState.LOOKING_FOR_START\n'
        yield '        self.active_parser = None\n'
        yield '        self.active_parser_type = None\n'
        yield '        self.active_payload_type = None\n'
        yield '        self.buffer = []\n\n'
        
        # Parse byte method
        yield '    def parse_byte(self, byte: int) -> PolyglotParserResult:\n'
        yield '        """\n'
        yield '        Parse a single byte and detect frame type.\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            PolyglotParserResult with valid=True when a complete message is received\n'
        yield '        """\n'
        yield '        result = PolyglotParserResult()\n'
        yield '        \n'
        yield '        if self.state == PolyglotParserState.LOOKING_FOR_START:\n'
        yield '            # Check for Basic frame (0x90)\n'
        yield '            if self.enable_basic and byte == BASIC_START_BYTE1:\n'
        yield '                self.state = PolyglotParserState.DETECTED_BASIC\n'
        yield '                self.buffer = [byte]\n'
        yield '            # Check for Tiny frame (0x70-0x78)\n'
        yield '            elif self.enable_tiny and 0x70 <= byte <= 0x78:\n'
        yield '                payload_type = byte - TINY_START_BYTE_BASE\n'
        yield '                if payload_type in PAYLOAD_TYPE_TO_TINY_FORMAT:\n'
        yield '                    parser_class = PAYLOAD_TYPE_TO_TINY_FORMAT[payload_type]\n'
        yield '                    self.active_parser = parser_class(self.get_msg_length)\n'
        yield '                    self.active_parser_type = "tiny"\n'
        yield '                    self.active_payload_type = payload_type\n'
        yield '                    self.state = PolyglotParserState.DETECTED_TINY\n'
        yield '                    # Feed the start byte to the parser\n'
        yield '                    frame_info = self.active_parser.parse_byte(byte)\n'
        yield '                    if frame_info.valid:\n'
        yield '                        format_name = parser_class.__name__\n'
        yield '                        result = PolyglotParserResult.from_frame_msg_info(\n'
        yield '                            frame_info, "tiny", payload_type, format_name)\n'
        yield '                        self.reset()\n'
        yield '            # Fall back to None frame\n'
        yield '            elif self.enable_none:\n'
        yield '                # For None frames, we need to determine the format\n'
        yield '                # This is tricky without external sync - we would need\n'
        yield '                # the message ID to determine format\n'
        yield '                self.state = PolyglotParserState.PARSING_NONE\n'
        yield '                if self.default_none_format:\n'
        yield '                    parser_class = globals().get(self.default_none_format)\n'
        yield '                    if parser_class:\n'
        yield '                        self.active_parser = parser_class(self.get_msg_length)\n'
        yield '                        self.active_parser_type = "none"\n'
        yield '                        self.active_payload_type = 0\n'
        yield '                        frame_info = self.active_parser.parse_byte(byte)\n'
        yield '                        if frame_info.valid:\n'
        yield '                            format_name = parser_class.__name__\n'
        yield '                            result = PolyglotParserResult.from_frame_msg_info(\n'
        yield '                                frame_info, "none", 0, format_name)\n'
        yield '                            self.reset()\n'
        yield '        \n'
        yield '        elif self.state == PolyglotParserState.DETECTED_BASIC:\n'
        yield '            # Got 0x90, now check for second start byte (0x70-0x78)\n'
        yield '            # Or continue parsing if we already have an active parser\n'
        yield '            if self.active_parser:\n'
        yield '                # Already detected frame type, continue parsing\n'
        yield '                frame_info = self.active_parser.parse_byte(byte)\n'
        yield '                if frame_info.valid:\n'
        yield '                    format_name = self.active_parser.__class__.__name__\n'
        yield '                    result = PolyglotParserResult.from_frame_msg_info(\n'
        yield '                        frame_info, self.active_parser_type,\n'
        yield '                        self.active_payload_type or 0, format_name)\n'
        yield '                    self.reset()\n'
        yield '            elif 0x70 <= byte <= 0x78:\n'
        yield '                payload_type = byte - TINY_START_BYTE_BASE\n'
        yield '                if payload_type in PAYLOAD_TYPE_TO_BASIC_FORMAT:\n'
        yield '                    parser_class = PAYLOAD_TYPE_TO_BASIC_FORMAT[payload_type]\n'
        yield '                    self.active_parser = parser_class(self.get_msg_length)\n'
        yield '                    self.active_parser_type = "basic"\n'
        yield '                    self.active_payload_type = payload_type\n'
        yield '                    # Feed both start bytes to the parser\n'
        yield '                    self.active_parser.parse_byte(0x90)\n'
        yield '                    frame_info = self.active_parser.parse_byte(byte)\n'
        yield '                    # Check if message is already complete (unlikely but possible)\n'
        yield '                    if frame_info.valid:\n'
        yield '                        format_name = parser_class.__name__\n'
        yield '                        result = PolyglotParserResult.from_frame_msg_info(\n'
        yield '                            frame_info, "basic", payload_type, format_name)\n'
        yield '                        self.reset()\n'
        yield '                else:\n'
        yield '                    # Invalid payload type, reset\n'
        yield '                    self.reset()\n'
        yield '            else:\n'
        yield '                # Not a valid Basic frame second byte, reset\n'
        yield '                self.reset()\n'
        yield '        \n'
        yield '        # Continue parsing with active parser for Tiny, Basic (after start bytes), or None frames\n'
        yield '        elif self.active_parser and not result.valid:\n'
        yield '            # This handles:\n'
        yield '            # - DETECTED_TINY: Continue parsing Tiny frame after start byte\n'
        yield '            # - DETECTED_BASIC: Continue parsing Basic frame after both start bytes\n'
        yield '            # - PARSING_NONE: Continue parsing None frame\n'
        yield '            frame_info = self.active_parser.parse_byte(byte)\n'
        yield '            if frame_info.valid:\n'
        yield '                format_name = self.active_parser.__class__.__name__\n'
        yield '                result = PolyglotParserResult.from_frame_msg_info(\n'
        yield '                    frame_info, self.active_parser_type,\n'
        yield '                    self.active_payload_type or 0, format_name)\n'
        yield '                self.reset()\n'
        yield '        \n'
        yield '        return result\n\n'
        
        # Encode method (delegates to specific format)
        yield '    def encode(self, msg_id: int, msg: bytes, frame_type: str = "basic",\n'
        yield '               payload_type: int = 1) -> bytes:\n'
        yield '        """\n'
        yield '        Encode a message with specified frame type and payload type.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            msg_id: Message ID\n'
        yield '            msg: Message data\n'
        yield '            frame_type: "basic", "tiny", or "none"\n'
        yield '            payload_type: Payload type index (0-8)\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            Encoded frame bytes\n'
        yield '        """\n'
        yield '        # Select format based on frame type and payload type\n'
        yield '        if frame_type == "basic":\n'
        yield '            format_map = PAYLOAD_TYPE_TO_BASIC_FORMAT\n'
        yield '        elif frame_type == "tiny":\n'
        yield '            format_map = PAYLOAD_TYPE_TO_TINY_FORMAT\n'
        yield '        elif frame_type == "none":\n'
        yield '            format_map = PAYLOAD_TYPE_TO_NONE_FORMAT\n'
        yield '        else:\n'
        yield '            raise ValueError(f"Unknown frame type: {frame_type}")\n'
        yield '        \n'
        yield '        parser_class = format_map.get(payload_type)\n'
        yield '        if not parser_class:\n'
        yield '            raise ValueError(f"Unknown payload type {payload_type} for {frame_type}")\n'
        yield '        \n'
        yield '        # Create temporary parser instance and encode\n'
        yield '        parser = parser_class()\n'
        yield '        return parser.encode(msg_id, msg)\n\n'


def generate_py_polyglot_parser(formats):
    """Generate Python polyglot parser code"""
    return ''.join(PolyglotParserPyGen.generate_polyglot_parser(formats))
