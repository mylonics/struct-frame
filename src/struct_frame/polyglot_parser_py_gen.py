#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
Python Polyglot Parser Generator

Generates Python code for polyglot parsers that can handle multiple frame types
in the same stream using the header + payload architecture.

Headers: Basic, Tiny, None (and third-party: UBX, MavlinkV1, MavlinkV2)
Payloads: Minimal, Default, Extended, etc.

The parser dynamically combines headers with payloads at runtime.
"""

from struct_frame import version
from struct_frame.frame_format import HeaderType, PayloadType
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class PolyglotParserPyGen:
    """Generates Python code for polyglot parsers using header + payload architecture"""

    @staticmethod
    def generate_polyglot_parser(collection):
        """Generate a polyglot parser from header and payload definitions"""
        yield '# Automatically generated polyglot frame parser\n'
        yield f'# Generated by {version} at {time.asctime()}.\n'
        yield '# Uses header + payload architecture for composable frame formats.\n\n'
        
        yield 'from enum import Enum\n'
        yield 'from typing import Union, Optional, Callable, List, Tuple\n'
        yield 'from dataclasses import dataclass\n\n'
        
        # Generate HeaderType enum
        yield '# =============================================================================\n'
        yield '# Header Types - Define start byte patterns\n'
        yield '# =============================================================================\n\n'
        
        yield 'class HeaderType(Enum):\n'
        yield '    """Header types defining start byte patterns"""\n'
        yield '    NONE = 0       # No start bytes\n'
        yield '    TINY = 1       # 1 start byte [0x70+PayloadType]\n'
        yield '    BASIC = 2      # 2 start bytes [0x90] [0x70+PayloadType]\n'
        yield '    UBX = 3        # 2 start bytes [0xB5] [0x62]\n'
        yield '    MAVLINK_V1 = 4 # 1 start byte [0xFE]\n'
        yield '    MAVLINK_V2 = 5 # 1 start byte [0xFD]\n\n\n'
        
        # Generate PayloadType enum
        yield '# =============================================================================\n'
        yield '# Payload Types - Define header/footer structure\n'
        yield '# =============================================================================\n\n'
        
        yield 'class PayloadType(Enum):\n'
        yield '    """Payload types defining header/footer structure"""\n'
        yield '    MINIMAL = 0                      # [MSG_ID] [PACKET]\n'
        yield '    DEFAULT = 1                      # [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    EXTENDED_MSG_IDS = 2             # [LEN] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    EXTENDED_LENGTH = 3              # [LEN16] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    EXTENDED = 4                     # [LEN16] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    SYS_COMP = 5                     # [SYS_ID] [COMP_ID] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    SEQ = 6                          # [SEQ] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    MULTI_SYSTEM_STREAM = 7          # [SEQ] [SYS_ID] [COMP_ID] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]\n'
        yield '    EXTENDED_MULTI_SYSTEM_STREAM = 8 # [SEQ] [SYS_ID] [COMP_ID] [LEN16] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]\n\n\n'
        
        # Generate constants
        yield '# =============================================================================\n'
        yield '# Constants\n'
        yield '# =============================================================================\n\n'
        
        yield '# Start byte constants\n'
        yield 'BASIC_START_BYTE = 0x90\n'
        yield 'PAYLOAD_TYPE_BASE = 0x70  # Payload type encoded as 0x70 + PayloadType.value\n'
        yield 'UBX_SYNC1 = 0xB5\n'
        yield 'UBX_SYNC2 = 0x62\n'
        yield 'MAVLINK_V1_STX = 0xFE\n'
        yield 'MAVLINK_V2_STX = 0xFD\n\n'
        
        yield '# Maximum payload type value (for range checking)\n'
        yield 'MAX_PAYLOAD_TYPE = 8\n\n\n'
        
        # Generate PayloadConfig dataclass
        yield '# =============================================================================\n'
        yield '# Payload Configuration\n'
        yield '# =============================================================================\n\n'
        
        yield '@dataclass\n'
        yield 'class PayloadConfig:\n'
        yield '    """Configuration for a payload type"""\n'
        yield '    payload_type: PayloadType\n'
        yield '    has_crc: bool\n'
        yield '    crc_bytes: int\n'
        yield '    has_length: bool\n'
        yield '    length_bytes: int  # 1 or 2\n'
        yield '    has_sequence: bool\n'
        yield '    has_system_id: bool\n'
        yield '    has_component_id: bool\n'
        yield '    has_package_id: bool\n\n'
        yield '    @property\n'
        yield '    def header_size(self) -> int:\n'
        yield '        """Size of payload header (before message data)"""\n'
        yield '        size = 1  # msg_id\n'
        yield '        if self.has_length:\n'
        yield '            size += self.length_bytes\n'
        yield '        if self.has_sequence:\n'
        yield '            size += 1\n'
        yield '        if self.has_system_id:\n'
        yield '            size += 1\n'
        yield '        if self.has_component_id:\n'
        yield '            size += 1\n'
        yield '        if self.has_package_id:\n'
        yield '            size += 1\n'
        yield '        return size\n\n'
        yield '    @property\n'
        yield '    def footer_size(self) -> int:\n'
        yield '        """Size of payload footer (CRC)"""\n'
        yield '        return self.crc_bytes\n\n'
        yield '    @property\n'
        yield '    def overhead(self) -> int:\n'
        yield '        """Total overhead (header + footer)"""\n'
        yield '        return self.header_size + self.footer_size\n\n\n'
        
        # Generate payload configurations from parsed definitions
        yield '# Payload type configurations\n'
        yield 'PAYLOAD_CONFIGS = {\n'
        
        for payload in collection.get_standard_payloads():
            pt = payload.payload_type
            yield f'    PayloadType.{pt.name}: PayloadConfig(\n'
            yield f'        payload_type=PayloadType.{pt.name},\n'
            yield f'        has_crc={payload.has_crc},\n'
            yield f'        crc_bytes={payload.crc_bytes},\n'
            yield f'        has_length={payload.has_length},\n'
            yield f'        length_bytes={payload.length_bytes},\n'
            yield f'        has_sequence={payload.has_sequence},\n'
            yield f'        has_system_id={payload.has_system_id},\n'
            yield f'        has_component_id={payload.has_component_id},\n'
            yield f'        has_package_id={payload.has_package_id},\n'
            yield '    ),\n'
        
        yield '}\n\n\n'
        
        # Generate checksum function
        yield '# =============================================================================\n'
        yield '# Utilities\n'
        yield '# =============================================================================\n\n'
        
        yield 'def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:\n'
        yield '    """Calculate Fletcher-16 checksum over the given data"""\n'
        yield '    if end is None:\n'
        yield '        end = len(buffer)\n'
        yield '    byte1 = 0\n'
        yield '    byte2 = 0\n'
        yield '    for x in range(start, end):\n'
        yield '        byte1 = (byte1 + buffer[x]) % 256\n'
        yield '        byte2 = (byte2 + byte1) % 256\n'
        yield '    return (byte1, byte2)\n\n\n'
        
        # Generate FrameMsgInfo
        yield '@dataclass\n'
        yield 'class FrameMsgInfo:\n'
        yield '    """Result from frame parsing"""\n'
        yield '    valid: bool = False\n'
        yield '    header_type: Optional[HeaderType] = None\n'
        yield '    payload_type: Optional[PayloadType] = None\n'
        yield '    msg_id: int = 0\n'
        yield '    msg_len: int = 0\n'
        yield '    msg_data: bytes = b\'\'\n'
        yield '    # Optional extended fields\n'
        yield '    package_id: int = 0\n'
        yield '    sequence: int = 0\n'
        yield '    system_id: int = 0\n'
        yield '    component_id: int = 0\n\n\n'
        
        # Generate parser state enum
        yield 'class ParserState(Enum):\n'
        yield '    """Parser state machine states"""\n'
        yield '    LOOKING_FOR_START = 0\n'
        yield '    GOT_BASIC_START = 1  # Got 0x90, waiting for payload type byte\n'
        yield '    GOT_UBX_SYNC1 = 2    # Got 0xB5, waiting for 0x62\n'
        yield '    PARSING_HEADER = 3   # Parsing payload header fields\n'
        yield '    PARSING_PAYLOAD = 4  # Parsing message data\n'
        yield '    PARSING_FOOTER = 5   # Parsing CRC\n\n\n'
        
        # Generate the main PolyglotParser class
        yield '# =============================================================================\n'
        yield '# Polyglot Parser\n'
        yield '# =============================================================================\n\n'
        
        yield 'class PolyglotParser:\n'
        yield '    """\n'
        yield '    Polyglot frame parser that can detect and parse multiple frame types.\n'
        yield '    \n'
        yield '    Supports:\n'
        yield '    - Basic frames: [0x90] [0x70+payload_type] [payload...]\n'
        yield '    - Tiny frames:  [0x70+payload_type] [payload...]\n'
        yield '    - None frames:  [payload...] (no start bytes)\n'
        yield '    \n'
        yield '    The payload type (0-8) determines the payload structure.\n'
        yield '    """\n\n'
        
        # Constructor
        yield '    def __init__(self,\n'
        yield '                 get_msg_length: Callable[[int], int] = None,\n'
        yield '                 enable_basic: bool = True,\n'
        yield '                 enable_tiny: bool = True,\n'
        yield '                 enable_none: bool = False,\n'
        yield '                 default_payload_type: PayloadType = PayloadType.DEFAULT):\n'
        yield '        """\n'
        yield '        Initialize polyglot parser.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            get_msg_length: Callback to get message length from msg_id (required for Minimal payloads)\n'
        yield '            enable_basic: Enable Basic frame parsing (default: True)\n'
        yield '            enable_tiny: Enable Tiny frame parsing (default: True)\n'
        yield '            enable_none: Enable None frame parsing (default: False, requires external sync)\n'
        yield '            default_payload_type: Default payload type for None frames\n'
        yield '        """\n'
        yield '        self.get_msg_length = get_msg_length\n'
        yield '        self.enable_basic = enable_basic\n'
        yield '        self.enable_tiny = enable_tiny\n'
        yield '        self.enable_none = enable_none\n'
        yield '        self.default_payload_type = default_payload_type\n'
        yield '        self.reset()\n\n'
        
        # Reset method
        yield '    def reset(self):\n'
        yield '        """Reset parser state"""\n'
        yield '        self.state = ParserState.LOOKING_FOR_START\n'
        yield '        self.header_type: Optional[HeaderType] = None\n'
        yield '        self.payload_type: Optional[PayloadType] = None\n'
        yield '        self.payload_config: Optional[PayloadConfig] = None\n'
        yield '        self.buffer: List[int] = []\n'
        yield '        self.header_bytes_remaining = 0\n'
        yield '        self.payload_bytes_remaining = 0\n'
        yield '        self.footer_bytes_remaining = 0\n'
        yield '        # Parsed header fields\n'
        yield '        self.msg_id = 0\n'
        yield '        self.msg_len = 0\n'
        yield '        self.package_id = 0\n'
        yield '        self.sequence = 0\n'
        yield '        self.system_id = 0\n'
        yield '        self.component_id = 0\n'
        yield '        self.header_field_index = 0\n\n'
        
        # Parse byte method
        yield '    def parse_byte(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """\n'
        yield '        Parse a single byte.\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            FrameMsgInfo with valid=True when a complete message is received\n'
        yield '        """\n'
        yield '        result = FrameMsgInfo()\n\n'
        
        yield '        if self.state == ParserState.LOOKING_FOR_START:\n'
        yield '            result = self._handle_looking_for_start(byte)\n'
        yield '        elif self.state == ParserState.GOT_BASIC_START:\n'
        yield '            result = self._handle_got_basic_start(byte)\n'
        yield '        elif self.state == ParserState.GOT_UBX_SYNC1:\n'
        yield '            result = self._handle_got_ubx_sync1(byte)\n'
        yield '        elif self.state == ParserState.PARSING_HEADER:\n'
        yield '            result = self._handle_parsing_header(byte)\n'
        yield '        elif self.state == ParserState.PARSING_PAYLOAD:\n'
        yield '            result = self._handle_parsing_payload(byte)\n'
        yield '        elif self.state == ParserState.PARSING_FOOTER:\n'
        yield '            result = self._handle_parsing_footer(byte)\n\n'
        yield '        return result\n\n'
        
        # Handle looking for start
        yield '    def _handle_looking_for_start(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle LOOKING_FOR_START state"""\n'
        yield '        # Check for Basic frame (0x90)\n'
        yield '        if self.enable_basic and byte == BASIC_START_BYTE:\n'
        yield '            self.state = ParserState.GOT_BASIC_START\n'
        yield '            self.header_type = HeaderType.BASIC\n'
        yield '            self.buffer = [byte]\n'
        yield '        # Check for Tiny frame (0x70-0x78)\n'
        yield '        elif self.enable_tiny and PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:\n'
        yield '            payload_type_value = byte - PAYLOAD_TYPE_BASE\n'
        yield '            self._start_payload_parsing(HeaderType.TINY, PayloadType(payload_type_value), [byte])\n'
        yield '        # Check for UBX (0xB5)\n'
        yield '        elif byte == UBX_SYNC1:\n'
        yield '            self.state = ParserState.GOT_UBX_SYNC1\n'
        yield '            self.buffer = [byte]\n'
        yield '        # Check for Mavlink V1 (0xFE)\n'
        yield '        elif byte == MAVLINK_V1_STX:\n'
        yield '            self.header_type = HeaderType.MAVLINK_V1\n'
        yield '            # TODO: Implement Mavlink V1 parsing\n'
        yield '            self.reset()\n'
        yield '        # Check for Mavlink V2 (0xFD)\n'
        yield '        elif byte == MAVLINK_V2_STX:\n'
        yield '            self.header_type = HeaderType.MAVLINK_V2\n'
        yield '            # TODO: Implement Mavlink V2 parsing\n'
        yield '            self.reset()\n'
        yield '        # None frame (no start bytes) - treat as payload directly\n'
        yield '        elif self.enable_none:\n'
        yield '            self._start_payload_parsing(HeaderType.NONE, self.default_payload_type, [])\n'
        yield '            return self._handle_parsing_header(byte)\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle got basic start
        yield '    def _handle_got_basic_start(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle GOT_BASIC_START state - waiting for payload type byte"""\n'
        yield '        if PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:\n'
        yield '            payload_type_value = byte - PAYLOAD_TYPE_BASE\n'
        yield '            self.buffer.append(byte)\n'
        yield '            self._start_payload_parsing(HeaderType.BASIC, PayloadType(payload_type_value), self.buffer)\n'
        yield '        else:\n'
        yield '            # Invalid second byte, reset\n'
        yield '            self.reset()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle got UBX sync1
        yield '    def _handle_got_ubx_sync1(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle GOT_UBX_SYNC1 state - waiting for second sync byte"""\n'
        yield '        if byte == UBX_SYNC2:\n'
        yield '            self.buffer.append(byte)\n'
        yield '            self.header_type = HeaderType.UBX\n'
        yield '            # TODO: Implement UBX payload parsing\n'
        yield '            self.reset()\n'
        yield '        else:\n'
        yield '            self.reset()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Start payload parsing
        yield '    def _start_payload_parsing(self, header_type: HeaderType, payload_type: PayloadType, buffer: List[int]):\n'
        yield '        """Initialize payload parsing after header detection"""\n'
        yield '        self.header_type = header_type\n'
        yield '        self.payload_type = payload_type\n'
        yield '        self.payload_config = PAYLOAD_CONFIGS.get(payload_type)\n'
        yield '        self.buffer = buffer.copy()\n'
        yield '        self.header_field_index = 0\n'
        yield '        self.state = ParserState.PARSING_HEADER\n\n'
        
        # Handle parsing header
        yield '    def _handle_parsing_header(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse payload header fields based on payload type"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        config = self.payload_config\n'
        yield '        if config is None:\n'
        yield '            self.reset()\n'
        yield '            return FrameMsgInfo()\n\n'
        yield '        # Parse header fields in order based on payload type\n'
        yield '        # Order: [SEQ] [SYS_ID] [COMP_ID] [LEN/LEN16] [PKG_ID] [MSG_ID]\n'
        yield '        field_order = []\n'
        yield '        if config.has_sequence:\n'
        yield '            field_order.append(\'sequence\')\n'
        yield '        if config.has_system_id:\n'
        yield '            field_order.append(\'system_id\')\n'
        yield '        if config.has_component_id:\n'
        yield '            field_order.append(\'component_id\')\n'
        yield '        if config.has_length:\n'
        yield '            if config.length_bytes == 2:\n'
        yield '                field_order.append(\'length_lo\')\n'
        yield '                field_order.append(\'length_hi\')\n'
        yield '            else:\n'
        yield '                field_order.append(\'length\')\n'
        yield '        if config.has_package_id:\n'
        yield '            field_order.append(\'package_id\')\n'
        yield '        field_order.append(\'msg_id\')\n\n'
        yield '        if self.header_field_index < len(field_order):\n'
        yield '            field_name = field_order[self.header_field_index]\n'
        yield '            if field_name == \'sequence\':\n'
        yield '                self.sequence = byte\n'
        yield '            elif field_name == \'system_id\':\n'
        yield '                self.system_id = byte\n'
        yield '            elif field_name == \'component_id\':\n'
        yield '                self.component_id = byte\n'
        yield '            elif field_name == \'length\':\n'
        yield '                self.msg_len = byte\n'
        yield '            elif field_name == \'length_lo\':\n'
        yield '                self.msg_len = byte\n'
        yield '            elif field_name == \'length_hi\':\n'
        yield '                self.msg_len |= (byte << 8)\n'
        yield '            elif field_name == \'package_id\':\n'
        yield '                self.package_id = byte\n'
        yield '            elif field_name == \'msg_id\':\n'
        yield '                self.msg_id = byte\n'
        yield '            self.header_field_index += 1\n\n'
        yield '        # Check if header is complete\n'
        yield '        if self.header_field_index >= len(field_order):\n'
        yield '            # Determine payload length\n'
        yield '            if config.has_length:\n'
        yield '                self.payload_bytes_remaining = self.msg_len\n'
        yield '            elif self.get_msg_length:\n'
        yield '                self.payload_bytes_remaining = self.get_msg_length(self.msg_id)\n'
        yield '            else:\n'
        yield '                # No length field and no callback - can\'t determine length\n'
        yield '                self.reset()\n'
        yield '                return FrameMsgInfo()\n'
        yield '            \n'
        yield '            self.footer_bytes_remaining = config.footer_size\n'
        yield '            self.state = ParserState.PARSING_PAYLOAD if self.payload_bytes_remaining > 0 else ParserState.PARSING_FOOTER\n\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle parsing payload
        yield '    def _handle_parsing_payload(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse message payload data"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        self.payload_bytes_remaining -= 1\n\n'
        yield '        if self.payload_bytes_remaining <= 0:\n'
        yield '            if self.footer_bytes_remaining > 0:\n'
        yield '                self.state = ParserState.PARSING_FOOTER\n'
        yield '            else:\n'
        yield '                return self._complete_message()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle parsing footer
        yield '    def _handle_parsing_footer(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse footer (CRC) bytes"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        self.footer_bytes_remaining -= 1\n\n'
        yield '        if self.footer_bytes_remaining <= 0:\n'
        yield '            return self._complete_message()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Complete message
        yield '    def _complete_message(self) -> FrameMsgInfo:\n'
        yield '        """Validate and return completed message"""\n'
        yield '        config = self.payload_config\n'
        yield '        if config is None:\n'
        yield '            self.reset()\n'
        yield '            return FrameMsgInfo()\n\n'
        yield '        # Validate CRC if present\n'
        yield '        if config.has_crc:\n'
        yield '            # CRC is calculated from after start bytes to before CRC\n'
        yield '            header_size = 0\n'
        yield '            if self.header_type == HeaderType.BASIC:\n'
        yield '                header_size = 2\n'
        yield '            elif self.header_type == HeaderType.TINY:\n'
        yield '                header_size = 1\n'
        yield '            crc_start = header_size\n'
        yield '            crc_end = len(self.buffer) - config.crc_bytes\n'
        yield '            calc_crc = fletcher_checksum(self.buffer, crc_start, crc_end)\n'
        yield '            recv_crc = (self.buffer[-2], self.buffer[-1])\n'
        yield '            if calc_crc != recv_crc:\n'
        yield '                self.reset()\n'
        yield '                return FrameMsgInfo()\n\n'
        yield '        # Extract message data\n'
        yield '        header_size = 0\n'
        yield '        if self.header_type == HeaderType.BASIC:\n'
        yield '            header_size = 2\n'
        yield '        elif self.header_type == HeaderType.TINY:\n'
        yield '            header_size = 1\n'
        yield '        payload_header_size = config.header_size\n'
        yield '        data_start = header_size + payload_header_size\n'
        yield '        data_end = len(self.buffer) - config.footer_size\n'
        yield '        msg_data = bytes(self.buffer[data_start:data_end])\n\n'
        yield '        result = FrameMsgInfo(\n'
        yield '            valid=True,\n'
        yield '            header_type=self.header_type,\n'
        yield '            payload_type=self.payload_type,\n'
        yield '            msg_id=self.msg_id,\n'
        yield '            msg_len=len(msg_data),\n'
        yield '            msg_data=msg_data,\n'
        yield '            package_id=self.package_id,\n'
        yield '            sequence=self.sequence,\n'
        yield '            system_id=self.system_id,\n'
        yield '            component_id=self.component_id,\n'
        yield '        )\n'
        yield '        self.reset()\n'
        yield '        return result\n\n'
        
        # Encode method
        yield '    def encode(self, msg_id: int, msg: bytes,\n'
        yield '               header_type: HeaderType = HeaderType.BASIC,\n'
        yield '               payload_type: PayloadType = PayloadType.DEFAULT,\n'
        yield '               package_id: int = 0,\n'
        yield '               sequence: int = 0,\n'
        yield '               system_id: int = 0,\n'
        yield '               component_id: int = 0) -> bytes:\n'
        yield '        """\n'
        yield '        Encode a message with specified header and payload type.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            msg_id: Message ID (0-255)\n'
        yield '            msg: Message data bytes\n'
        yield '            header_type: Header type (BASIC, TINY, or NONE)\n'
        yield '            payload_type: Payload type (MINIMAL, DEFAULT, etc.)\n'
        yield '            package_id: Package ID for EXTENDED_MSG_IDS payloads\n'
        yield '            sequence: Sequence number for SEQ payloads\n'
        yield '            system_id: System ID for SYS_COMP payloads\n'
        yield '            component_id: Component ID for SYS_COMP payloads\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            Encoded frame bytes\n'
        yield '        """\n'
        yield '        config = PAYLOAD_CONFIGS.get(payload_type)\n'
        yield '        if config is None:\n'
        yield '            raise ValueError(f"Unknown payload type: {payload_type}")\n\n'
        yield '        output = []\n\n'
        yield '        # Add header start bytes\n'
        yield '        if header_type == HeaderType.BASIC:\n'
        yield '            output.append(BASIC_START_BYTE)\n'
        yield '            output.append(PAYLOAD_TYPE_BASE + payload_type.value)\n'
        yield '        elif header_type == HeaderType.TINY:\n'
        yield '            output.append(PAYLOAD_TYPE_BASE + payload_type.value)\n'
        yield '        # NONE has no start bytes\n\n'
        yield '        # Add payload header fields in order\n'
        yield '        if config.has_sequence:\n'
        yield '            output.append(sequence & 0xFF)\n'
        yield '        if config.has_system_id:\n'
        yield '            output.append(system_id & 0xFF)\n'
        yield '        if config.has_component_id:\n'
        yield '            output.append(component_id & 0xFF)\n'
        yield '        if config.has_length:\n'
        yield '            if config.length_bytes == 2:\n'
        yield '                output.append(len(msg) & 0xFF)\n'
        yield '                output.append((len(msg) >> 8) & 0xFF)\n'
        yield '            else:\n'
        yield '                output.append(len(msg) & 0xFF)\n'
        yield '        if config.has_package_id:\n'
        yield '            output.append(package_id & 0xFF)\n'
        yield '        output.append(msg_id & 0xFF)\n\n'
        yield '        # Add message data\n'
        yield '        output.extend(msg)\n\n'
        yield '        # Add CRC if needed\n'
        yield '        if config.has_crc:\n'
        yield '            # CRC calculated from after start bytes\n'
        yield '            crc_start = 0\n'
        yield '            if header_type == HeaderType.BASIC:\n'
        yield '                crc_start = 2\n'
        yield '            elif header_type == HeaderType.TINY:\n'
        yield '                crc_start = 1\n'
        yield '            crc = fletcher_checksum(output, crc_start)\n'
        yield '            output.append(crc[0])\n'
        yield '            output.append(crc[1])\n\n'
        yield '        return bytes(output)\n\n'
        
        # Convenience methods
        yield '    def encode_basic(self, msg_id: int, msg: bytes,\n'
        yield '                     payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:\n'
        yield '        """Encode with Basic header"""\n'
        yield '        return self.encode(msg_id, msg, HeaderType.BASIC, payload_type, **kwargs)\n\n'
        yield '    def encode_tiny(self, msg_id: int, msg: bytes,\n'
        yield '                    payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:\n'
        yield '        """Encode with Tiny header"""\n'
        yield '        return self.encode(msg_id, msg, HeaderType.TINY, payload_type, **kwargs)\n\n'


def generate_py_polyglot_parser(collection):
    """Generate Python polyglot parser code"""
    return ''.join(PolyglotParserPyGen.generate_polyglot_parser(collection))
