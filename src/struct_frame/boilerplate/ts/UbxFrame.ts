// Automatically generated frame parser
// Generated by 0.0.1 at Thu Dec  4 20:27:20 2025.

import {
    FrameMsgInfo, createFrameMsgInfo, fletcher_checksum,
    validate_payload_with_crc, validate_payload_minimal,
    encode_payload_with_crc, encode_payload_minimal,
} from './frame_base';

// =============================================================================
// UbxFrame Frame Format
// =============================================================================

export enum UbxFrameParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * UbxFrame - Frame format parser and encoder
 * 
 * Format: [SYNC1=0xB5] [SYNC2=0x62] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class UbxFrame {
    static readonly START_BYTE1 = 0xB5;
    static readonly START_BYTE2 = 0x62;
    static readonly HEADER_SIZE = 5;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 7;
    static readonly LENGTH_BYTES = 1;

    private state: UbxFrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new UbxFrame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case UbxFrameParserState.LOOKING_FOR_START1:
                if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                }
                break;

            case UbxFrameParserState.LOOKING_FOR_START2:
                if (byte === UbxFrame.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = UbxFrameParserState.GETTING_MSG_ID;
                } else if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                } else {
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case UbxFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = UbxFrameParserState.GETTING_LENGTH;
                break;

            case UbxFrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = UbxFrame.OVERHEAD + this.msg_length;
                this.state = UbxFrameParserState.GETTING_PAYLOAD;
                break;

            case UbxFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Use shared payload validation with CRC
                    const validationResult = validate_payload_with_crc(this.buffer, UbxFrame.HEADER_SIZE, 1, 2);
                    if (validationResult.valid) {
                        result.valid = validationResult.valid;
                        result.msg_id = validationResult.msg_id;
                        result.msg_len = validationResult.msg_len;
                        result.msg_data = validationResult.msg_data;
                    }
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with UbxFrame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(UbxFrame.START_BYTE1);
        output.push(UbxFrame.START_BYTE2);
        // Use shared payload encoding with CRC
        encode_payload_with_crc(output, msg_id, msg, 1, 2);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete UbxFrame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        if (buffer.length < UbxFrame.OVERHEAD) {
            return createFrameMsgInfo();
        }

        if (buffer[0] !== UbxFrame.START_BYTE1) {
            return createFrameMsgInfo();
        }
        if (buffer[1] !== UbxFrame.START_BYTE2) {
            return createFrameMsgInfo();
        }

        // Use shared payload validation with CRC
        return validate_payload_with_crc(buffer, UbxFrame.HEADER_SIZE, 1, 2);
    }
}
