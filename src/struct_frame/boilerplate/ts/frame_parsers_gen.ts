// Automatically generated frame parser
// Generated by 0.0.1 at Sun Nov 30 16:50:10 2025.

// Frame format type enumeration
export enum FrameFormatType {
    MINIMAL_FRAME = 0,
    BASIC_FRAME = 1,
    BASIC_FRAME_NO_CRC = 2,
    TINY_FRAME = 3,
    TINY_FRAME_NO_CRC = 4,
    MINIMAL_FRAME_WITH_LEN = 5,
    MINIMAL_FRAME_WITH_LEN_NO_CRC = 6,
    BASIC_FRAME_WITH_LEN = 7,
    BASIC_FRAME_WITH_LEN_NO_CRC = 8,
    TINY_FRAME_WITH_LEN = 9,
    TINY_FRAME_WITH_LEN_NO_CRC = 10,
    MINIMAL_FRAME_WITH_LEN16 = 11,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12,
    BASIC_FRAME_WITH_LEN16 = 13,
    BASIC_FRAME_WITH_LEN16_NO_CRC = 14,
    TINY_FRAME_WITH_LEN16 = 15,
    TINY_FRAME_WITH_LEN16_NO_CRC = 16,
    BASIC_FRAME_WITH_SYS_COMP = 17,
    UBX_FRAME = 18,
    MAVLINK_V1_FRAME = 19,
    MAVLINK_V2_FRAME = 20,
    FRAME_FORMAT_CONFIG = 21,
}

// Fletcher-16 checksum calculation
export function fletcher_checksum(buffer: Uint8Array | number[], start: number = 0, end?: number): [number, number] {
    if (end === undefined) {
        end = buffer.length;
    }
    
    let byte1 = 0;
    let byte2 = 0;
    
    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }
    
    return [byte1, byte2];
}

// Parse result interface
export interface FrameMsgInfo {
    valid: boolean;
    msg_id: number;
    msg_len: number;
    msg_data: Uint8Array;
}

// Create default FrameMsgInfo
export function createFrameMsgInfo(): FrameMsgInfo {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// MinimalFrame Frame Format
// =============================================================================

export enum MinimalFrameParserState {
    GETTING_MSG_ID = 0,
    GETTING_PAYLOAD = 1
}

/**
 * MinimalFrame - Frame format parser and encoder
 * 
 * Format: [MSG_ID] [MSG...] [CRC1] [CRC2]
 */
export class MinimalFrame {
    static readonly HEADER_SIZE = 1;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 3;

    private state: MinimalFrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MinimalFrame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = MinimalFrame.OVERHEAD + msg_length;
                        this.state = MinimalFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = MinimalFrameParserState.GETTING_MSG_ID;
                    }
                } else {
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;

            case MinimalFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - MinimalFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrame.HEADER_SIZE, this.packet_size - MinimalFrame.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MinimalFrame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MinimalFrame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrame.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrame.HEADER_SIZE, buffer.length - MinimalFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrame Frame Format
// =============================================================================

export enum BasicFrameParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_PAYLOAD = 3
}

/**
 * BasicFrame - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x91] [MSG_ID] [MSG...] [CRC1] [CRC2]
 */
export class BasicFrame {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x91;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 5;

    private state: BasicFrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameParserState.LOOKING_FOR_START1:
                if (byte === BasicFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameParserState.LOOKING_FOR_START2:
                if (byte === BasicFrame.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrame.OVERHEAD + msg_length;
                        this.state = BasicFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - BasicFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrame.HEADER_SIZE, this.packet_size - BasicFrame.FOOTER_SIZE));
                    }
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrame.START_BYTE1);
        output.push(BasicFrame.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrame.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrame.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrame.HEADER_SIZE, buffer.length - BasicFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameNoCrc Frame Format
// =============================================================================

export enum BasicFrameNoCrcParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_PAYLOAD = 3
}

/**
 * BasicFrameNoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x95] [MSG_ID] [MSG...]
 */
export class BasicFrameNoCrc {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x95;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 3;

    private state: BasicFrameNoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameNoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameNoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameNoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameNoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameNoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrameNoCrc.OVERHEAD + msg_length;
                        this.state = BasicFrameNoCrcParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameNoCrc.HEADER_SIZE));
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameNoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameNoCrc.START_BYTE1);
        output.push(BasicFrameNoCrc.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameNoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameNoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameNoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrame Frame Format
// =============================================================================

export enum TinyFrameParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_PAYLOAD = 2
}

/**
 * TinyFrame - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x70] [MSG_ID] [MSG...] [CRC1] [CRC2]
 */
export class TinyFrame {
    static readonly START_BYTE = 0x70;
    static readonly HEADER_SIZE = 2;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 4;

    private state: TinyFrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameParserState.LOOKING_FOR_START:
                if (byte === TinyFrame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = TinyFrame.OVERHEAD + msg_length;
                        this.state = TinyFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = TinyFrameParserState.LOOKING_FOR_START;
                    }
                } else {
                    this.state = TinyFrameParserState.LOOKING_FOR_START;
                }
                break;

            case TinyFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - TinyFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrame.HEADER_SIZE, this.packet_size - TinyFrame.FOOTER_SIZE));
                    }
                    this.state = TinyFrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrame.START_BYTE);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrame.HEADER_SIZE, buffer.length - TinyFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameNoCrc Frame Format
// =============================================================================

export enum TinyFrameNoCrcParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_PAYLOAD = 2
}

/**
 * TinyFrameNoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x72] [MSG_ID] [MSG...]
 */
export class TinyFrameNoCrc {
    static readonly START_BYTE = 0x72;
    static readonly HEADER_SIZE = 2;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 2;

    private state: TinyFrameNoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameNoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameNoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameNoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameNoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = TinyFrameNoCrc.OVERHEAD + msg_length;
                        this.state = TinyFrameNoCrcParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                    }
                } else {
                    this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                }
                break;

            case TinyFrameNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameNoCrc.HEADER_SIZE));
                    this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameNoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameNoCrc.START_BYTE);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameNoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameNoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen Frame Format
// =============================================================================

export enum MinimalFrameWithLenParserState {
    GETTING_MSG_ID = 0,
    GETTING_LENGTH = 1,
    GETTING_PAYLOAD = 2
}

/**
 * MinimalFrameWithLen - Frame format parser and encoder
 * 
 * Format: [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class MinimalFrameWithLen {
    static readonly HEADER_SIZE = 2;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 4;
    static readonly LENGTH_BYTES = 1;

    private state: MinimalFrameWithLenParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MinimalFrameWithLen parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLenParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MinimalFrameWithLen.OVERHEAD + this.msg_length;
                this.state = MinimalFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case MinimalFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - MinimalFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen.HEADER_SIZE, this.packet_size - MinimalFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MinimalFrameWithLen format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MinimalFrameWithLen packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen.HEADER_SIZE, buffer.length - MinimalFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLenNoCrc Frame Format
// =============================================================================

export enum MinimalFrameWithLenNoCrcParserState {
    GETTING_MSG_ID = 0,
    GETTING_LENGTH = 1,
    GETTING_PAYLOAD = 2
}

/**
 * MinimalFrameWithLenNoCrc - Frame format parser and encoder
 * 
 * Format: [MSG_ID] [LEN] [MSG...]
 */
export class MinimalFrameWithLenNoCrc {
    static readonly HEADER_SIZE = 2;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 2;
    static readonly LENGTH_BYTES = 1;

    private state: MinimalFrameWithLenNoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MinimalFrameWithLenNoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MinimalFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - MinimalFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MinimalFrameWithLenNoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MinimalFrameWithLenNoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen Frame Format
// =============================================================================

export enum BasicFrameWithLenParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * BasicFrameWithLen - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x92] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class BasicFrameWithLen {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x92;
    static readonly HEADER_SIZE = 4;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 6;
    static readonly LENGTH_BYTES = 1;

    private state: BasicFrameWithLenParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameWithLen parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLenParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLenParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLenParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLenParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = BasicFrameWithLen.OVERHEAD + this.msg_length;
                this.state = BasicFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case BasicFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - BasicFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen.HEADER_SIZE, this.packet_size - BasicFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameWithLen format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameWithLen.START_BYTE1);
        output.push(BasicFrameWithLen.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameWithLen packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen.HEADER_SIZE, buffer.length - BasicFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameWithLenNoCrc Frame Format
// =============================================================================

export enum BasicFrameWithLenNoCrcParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * BasicFrameWithLenNoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x96] [MSG_ID] [LEN] [MSG...]
 */
export class BasicFrameWithLenNoCrc {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x96;
    static readonly HEADER_SIZE = 4;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 4;
    static readonly LENGTH_BYTES = 1;

    private state: BasicFrameWithLenNoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameWithLenNoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLenNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLenNoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLenNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = BasicFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameWithLenNoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameWithLenNoCrc.START_BYTE1);
        output.push(BasicFrameWithLenNoCrc.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameWithLenNoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLenNoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLenNoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen Frame Format
// =============================================================================

export enum TinyFrameWithLenParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * TinyFrameWithLen - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x71] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class TinyFrameWithLen {
    static readonly START_BYTE = 0x71;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 5;
    static readonly LENGTH_BYTES = 1;

    private state: TinyFrameWithLenParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameWithLen parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLenParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLenParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLenParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = TinyFrameWithLen.OVERHEAD + this.msg_length;
                this.state = TinyFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case TinyFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - TinyFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen.HEADER_SIZE, this.packet_size - TinyFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameWithLen format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameWithLen.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameWithLen packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen.HEADER_SIZE, buffer.length - TinyFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameWithLenNoCrc Frame Format
// =============================================================================

export enum TinyFrameWithLenNoCrcParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * TinyFrameWithLenNoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x73] [MSG_ID] [LEN] [MSG...]
 */
export class TinyFrameWithLenNoCrc {
    static readonly START_BYTE = 0x73;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 3;
    static readonly LENGTH_BYTES = 1;

    private state: TinyFrameWithLenNoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameWithLenNoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLenNoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = TinyFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameWithLenNoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameWithLenNoCrc.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameWithLenNoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLenNoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen16 Frame Format
// =============================================================================

export enum MinimalFrameWithLen16ParserState {
    GETTING_MSG_ID = 0,
    GETTING_LENGTH = 1,
    GETTING_PAYLOAD = 2
}

/**
 * MinimalFrameWithLen16 - Frame format parser and encoder
 * 
 * Format: [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
 */
export class MinimalFrameWithLen16 {
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 5;
    static readonly LENGTH_BYTES = 2;

    private state: MinimalFrameWithLen16ParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MinimalFrameWithLen16 parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 2) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = MinimalFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = MinimalFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case MinimalFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - MinimalFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen16.HEADER_SIZE, this.packet_size - MinimalFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MinimalFrameWithLen16 format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MinimalFrameWithLen16 packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen16.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen16.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen16.HEADER_SIZE, buffer.length - MinimalFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen16NoCrc Frame Format
// =============================================================================

export enum MinimalFrameWithLen16NoCrcParserState {
    GETTING_MSG_ID = 0,
    GETTING_LENGTH = 1,
    GETTING_PAYLOAD = 2
}

/**
 * MinimalFrameWithLen16NoCrc - Frame format parser and encoder
 * 
 * Format: [MSG_ID] [LEN16] [MSG...]
 */
export class MinimalFrameWithLen16NoCrc {
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 3;
    static readonly LENGTH_BYTES = 2;

    private state: MinimalFrameWithLen16NoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MinimalFrameWithLen16NoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 2) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = MinimalFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - MinimalFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MinimalFrameWithLen16NoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MinimalFrameWithLen16NoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen16 Frame Format
// =============================================================================

export enum BasicFrameWithLen16ParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * BasicFrameWithLen16 - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x93] [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
 */
export class BasicFrameWithLen16 {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x93;
    static readonly HEADER_SIZE = 5;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 7;
    static readonly LENGTH_BYTES = 2;

    private state: BasicFrameWithLen16ParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameWithLen16 parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLen16ParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen16.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLen16ParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen16.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLen16ParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen16.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 4) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = BasicFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = BasicFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case BasicFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - BasicFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen16.HEADER_SIZE, this.packet_size - BasicFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameWithLen16 format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameWithLen16.START_BYTE1);
        output.push(BasicFrameWithLen16.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameWithLen16 packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen16.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen16.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen16.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen16.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen16.HEADER_SIZE, buffer.length - BasicFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen16NoCrc Frame Format
// =============================================================================

export enum BasicFrameWithLen16NoCrcParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * BasicFrameWithLen16NoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x97] [MSG_ID] [LEN16] [MSG...]
 */
export class BasicFrameWithLen16NoCrc {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x97;
    static readonly HEADER_SIZE = 5;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 5;
    static readonly LENGTH_BYTES = 2;

    private state: BasicFrameWithLen16NoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameWithLen16NoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 4) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = BasicFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameWithLen16NoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameWithLen16NoCrc.START_BYTE1);
        output.push(BasicFrameWithLen16NoCrc.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameWithLen16NoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen16NoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen16NoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen16 Frame Format
// =============================================================================

export enum TinyFrameWithLen16ParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * TinyFrameWithLen16 - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x74] [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
 */
export class TinyFrameWithLen16 {
    static readonly START_BYTE = 0x74;
    static readonly HEADER_SIZE = 4;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 6;
    static readonly LENGTH_BYTES = 2;

    private state: TinyFrameWithLen16ParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameWithLen16 parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLen16ParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen16.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLen16ParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 3) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = TinyFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = TinyFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case TinyFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - TinyFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen16.HEADER_SIZE, this.packet_size - TinyFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameWithLen16 format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameWithLen16.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameWithLen16 packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen16.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen16.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen16.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen16.HEADER_SIZE, buffer.length - TinyFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen16NoCrc Frame Format
// =============================================================================

export enum TinyFrameWithLen16NoCrcParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * TinyFrameWithLen16NoCrc - Frame format parser and encoder
 * 
 * Format: [START_BYTE=0x75] [MSG_ID] [LEN16] [MSG...]
 */
export class TinyFrameWithLen16NoCrc {
    static readonly START_BYTE = 0x75;
    static readonly HEADER_SIZE = 4;
    static readonly FOOTER_SIZE = 0;
    static readonly OVERHEAD = 4;
    static readonly LENGTH_BYTES = 2;

    private state: TinyFrameWithLen16NoCrcParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private length_lo: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new TinyFrameWithLen16NoCrc parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen16NoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 3) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = TinyFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with TinyFrameWithLen16NoCrc format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(TinyFrameWithLen16NoCrc.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    /**
     * Validate a complete TinyFrameWithLen16NoCrc packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen16NoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithSysComp Frame Format
// =============================================================================

export enum BasicFrameWithSysCompParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_PAYLOAD = 3
}

/**
 * BasicFrameWithSysComp - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x94] [MSG_ID] [MSG...] [CRC1] [CRC2]
 */
export class BasicFrameWithSysComp {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x94;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 5;

    private state: BasicFrameWithSysCompParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new BasicFrameWithSysComp parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithSysCompParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithSysComp.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithSysCompParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithSysComp.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithSysCompParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithSysComp.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithSysCompParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrameWithSysComp.OVERHEAD + msg_length;
                        this.state = BasicFrameWithSysCompParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithSysCompParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - BasicFrameWithSysComp.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithSysComp.HEADER_SIZE, this.packet_size - BasicFrameWithSysComp.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with BasicFrameWithSysComp format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(BasicFrameWithSysComp.START_BYTE1);
        output.push(BasicFrameWithSysComp.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete BasicFrameWithSysComp packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithSysComp.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithSysComp.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithSysComp.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithSysComp.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithSysComp.HEADER_SIZE, buffer.length - BasicFrameWithSysComp.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// UbxFrame Frame Format
// =============================================================================

export enum UbxFrameParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_LENGTH = 3,
    GETTING_PAYLOAD = 4
}

/**
 * UbxFrame - Frame format parser and encoder
 * 
 * Format: [SYNC1=0xB5] [SYNC2=0x62] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class UbxFrame {
    static readonly START_BYTE1 = 0xB5;
    static readonly START_BYTE2 = 0x62;
    static readonly HEADER_SIZE = 5;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 7;
    static readonly LENGTH_BYTES = 1;

    private state: UbxFrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new UbxFrame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case UbxFrameParserState.LOOKING_FOR_START1:
                if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                }
                break;

            case UbxFrameParserState.LOOKING_FOR_START2:
                if (byte === UbxFrame.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = UbxFrameParserState.GETTING_MSG_ID;
                } else if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                } else {
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case UbxFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = UbxFrameParserState.GETTING_LENGTH;
                break;

            case UbxFrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = UbxFrame.OVERHEAD + this.msg_length;
                this.state = UbxFrameParserState.GETTING_PAYLOAD;
                break;

            case UbxFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - UbxFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(UbxFrame.HEADER_SIZE, this.packet_size - UbxFrame.FOOTER_SIZE));
                    }
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with UbxFrame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(UbxFrame.START_BYTE1);
        output.push(UbxFrame.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete UbxFrame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < UbxFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== UbxFrame.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== UbxFrame.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - UbxFrame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, UbxFrame.HEADER_SIZE, buffer.length - UbxFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MavlinkV1Frame Frame Format
// =============================================================================

export enum MavlinkV1FrameParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * MavlinkV1Frame - Frame format parser and encoder
 * 
 * Format: [STX=0xFE] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class MavlinkV1Frame {
    static readonly START_BYTE = 0xFE;
    static readonly HEADER_SIZE = 3;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 5;
    static readonly LENGTH_BYTES = 1;

    private state: MavlinkV1FrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MavlinkV1Frame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MavlinkV1FrameParserState.LOOKING_FOR_START:
                if (byte === MavlinkV1Frame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = MavlinkV1FrameParserState.GETTING_MSG_ID;
                }
                break;

            case MavlinkV1FrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MavlinkV1FrameParserState.GETTING_LENGTH;
                break;

            case MavlinkV1FrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MavlinkV1Frame.OVERHEAD + this.msg_length;
                this.state = MavlinkV1FrameParserState.GETTING_PAYLOAD;
                break;

            case MavlinkV1FrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - MavlinkV1Frame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MavlinkV1Frame.HEADER_SIZE, this.packet_size - MavlinkV1Frame.FOOTER_SIZE));
                    }
                    this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MavlinkV1Frame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(MavlinkV1Frame.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MavlinkV1Frame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MavlinkV1Frame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== MavlinkV1Frame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - MavlinkV1Frame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MavlinkV1Frame.HEADER_SIZE, buffer.length - MavlinkV1Frame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MavlinkV2Frame Frame Format
// =============================================================================

export enum MavlinkV2FrameParserState {
    LOOKING_FOR_START = 0,
    GETTING_MSG_ID = 1,
    GETTING_LENGTH = 2,
    GETTING_PAYLOAD = 3
}

/**
 * MavlinkV2Frame - Frame format parser and encoder
 * 
 * Format: [STX=0xFD] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
 */
export class MavlinkV2Frame {
    static readonly START_BYTE = 0xFD;
    static readonly HEADER_SIZE = 5;
    static readonly FOOTER_SIZE = 2;
    static readonly OVERHEAD = 7;
    static readonly LENGTH_BYTES = 1;

    private state: MavlinkV2FrameParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private msg_length: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new MavlinkV2Frame parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MavlinkV2FrameParserState.LOOKING_FOR_START:
                if (byte === MavlinkV2Frame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = MavlinkV2FrameParserState.GETTING_MSG_ID;
                }
                break;

            case MavlinkV2FrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MavlinkV2FrameParserState.GETTING_LENGTH;
                break;

            case MavlinkV2FrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MavlinkV2Frame.OVERHEAD + this.msg_length;
                this.state = MavlinkV2FrameParserState.GETTING_PAYLOAD;
                break;

            case MavlinkV2FrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - MavlinkV2Frame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MavlinkV2Frame.HEADER_SIZE, this.packet_size - MavlinkV2Frame.FOOTER_SIZE));
                    }
                    this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with MavlinkV2Frame format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(MavlinkV2Frame.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete MavlinkV2Frame packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < MavlinkV2Frame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== MavlinkV2Frame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - MavlinkV2Frame.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MavlinkV2Frame.HEADER_SIZE, buffer.length - MavlinkV2Frame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// FrameFormatConfig Frame Format
// =============================================================================

export enum FrameFormatConfigParserState {
    LOOKING_FOR_START1 = 0,
    LOOKING_FOR_START2 = 1,
    GETTING_MSG_ID = 2,
    GETTING_PAYLOAD = 3
}

/**
 * FrameFormatConfig - Frame format parser and encoder
 * 
 * Format: [START_BYTE1=0x90] [START_BYTE2=0x91] [MSG_ID] [MSG...] [CRC1] [CRC2]
 */
export class FrameFormatConfig {
    static readonly START_BYTE1 = 0x90;
    static readonly START_BYTE2 = 0x91;
    static readonly HEADER_SIZE = 2;
    static readonly FOOTER_SIZE = 1;
    static readonly OVERHEAD = 3;

    private state: FrameFormatConfigParserState;
    private buffer: number[];
    private packet_size: number;
    private msg_id: number;
    private get_msg_length?: (msg_id: number) => number | undefined;

    /**
     * Create a new FrameFormatConfig parser
     * @param get_msg_length Callback to get message length from msg_id (required for non-length frames)
     */
    constructor(get_msg_length?: (msg_id: number) => number | undefined) {
        this.get_msg_length = get_msg_length;
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /** Reset parser state */
    reset(): void {
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    /**
     * Parse a single byte
     * @param byte The byte to parse
     * @returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    parse_byte(byte: number): FrameMsgInfo {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case FrameFormatConfigParserState.LOOKING_FOR_START1:
                if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                }
                break;

            case FrameFormatConfigParserState.LOOKING_FOR_START2:
                if (byte === FrameFormatConfig.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = FrameFormatConfigParserState.GETTING_MSG_ID;
                } else if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = FrameFormatConfig.OVERHEAD + msg_length;
                        this.state = FrameFormatConfigParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Validate checksum
                    const msg_length = this.packet_size - FrameFormatConfig.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(FrameFormatConfig.HEADER_SIZE, this.packet_size - FrameFormatConfig.FOOTER_SIZE));
                    }
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    /**
     * Encode a message with FrameFormatConfig format
     * @param msg_id Message ID
     * @param msg Message data
     * @returns Encoded frame as Uint8Array
     */
    static encode(msg_id: number, msg: Uint8Array | number[]): Uint8Array {
        const output: number[] = [];
        output.push(FrameFormatConfig.START_BYTE1);
        output.push(FrameFormatConfig.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    /**
     * Validate a complete FrameFormatConfig packet in a buffer
     * @param buffer Buffer containing the complete packet
     * @returns FrameMsgInfo with valid=true if packet is valid
     */
    static validate_packet(buffer: Uint8Array | number[]): FrameMsgInfo {
        const result = createFrameMsgInfo();

        if (buffer.length < FrameFormatConfig.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== FrameFormatConfig.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== FrameFormatConfig.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - FrameFormatConfig.OVERHEAD;

        // Validate checksum
        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, FrameFormatConfig.HEADER_SIZE, buffer.length - FrameFormatConfig.FOOTER_SIZE));
        }

        return result;
    }
}


