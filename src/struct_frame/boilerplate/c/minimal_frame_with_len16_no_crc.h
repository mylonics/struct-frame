/* Automatically generated frame parser */
/* Generated by 0.0.1 at Wed Dec  3 17:57:16 2025. */

#pragma once

#include "frame_base.h"

/*===========================================================================
 * MinimalFrameWithLen16NoCrc Frame Format
 *===========================================================================*/

/* MinimalFrameWithLen16NoCrc constants */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE    3  /* msg_id + length(2) */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD       (MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE)

/* MinimalFrameWithLen16NoCrc parser states */
typedef enum minimal_frame_with_len16_no_crc_parser_state {
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH = 1,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD = 2
} minimal_frame_with_len16_no_crc_parser_state_t;

/* MinimalFrameWithLen16NoCrc parser state structure */
typedef struct minimal_frame_with_len16_no_crc_parser {
    minimal_frame_with_len16_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_with_len16_no_crc_parser_t;

/* MinimalFrameWithLen16NoCrc encode buffer structure */
typedef struct minimal_frame_with_len16_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_with_len16_no_crc_encode_buffer_t;

/**
 * Initialize a MinimalFrameWithLen16NoCrc parser
 */
static inline void minimal_frame_with_len16_no_crc_parser_init(minimal_frame_with_len16_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrameWithLen16NoCrc parser state
 */
static inline void minimal_frame_with_len16_no_crc_parser_reset(minimal_frame_with_len16_no_crc_parser_t* parser) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MinimalFrameWithLen16NoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_with_len16_no_crc_parse_byte(minimal_frame_with_len16_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH;
            break;

        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 2) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD;
                } else {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
                }
            }
            break;

        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;
    buffer[1] = (uint8_t)(msg_size & 0xFF);
    buffer[2] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen16NoCrc packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[0];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}

