/* Automatically generated frame parser header */
/* Generated by 0.0.1 at Sun Nov 30 16:50:10 2025. */

#pragma once

#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <string.h>

/* Frame format type enumeration */
typedef enum FrameFormatType {
    FRAME_FORMAT_MINIMAL_FRAME = 0,
    FRAME_FORMAT_BASIC_FRAME = 1,
    FRAME_FORMAT_BASIC_FRAME_NO_CRC = 2,
    FRAME_FORMAT_TINY_FRAME = 3,
    FRAME_FORMAT_TINY_FRAME_NO_CRC = 4,
    FRAME_FORMAT_MINIMAL_FRAME_WITH_LEN = 5,
    FRAME_FORMAT_MINIMAL_FRAME_WITH_LEN_NO_CRC = 6,
    FRAME_FORMAT_BASIC_FRAME_WITH_LEN = 7,
    FRAME_FORMAT_BASIC_FRAME_WITH_LEN_NO_CRC = 8,
    FRAME_FORMAT_TINY_FRAME_WITH_LEN = 9,
    FRAME_FORMAT_TINY_FRAME_WITH_LEN_NO_CRC = 10,
    FRAME_FORMAT_MINIMAL_FRAME_WITH_LEN16 = 11,
    FRAME_FORMAT_MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12,
    FRAME_FORMAT_BASIC_FRAME_WITH_LEN16 = 13,
    FRAME_FORMAT_BASIC_FRAME_WITH_LEN16_NO_CRC = 14,
    FRAME_FORMAT_TINY_FRAME_WITH_LEN16 = 15,
    FRAME_FORMAT_TINY_FRAME_WITH_LEN16_NO_CRC = 16,
    FRAME_FORMAT_BASIC_FRAME_WITH_SYS_COMP = 17,
    FRAME_FORMAT_UBX_FRAME = 18,
    FRAME_FORMAT_MAVLINK_V1_FRAME = 19,
    FRAME_FORMAT_MAVLINK_V2_FRAME = 20,
    FRAME_FORMAT_FRAME_FORMAT_CONFIG = 21,
} FrameFormatType;

/*===========================================================================
 * Checksum Calculation
 *===========================================================================*/

typedef struct frame_checksum {
    uint8_t byte1;
    uint8_t byte2;
} frame_checksum_t;

/**
 * Calculate Fletcher-16 checksum over the given data
 */
static inline frame_checksum_t frame_fletcher_checksum(const uint8_t* data, size_t length) {
    frame_checksum_t ck = {0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = (uint8_t)(ck.byte1 + data[i]);
        ck.byte2 = (uint8_t)(ck.byte2 + ck.byte1);
    }
    return ck;
}

/* Parse result */
typedef struct frame_msg_info {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
} frame_msg_info_t;

/*===========================================================================
 * MinimalFrame Frame Format
 *===========================================================================*/

/* MinimalFrame constants */
#define MINIMAL_FRAME_HEADER_SIZE    1  /* msg_id */
#define MINIMAL_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define MINIMAL_FRAME_OVERHEAD       (MINIMAL_FRAME_HEADER_SIZE + MINIMAL_FRAME_FOOTER_SIZE)

/* MinimalFrame parser states */
typedef enum minimal_frame_parser_state {
    MINIMAL_FRAME_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_GETTING_PAYLOAD = 1
} minimal_frame_parser_state_t;

/* MinimalFrame parser state structure */
typedef struct minimal_frame_parser {
    minimal_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_parser_t;

/* MinimalFrame encode buffer structure */
typedef struct minimal_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_encode_buffer_t;

/**
 * Initialize a MinimalFrame parser
 */
static inline void minimal_frame_parser_init(minimal_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrame parser state
 */
static inline void minimal_frame_parser_reset(minimal_frame_parser_t* parser) {
    parser->state = MINIMAL_FRAME_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with MinimalFrame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_parse_byte(minimal_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = MINIMAL_FRAME_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = MINIMAL_FRAME_GETTING_PAYLOAD;
                    } else {
                        parser->state = MINIMAL_FRAME_GETTING_MSG_ID;
                    }
                } else {
                    parser->state = MINIMAL_FRAME_GETTING_MSG_ID;
                }
            }
            break;

        case MINIMAL_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - MINIMAL_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 0, msg_length + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + MINIMAL_FRAME_HEADER_SIZE;
                }
                parser->state = MINIMAL_FRAME_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_size + 1);
    buffer[MINIMAL_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrame packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * BasicFrame Frame Format
 *===========================================================================*/

/* BasicFrame constants */
#define BASIC_FRAME_START_BYTE1    0x90
#define BASIC_FRAME_START_BYTE2    0x91
#define BASIC_FRAME_HEADER_SIZE    3  /* start_byte1 + start_byte2 + msg_id */
#define BASIC_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define BASIC_FRAME_OVERHEAD       (BASIC_FRAME_HEADER_SIZE + BASIC_FRAME_FOOTER_SIZE)

/* BasicFrame parser states */
typedef enum basic_frame_parser_state {
    BASIC_FRAME_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_GETTING_MSG_ID = 2,
    BASIC_FRAME_GETTING_PAYLOAD = 3
} basic_frame_parser_state_t;

/* BasicFrame parser state structure */
typedef struct basic_frame_parser {
    basic_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_parser_t;

/* BasicFrame encode buffer structure */
typedef struct basic_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_encode_buffer_t;

/**
 * Initialize a BasicFrame parser
 */
static inline void basic_frame_parser_init(basic_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrame parser state
 */
static inline void basic_frame_parser_reset(basic_frame_parser_t* parser) {
    parser->state = BASIC_FRAME_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with BasicFrame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_parse_byte(basic_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = BASIC_FRAME_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = BASIC_FRAME_GETTING_PAYLOAD;
                    } else {
                        parser->state = BASIC_FRAME_LOOKING_FOR_START1;
                    }
                } else {
                    parser->state = BASIC_FRAME_LOOKING_FOR_START1;
                }
            }
            break;

        case BASIC_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - BASIC_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + BASIC_FRAME_HEADER_SIZE;
                }
                parser->state = BASIC_FRAME_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_START_BYTE1;
    buffer[1] = BASIC_FRAME_START_BYTE2;
    buffer[2] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[BASIC_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrame packet in a buffer
 */
static inline frame_msg_info_t basic_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * BasicFrameNoCrc Frame Format
 *===========================================================================*/

/* BasicFrameNoCrc constants */
#define BASIC_FRAME_NO_CRC_START_BYTE1    0x90
#define BASIC_FRAME_NO_CRC_START_BYTE2    0x95
#define BASIC_FRAME_NO_CRC_HEADER_SIZE    3  /* start_byte1 + start_byte2 + msg_id */
#define BASIC_FRAME_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define BASIC_FRAME_NO_CRC_OVERHEAD       (BASIC_FRAME_NO_CRC_HEADER_SIZE + BASIC_FRAME_NO_CRC_FOOTER_SIZE)

/* BasicFrameNoCrc parser states */
typedef enum basic_frame_no_crc_parser_state {
    BASIC_FRAME_NO_CRC_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_NO_CRC_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_NO_CRC_GETTING_MSG_ID = 2,
    BASIC_FRAME_NO_CRC_GETTING_PAYLOAD = 3
} basic_frame_no_crc_parser_state_t;

/* BasicFrameNoCrc parser state structure */
typedef struct basic_frame_no_crc_parser {
    basic_frame_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_no_crc_parser_t;

/* BasicFrameNoCrc encode buffer structure */
typedef struct basic_frame_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_no_crc_encode_buffer_t;

/**
 * Initialize a BasicFrameNoCrc parser
 */
static inline void basic_frame_no_crc_parser_init(basic_frame_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameNoCrc parser state
 */
static inline void basic_frame_no_crc_parser_reset(basic_frame_no_crc_parser_t* parser) {
    parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with BasicFrameNoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_no_crc_parse_byte(basic_frame_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_NO_CRC_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_NO_CRC_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_NO_CRC_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_NO_CRC_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = BASIC_FRAME_NO_CRC_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = BASIC_FRAME_NO_CRC_GETTING_PAYLOAD;
                    } else {
                        parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
                    }
                } else {
                    parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
                }
            }
            break;

        case BASIC_FRAME_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - BASIC_FRAME_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + BASIC_FRAME_NO_CRC_HEADER_SIZE;
                parser->state = BASIC_FRAME_NO_CRC_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameNoCrc packet in a buffer
 */
static inline frame_msg_info_t basic_frame_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_NO_CRC_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_NO_CRC_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * TinyFrame Frame Format
 *===========================================================================*/

/* TinyFrame constants */
#define TINY_FRAME_START_BYTE    0x70
#define TINY_FRAME_HEADER_SIZE    2  /* start_byte + msg_id */
#define TINY_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define TINY_FRAME_OVERHEAD       (TINY_FRAME_HEADER_SIZE + TINY_FRAME_FOOTER_SIZE)

/* TinyFrame parser states */
typedef enum tiny_frame_parser_state {
    TINY_FRAME_LOOKING_FOR_START = 0,
    TINY_FRAME_GETTING_MSG_ID = 1,
    TINY_FRAME_GETTING_PAYLOAD = 2
} tiny_frame_parser_state_t;

/* TinyFrame parser state structure */
typedef struct tiny_frame_parser {
    tiny_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_parser_t;

/* TinyFrame encode buffer structure */
typedef struct tiny_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_encode_buffer_t;

/**
 * Initialize a TinyFrame parser
 */
static inline void tiny_frame_parser_init(tiny_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrame parser state
 */
static inline void tiny_frame_parser_reset(tiny_frame_parser_t* parser) {
    parser->state = TINY_FRAME_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with TinyFrame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_parse_byte(tiny_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_LOOKING_FOR_START:
            if (byte == TINY_FRAME_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = TINY_FRAME_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = TINY_FRAME_GETTING_PAYLOAD;
                    } else {
                        parser->state = TINY_FRAME_LOOKING_FOR_START;
                    }
                } else {
                    parser->state = TINY_FRAME_LOOKING_FOR_START;
                }
            }
            break;

        case TINY_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - TINY_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 1, msg_length + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + TINY_FRAME_HEADER_SIZE;
                }
                parser->state = TINY_FRAME_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_START_BYTE;
    buffer[1] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_size + 1);
    buffer[TINY_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrame packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + TINY_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * TinyFrameNoCrc Frame Format
 *===========================================================================*/

/* TinyFrameNoCrc constants */
#define TINY_FRAME_NO_CRC_START_BYTE    0x72
#define TINY_FRAME_NO_CRC_HEADER_SIZE    2  /* start_byte + msg_id */
#define TINY_FRAME_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define TINY_FRAME_NO_CRC_OVERHEAD       (TINY_FRAME_NO_CRC_HEADER_SIZE + TINY_FRAME_NO_CRC_FOOTER_SIZE)

/* TinyFrameNoCrc parser states */
typedef enum tiny_frame_no_crc_parser_state {
    TINY_FRAME_NO_CRC_LOOKING_FOR_START = 0,
    TINY_FRAME_NO_CRC_GETTING_MSG_ID = 1,
    TINY_FRAME_NO_CRC_GETTING_PAYLOAD = 2
} tiny_frame_no_crc_parser_state_t;

/* TinyFrameNoCrc parser state structure */
typedef struct tiny_frame_no_crc_parser {
    tiny_frame_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_no_crc_parser_t;

/* TinyFrameNoCrc encode buffer structure */
typedef struct tiny_frame_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_no_crc_encode_buffer_t;

/**
 * Initialize a TinyFrameNoCrc parser
 */
static inline void tiny_frame_no_crc_parser_init(tiny_frame_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_NO_CRC_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrameNoCrc parser state
 */
static inline void tiny_frame_no_crc_parser_reset(tiny_frame_no_crc_parser_t* parser) {
    parser->state = TINY_FRAME_NO_CRC_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with TinyFrameNoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_no_crc_parse_byte(tiny_frame_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_NO_CRC_LOOKING_FOR_START:
            if (byte == TINY_FRAME_NO_CRC_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_NO_CRC_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = TINY_FRAME_NO_CRC_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = TINY_FRAME_NO_CRC_GETTING_PAYLOAD;
                    } else {
                        parser->state = TINY_FRAME_NO_CRC_LOOKING_FOR_START;
                    }
                } else {
                    parser->state = TINY_FRAME_NO_CRC_LOOKING_FOR_START;
                }
            }
            break;

        case TINY_FRAME_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - TINY_FRAME_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + TINY_FRAME_NO_CRC_HEADER_SIZE;
                parser->state = TINY_FRAME_NO_CRC_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrameNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_NO_CRC_START_BYTE;
    buffer[1] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameNoCrc packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_NO_CRC_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + TINY_FRAME_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * MinimalFrameWithLen Frame Format
 *===========================================================================*/

/* MinimalFrameWithLen constants */
#define MINIMAL_FRAME_WITH_LEN_HEADER_SIZE    2  /* msg_id + length(1) */
#define MINIMAL_FRAME_WITH_LEN_FOOTER_SIZE    2  /* crc(2 bytes) */
#define MINIMAL_FRAME_WITH_LEN_OVERHEAD       (MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN_FOOTER_SIZE)

/* MinimalFrameWithLen parser states */
typedef enum minimal_frame_with_len_parser_state {
    MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_WITH_LEN_GETTING_LENGTH = 1,
    MINIMAL_FRAME_WITH_LEN_GETTING_PAYLOAD = 2
} minimal_frame_with_len_parser_state_t;

/* MinimalFrameWithLen parser state structure */
typedef struct minimal_frame_with_len_parser {
    minimal_frame_with_len_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_with_len_parser_t;

/* MinimalFrameWithLen encode buffer structure */
typedef struct minimal_frame_with_len_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_with_len_encode_buffer_t;

/**
 * Initialize a MinimalFrameWithLen parser
 */
static inline void minimal_frame_with_len_parser_init(minimal_frame_with_len_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrameWithLen parser state
 */
static inline void minimal_frame_with_len_parser_reset(minimal_frame_with_len_parser_t* parser) {
    parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MinimalFrameWithLen format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_with_len_parse_byte(minimal_frame_with_len_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_LENGTH;
            break;

        case MINIMAL_FRAME_WITH_LEN_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = MINIMAL_FRAME_WITH_LEN_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_PAYLOAD;
            } else {
                parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID;
            }
            break;

        case MINIMAL_FRAME_WITH_LEN_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - MINIMAL_FRAME_WITH_LEN_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 0, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE;
                }
                parser->state = MINIMAL_FRAME_WITH_LEN_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;
    buffer[1] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_size + 1 + 1);
    buffer[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_WITH_LEN_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * MinimalFrameWithLenNoCrc Frame Format
 *===========================================================================*/

/* MinimalFrameWithLenNoCrc constants */
#define MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE    2  /* msg_id + length(1) */
#define MINIMAL_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD       (MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE)

/* MinimalFrameWithLenNoCrc parser states */
typedef enum minimal_frame_with_len_no_crc_parser_state {
    MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH = 1,
    MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD = 2
} minimal_frame_with_len_no_crc_parser_state_t;

/* MinimalFrameWithLenNoCrc parser state structure */
typedef struct minimal_frame_with_len_no_crc_parser {
    minimal_frame_with_len_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_with_len_no_crc_parser_t;

/* MinimalFrameWithLenNoCrc encode buffer structure */
typedef struct minimal_frame_with_len_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_with_len_no_crc_encode_buffer_t;

/**
 * Initialize a MinimalFrameWithLenNoCrc parser
 */
static inline void minimal_frame_with_len_no_crc_parser_init(minimal_frame_with_len_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrameWithLenNoCrc parser state
 */
static inline void minimal_frame_with_len_no_crc_parser_reset(minimal_frame_with_len_no_crc_parser_t* parser) {
    parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MinimalFrameWithLenNoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_with_len_no_crc_parse_byte(minimal_frame_with_len_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH;
            break;

        case MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD;
            } else {
                parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
            }
            break;

        case MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                parser->state = MINIMAL_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;
    buffer[1] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLenNoCrc packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[0];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * BasicFrameWithLen Frame Format
 *===========================================================================*/

/* BasicFrameWithLen constants */
#define BASIC_FRAME_WITH_LEN_START_BYTE1    0x90
#define BASIC_FRAME_WITH_LEN_START_BYTE2    0x92
#define BASIC_FRAME_WITH_LEN_HEADER_SIZE    4  /* start_byte1 + start_byte2 + msg_id + length(1) */
#define BASIC_FRAME_WITH_LEN_FOOTER_SIZE    2  /* crc(2 bytes) */
#define BASIC_FRAME_WITH_LEN_OVERHEAD       (BASIC_FRAME_WITH_LEN_HEADER_SIZE + BASIC_FRAME_WITH_LEN_FOOTER_SIZE)

/* BasicFrameWithLen parser states */
typedef enum basic_frame_with_len_parser_state {
    BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_WITH_LEN_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_WITH_LEN_GETTING_MSG_ID = 2,
    BASIC_FRAME_WITH_LEN_GETTING_LENGTH = 3,
    BASIC_FRAME_WITH_LEN_GETTING_PAYLOAD = 4
} basic_frame_with_len_parser_state_t;

/* BasicFrameWithLen parser state structure */
typedef struct basic_frame_with_len_parser {
    basic_frame_with_len_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_with_len_parser_t;

/* BasicFrameWithLen encode buffer structure */
typedef struct basic_frame_with_len_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_with_len_encode_buffer_t;

/**
 * Initialize a BasicFrameWithLen parser
 */
static inline void basic_frame_with_len_parser_init(basic_frame_with_len_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameWithLen parser state
 */
static inline void basic_frame_with_len_parser_reset(basic_frame_with_len_parser_t* parser) {
    parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with BasicFrameWithLen format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_with_len_parse_byte(basic_frame_with_len_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_WITH_LEN_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_WITH_LEN_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_WITH_LEN_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_WITH_LEN_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_WITH_LEN_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = BASIC_FRAME_WITH_LEN_GETTING_LENGTH;
            break;

        case BASIC_FRAME_WITH_LEN_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = BASIC_FRAME_WITH_LEN_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = BASIC_FRAME_WITH_LEN_GETTING_PAYLOAD;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - BASIC_FRAME_WITH_LEN_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + BASIC_FRAME_WITH_LEN_HEADER_SIZE;
                }
                parser->state = BASIC_FRAME_WITH_LEN_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_WITH_LEN_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1 + 1);
    buffer[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen packet in a buffer
 */
static inline frame_msg_info_t basic_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_WITH_LEN_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_WITH_LEN_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_WITH_LEN_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_WITH_LEN_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * BasicFrameWithLenNoCrc Frame Format
 *===========================================================================*/

/* BasicFrameWithLenNoCrc constants */
#define BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1    0x90
#define BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2    0x96
#define BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE    4  /* start_byte1 + start_byte2 + msg_id + length(1) */
#define BASIC_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD       (BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + BASIC_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE)

/* BasicFrameWithLenNoCrc parser states */
typedef enum basic_frame_with_len_no_crc_parser_state {
    BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID = 2,
    BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH = 3,
    BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD = 4
} basic_frame_with_len_no_crc_parser_state_t;

/* BasicFrameWithLenNoCrc parser state structure */
typedef struct basic_frame_with_len_no_crc_parser {
    basic_frame_with_len_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_with_len_no_crc_parser_t;

/* BasicFrameWithLenNoCrc encode buffer structure */
typedef struct basic_frame_with_len_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_with_len_no_crc_encode_buffer_t;

/**
 * Initialize a BasicFrameWithLenNoCrc parser
 */
static inline void basic_frame_with_len_no_crc_parser_init(basic_frame_with_len_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameWithLenNoCrc parser state
 */
static inline void basic_frame_with_len_no_crc_parser_reset(basic_frame_with_len_no_crc_parser_t* parser) {
    parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with BasicFrameWithLenNoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_with_len_no_crc_parse_byte(basic_frame_with_len_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH;
            break;

        case BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                parser->state = BASIC_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameWithLenNoCrc packet in a buffer
 */
static inline frame_msg_info_t basic_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * TinyFrameWithLen Frame Format
 *===========================================================================*/

/* TinyFrameWithLen constants */
#define TINY_FRAME_WITH_LEN_START_BYTE    0x71
#define TINY_FRAME_WITH_LEN_HEADER_SIZE    3  /* start_byte + msg_id + length(1) */
#define TINY_FRAME_WITH_LEN_FOOTER_SIZE    2  /* crc(2 bytes) */
#define TINY_FRAME_WITH_LEN_OVERHEAD       (TINY_FRAME_WITH_LEN_HEADER_SIZE + TINY_FRAME_WITH_LEN_FOOTER_SIZE)

/* TinyFrameWithLen parser states */
typedef enum tiny_frame_with_len_parser_state {
    TINY_FRAME_WITH_LEN_LOOKING_FOR_START = 0,
    TINY_FRAME_WITH_LEN_GETTING_MSG_ID = 1,
    TINY_FRAME_WITH_LEN_GETTING_LENGTH = 2,
    TINY_FRAME_WITH_LEN_GETTING_PAYLOAD = 3
} tiny_frame_with_len_parser_state_t;

/* TinyFrameWithLen parser state structure */
typedef struct tiny_frame_with_len_parser {
    tiny_frame_with_len_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_with_len_parser_t;

/* TinyFrameWithLen encode buffer structure */
typedef struct tiny_frame_with_len_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_with_len_encode_buffer_t;

/**
 * Initialize a TinyFrameWithLen parser
 */
static inline void tiny_frame_with_len_parser_init(tiny_frame_with_len_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_WITH_LEN_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrameWithLen parser state
 */
static inline void tiny_frame_with_len_parser_reset(tiny_frame_with_len_parser_t* parser) {
    parser->state = TINY_FRAME_WITH_LEN_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with TinyFrameWithLen format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_with_len_parse_byte(tiny_frame_with_len_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_WITH_LEN_LOOKING_FOR_START:
            if (byte == TINY_FRAME_WITH_LEN_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_WITH_LEN_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_WITH_LEN_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = TINY_FRAME_WITH_LEN_GETTING_LENGTH;
            break;

        case TINY_FRAME_WITH_LEN_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = TINY_FRAME_WITH_LEN_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = TINY_FRAME_WITH_LEN_GETTING_PAYLOAD;
            } else {
                parser->state = TINY_FRAME_WITH_LEN_LOOKING_FOR_START;
            }
            break;

        case TINY_FRAME_WITH_LEN_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - TINY_FRAME_WITH_LEN_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 1, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + TINY_FRAME_WITH_LEN_HEADER_SIZE;
                }
                parser->state = TINY_FRAME_WITH_LEN_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_WITH_LEN_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_WITH_LEN_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_WITH_LEN_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_WITH_LEN_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + TINY_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * TinyFrameWithLenNoCrc Frame Format
 *===========================================================================*/

/* TinyFrameWithLenNoCrc constants */
#define TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE    0x73
#define TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE    3  /* start_byte + msg_id + length(1) */
#define TINY_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD       (TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + TINY_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE)

/* TinyFrameWithLenNoCrc parser states */
typedef enum tiny_frame_with_len_no_crc_parser_state {
    TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START = 0,
    TINY_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID = 1,
    TINY_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH = 2,
    TINY_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD = 3
} tiny_frame_with_len_no_crc_parser_state_t;

/* TinyFrameWithLenNoCrc parser state structure */
typedef struct tiny_frame_with_len_no_crc_parser {
    tiny_frame_with_len_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_with_len_no_crc_parser_t;

/* TinyFrameWithLenNoCrc encode buffer structure */
typedef struct tiny_frame_with_len_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_with_len_no_crc_encode_buffer_t;

/**
 * Initialize a TinyFrameWithLenNoCrc parser
 */
static inline void tiny_frame_with_len_no_crc_parser_init(tiny_frame_with_len_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrameWithLenNoCrc parser state
 */
static inline void tiny_frame_with_len_no_crc_parser_reset(tiny_frame_with_len_no_crc_parser_t* parser) {
    parser->state = TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with TinyFrameWithLenNoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_with_len_no_crc_parse_byte(tiny_frame_with_len_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START:
            if (byte == TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_WITH_LEN_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = TINY_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH;
            break;

        case TINY_FRAME_WITH_LEN_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = TINY_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD;
            } else {
                parser->state = TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START;
            }
            break;

        case TINY_FRAME_WITH_LEN_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                parser->state = TINY_FRAME_WITH_LEN_NO_CRC_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameWithLenNoCrc packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * MinimalFrameWithLen16 Frame Format
 *===========================================================================*/

/* MinimalFrameWithLen16 constants */
#define MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE    3  /* msg_id + length(2) */
#define MINIMAL_FRAME_WITH_LEN16_FOOTER_SIZE    2  /* crc(2 bytes) */
#define MINIMAL_FRAME_WITH_LEN16_OVERHEAD       (MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN16_FOOTER_SIZE)

/* MinimalFrameWithLen16 parser states */
typedef enum minimal_frame_with_len16_parser_state {
    MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_WITH_LEN16_GETTING_LENGTH = 1,
    MINIMAL_FRAME_WITH_LEN16_GETTING_PAYLOAD = 2
} minimal_frame_with_len16_parser_state_t;

/* MinimalFrameWithLen16 parser state structure */
typedef struct minimal_frame_with_len16_parser {
    minimal_frame_with_len16_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_with_len16_parser_t;

/* MinimalFrameWithLen16 encode buffer structure */
typedef struct minimal_frame_with_len16_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_with_len16_encode_buffer_t;

/**
 * Initialize a MinimalFrameWithLen16 parser
 */
static inline void minimal_frame_with_len16_parser_init(minimal_frame_with_len16_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrameWithLen16 parser state
 */
static inline void minimal_frame_with_len16_parser_reset(minimal_frame_with_len16_parser_t* parser) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MinimalFrameWithLen16 format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_with_len16_parse_byte(minimal_frame_with_len16_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_LENGTH;
            break;

        case MINIMAL_FRAME_WITH_LEN16_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 2) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = MINIMAL_FRAME_WITH_LEN16_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_PAYLOAD;
                } else {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID;
                }
            }
            break;

        case MINIMAL_FRAME_WITH_LEN16_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - MINIMAL_FRAME_WITH_LEN16_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 0, msg_length + 1 + 2);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE;
                }
                parser->state = MINIMAL_FRAME_WITH_LEN16_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;
    buffer[1] = (uint8_t)(msg_size & 0xFF);
    buffer[2] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_size + 1 + 2);
    buffer[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen16 packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_WITH_LEN16_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN16_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 0, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * MinimalFrameWithLen16NoCrc Frame Format
 *===========================================================================*/

/* MinimalFrameWithLen16NoCrc constants */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE    3  /* msg_id + length(2) */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD       (MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE)

/* MinimalFrameWithLen16NoCrc parser states */
typedef enum minimal_frame_with_len16_no_crc_parser_state {
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID = 0,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH = 1,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD = 2
} minimal_frame_with_len16_no_crc_parser_state_t;

/* MinimalFrameWithLen16NoCrc parser state structure */
typedef struct minimal_frame_with_len16_no_crc_parser {
    minimal_frame_with_len16_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} minimal_frame_with_len16_no_crc_parser_t;

/* MinimalFrameWithLen16NoCrc encode buffer structure */
typedef struct minimal_frame_with_len16_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} minimal_frame_with_len16_no_crc_encode_buffer_t;

/**
 * Initialize a MinimalFrameWithLen16NoCrc parser
 */
static inline void minimal_frame_with_len16_no_crc_parser_init(minimal_frame_with_len16_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MinimalFrameWithLen16NoCrc parser state
 */
static inline void minimal_frame_with_len16_no_crc_parser_reset(minimal_frame_with_len16_no_crc_parser_t* parser) {
    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MinimalFrameWithLen16NoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t minimal_frame_with_len16_no_crc_parse_byte(minimal_frame_with_len16_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH;
            break;

        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 2) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD;
                } else {
                    parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
                }
            }
            break;

        case MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                parser->state = MINIMAL_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MinimalFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t minimal_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = msg_id;
    buffer[1] = (uint8_t)(msg_size & 0xFF);
    buffer[2] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen16NoCrc packet in a buffer
 */
static inline frame_msg_info_t minimal_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) {
        return result;
    }


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[0];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * BasicFrameWithLen16 Frame Format
 *===========================================================================*/

/* BasicFrameWithLen16 constants */
#define BASIC_FRAME_WITH_LEN16_START_BYTE1    0x90
#define BASIC_FRAME_WITH_LEN16_START_BYTE2    0x93
#define BASIC_FRAME_WITH_LEN16_HEADER_SIZE    5  /* start_byte1 + start_byte2 + msg_id + length(2) */
#define BASIC_FRAME_WITH_LEN16_FOOTER_SIZE    2  /* crc(2 bytes) */
#define BASIC_FRAME_WITH_LEN16_OVERHEAD       (BASIC_FRAME_WITH_LEN16_HEADER_SIZE + BASIC_FRAME_WITH_LEN16_FOOTER_SIZE)

/* BasicFrameWithLen16 parser states */
typedef enum basic_frame_with_len16_parser_state {
    BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_WITH_LEN16_GETTING_MSG_ID = 2,
    BASIC_FRAME_WITH_LEN16_GETTING_LENGTH = 3,
    BASIC_FRAME_WITH_LEN16_GETTING_PAYLOAD = 4
} basic_frame_with_len16_parser_state_t;

/* BasicFrameWithLen16 parser state structure */
typedef struct basic_frame_with_len16_parser {
    basic_frame_with_len16_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_with_len16_parser_t;

/* BasicFrameWithLen16 encode buffer structure */
typedef struct basic_frame_with_len16_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_with_len16_encode_buffer_t;

/**
 * Initialize a BasicFrameWithLen16 parser
 */
static inline void basic_frame_with_len16_parser_init(basic_frame_with_len16_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameWithLen16 parser state
 */
static inline void basic_frame_with_len16_parser_reset(basic_frame_with_len16_parser_t* parser) {
    parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with BasicFrameWithLen16 format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_with_len16_parse_byte(basic_frame_with_len16_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_WITH_LEN16_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN16_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = BASIC_FRAME_WITH_LEN16_GETTING_LENGTH;
            break;

        case BASIC_FRAME_WITH_LEN16_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 4) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = BASIC_FRAME_WITH_LEN16_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = BASIC_FRAME_WITH_LEN16_GETTING_PAYLOAD;
                } else {
                    parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1;
                }
            }
            break;

        case BASIC_FRAME_WITH_LEN16_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - BASIC_FRAME_WITH_LEN16_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1 + 2);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + BASIC_FRAME_WITH_LEN16_HEADER_SIZE;
                }
                parser->state = BASIC_FRAME_WITH_LEN16_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_WITH_LEN16_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN16_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = (uint8_t)(msg_size & 0xFF);
    buffer[4] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1 + 2);
    buffer[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen16 packet in a buffer
 */
static inline frame_msg_info_t basic_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_WITH_LEN16_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_WITH_LEN16_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_WITH_LEN16_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_WITH_LEN16_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * BasicFrameWithLen16NoCrc Frame Format
 *===========================================================================*/

/* BasicFrameWithLen16NoCrc constants */
#define BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1    0x90
#define BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2    0x97
#define BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE    5  /* start_byte1 + start_byte2 + msg_id + length(2) */
#define BASIC_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD       (BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + BASIC_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE)

/* BasicFrameWithLen16NoCrc parser states */
typedef enum basic_frame_with_len16_no_crc_parser_state {
    BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID = 2,
    BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH = 3,
    BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD = 4
} basic_frame_with_len16_no_crc_parser_state_t;

/* BasicFrameWithLen16NoCrc parser state structure */
typedef struct basic_frame_with_len16_no_crc_parser {
    basic_frame_with_len16_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_with_len16_no_crc_parser_t;

/* BasicFrameWithLen16NoCrc encode buffer structure */
typedef struct basic_frame_with_len16_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_with_len16_no_crc_encode_buffer_t;

/**
 * Initialize a BasicFrameWithLen16NoCrc parser
 */
static inline void basic_frame_with_len16_no_crc_parser_init(basic_frame_with_len16_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameWithLen16NoCrc parser state
 */
static inline void basic_frame_with_len16_no_crc_parser_reset(basic_frame_with_len16_no_crc_parser_t* parser) {
    parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with BasicFrameWithLen16NoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_with_len16_no_crc_parse_byte(basic_frame_with_len16_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH;
            break;

        case BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 4) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD;
                } else {
                    parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1;
                }
            }
            break;

        case BASIC_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                parser->state = BASIC_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = (uint8_t)(msg_size & 0xFF);
    buffer[4] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen16NoCrc packet in a buffer
 */
static inline frame_msg_info_t basic_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * TinyFrameWithLen16 Frame Format
 *===========================================================================*/

/* TinyFrameWithLen16 constants */
#define TINY_FRAME_WITH_LEN16_START_BYTE    0x74
#define TINY_FRAME_WITH_LEN16_HEADER_SIZE    4  /* start_byte + msg_id + length(2) */
#define TINY_FRAME_WITH_LEN16_FOOTER_SIZE    2  /* crc(2 bytes) */
#define TINY_FRAME_WITH_LEN16_OVERHEAD       (TINY_FRAME_WITH_LEN16_HEADER_SIZE + TINY_FRAME_WITH_LEN16_FOOTER_SIZE)

/* TinyFrameWithLen16 parser states */
typedef enum tiny_frame_with_len16_parser_state {
    TINY_FRAME_WITH_LEN16_LOOKING_FOR_START = 0,
    TINY_FRAME_WITH_LEN16_GETTING_MSG_ID = 1,
    TINY_FRAME_WITH_LEN16_GETTING_LENGTH = 2,
    TINY_FRAME_WITH_LEN16_GETTING_PAYLOAD = 3
} tiny_frame_with_len16_parser_state_t;

/* TinyFrameWithLen16 parser state structure */
typedef struct tiny_frame_with_len16_parser {
    tiny_frame_with_len16_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_with_len16_parser_t;

/* TinyFrameWithLen16 encode buffer structure */
typedef struct tiny_frame_with_len16_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_with_len16_encode_buffer_t;

/**
 * Initialize a TinyFrameWithLen16 parser
 */
static inline void tiny_frame_with_len16_parser_init(tiny_frame_with_len16_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_WITH_LEN16_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrameWithLen16 parser state
 */
static inline void tiny_frame_with_len16_parser_reset(tiny_frame_with_len16_parser_t* parser) {
    parser->state = TINY_FRAME_WITH_LEN16_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with TinyFrameWithLen16 format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_with_len16_parse_byte(tiny_frame_with_len16_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_WITH_LEN16_LOOKING_FOR_START:
            if (byte == TINY_FRAME_WITH_LEN16_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_WITH_LEN16_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_WITH_LEN16_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = TINY_FRAME_WITH_LEN16_GETTING_LENGTH;
            break;

        case TINY_FRAME_WITH_LEN16_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 3) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = TINY_FRAME_WITH_LEN16_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = TINY_FRAME_WITH_LEN16_GETTING_PAYLOAD;
                } else {
                    parser->state = TINY_FRAME_WITH_LEN16_LOOKING_FOR_START;
                }
            }
            break;

        case TINY_FRAME_WITH_LEN16_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - TINY_FRAME_WITH_LEN16_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 1, msg_length + 1 + 2);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE;
                }
                parser->state = TINY_FRAME_WITH_LEN16_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_WITH_LEN16_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)(msg_size & 0xFF);
    buffer[3] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_size + 1 + 2);
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen16 packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_WITH_LEN16_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_WITH_LEN16_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_WITH_LEN16_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * TinyFrameWithLen16NoCrc Frame Format
 *===========================================================================*/

/* TinyFrameWithLen16NoCrc constants */
#define TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE    0x75
#define TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE    4  /* start_byte + msg_id + length(2) */
#define TINY_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE    0  /* no footer */
#define TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD       (TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + TINY_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE)

/* TinyFrameWithLen16NoCrc parser states */
typedef enum tiny_frame_with_len16_no_crc_parser_state {
    TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START = 0,
    TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID = 1,
    TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH = 2,
    TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD = 3
} tiny_frame_with_len16_no_crc_parser_state_t;

/* TinyFrameWithLen16NoCrc parser state structure */
typedef struct tiny_frame_with_len16_no_crc_parser {
    tiny_frame_with_len16_no_crc_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    uint8_t length_lo;  /* Low byte for 16-bit length */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} tiny_frame_with_len16_no_crc_parser_t;

/* TinyFrameWithLen16NoCrc encode buffer structure */
typedef struct tiny_frame_with_len16_no_crc_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} tiny_frame_with_len16_no_crc_encode_buffer_t;

/**
 * Initialize a TinyFrameWithLen16NoCrc parser
 */
static inline void tiny_frame_with_len16_no_crc_parser_init(tiny_frame_with_len16_no_crc_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->length_lo = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset TinyFrameWithLen16NoCrc parser state
 */
static inline void tiny_frame_with_len16_no_crc_parser_reset(tiny_frame_with_len16_no_crc_parser_t* parser) {
    parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with TinyFrameWithLen16NoCrc format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t tiny_frame_with_len16_no_crc_parse_byte(tiny_frame_with_len16_no_crc_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START:
            if (byte == TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID;
            }
            break;

        case TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH;
            break;

        case TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            if (parser->buffer_index == 3) {
                parser->length_lo = byte;
            } else {
                parser->msg_length = parser->length_lo | ((size_t)byte << 8);
                parser->packet_size = TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + parser->msg_length;
                if (parser->packet_size <= parser->buffer_max_size) {
                    parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD;
                } else {
                    parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START;
                }
            }
            break;

        case TINY_FRAME_WITH_LEN16_NO_CRC_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                result.valid = true;
                result.msg_id = parser->msg_id;
                result.msg_len = parser->packet_size - TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                result.msg_data = parser->buffer + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                parser->state = TINY_FRAME_WITH_LEN16_NO_CRC_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with TinyFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t tiny_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)(msg_size & 0xFF);
    buffer[3] = (uint8_t)((msg_size >> 8) & 0xFF);

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen16NoCrc packet in a buffer
 */
static inline frame_msg_info_t tiny_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) {
        return result;
    }

    if (buffer[0] != TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE) {
        return result;
    }

    size_t msg_length = length - TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = (uint8_t*)(buffer + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


/*===========================================================================
 * BasicFrameWithSysComp Frame Format
 *===========================================================================*/

/* BasicFrameWithSysComp constants */
#define BASIC_FRAME_WITH_SYS_COMP_START_BYTE1    0x90
#define BASIC_FRAME_WITH_SYS_COMP_START_BYTE2    0x94
#define BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE    3  /* start_byte1 + start_byte2 + msg_id */
#define BASIC_FRAME_WITH_SYS_COMP_FOOTER_SIZE    2  /* crc(2 bytes) */
#define BASIC_FRAME_WITH_SYS_COMP_OVERHEAD       (BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + BASIC_FRAME_WITH_SYS_COMP_FOOTER_SIZE)

/* BasicFrameWithSysComp parser states */
typedef enum basic_frame_with_sys_comp_parser_state {
    BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1 = 0,
    BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START2 = 1,
    BASIC_FRAME_WITH_SYS_COMP_GETTING_MSG_ID = 2,
    BASIC_FRAME_WITH_SYS_COMP_GETTING_PAYLOAD = 3
} basic_frame_with_sys_comp_parser_state_t;

/* BasicFrameWithSysComp parser state structure */
typedef struct basic_frame_with_sys_comp_parser {
    basic_frame_with_sys_comp_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} basic_frame_with_sys_comp_parser_t;

/* BasicFrameWithSysComp encode buffer structure */
typedef struct basic_frame_with_sys_comp_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} basic_frame_with_sys_comp_encode_buffer_t;

/**
 * Initialize a BasicFrameWithSysComp parser
 */
static inline void basic_frame_with_sys_comp_parser_init(basic_frame_with_sys_comp_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset BasicFrameWithSysComp parser state
 */
static inline void basic_frame_with_sys_comp_parser_reset(basic_frame_with_sys_comp_parser_t* parser) {
    parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with BasicFrameWithSysComp format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t basic_frame_with_sys_comp_parse_byte(basic_frame_with_sys_comp_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1:
            if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START2;
            }
            break;

        case BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START2:
            if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = BASIC_FRAME_WITH_SYS_COMP_GETTING_MSG_ID;
            } else if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START2;
            } else {
                parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
            }
            break;

        case BASIC_FRAME_WITH_SYS_COMP_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = BASIC_FRAME_WITH_SYS_COMP_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = BASIC_FRAME_WITH_SYS_COMP_GETTING_PAYLOAD;
                    } else {
                        parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
                    }
                } else {
                    parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
                }
            }
            break;

        case BASIC_FRAME_WITH_SYS_COMP_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - BASIC_FRAME_WITH_SYS_COMP_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE;
                }
                parser->state = BASIC_FRAME_WITH_SYS_COMP_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with BasicFrameWithSysComp format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t basic_frame_with_sys_comp_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_SYS_COMP_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE2;
    buffer[2] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithSysComp packet in a buffer
 */
static inline frame_msg_info_t basic_frame_with_sys_comp_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < BASIC_FRAME_WITH_SYS_COMP_OVERHEAD) {
        return result;
    }

    if (buffer[0] != BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) {
        return result;
    }
    if (buffer[1] != BASIC_FRAME_WITH_SYS_COMP_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - BASIC_FRAME_WITH_SYS_COMP_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * UbxFrame Frame Format
 *===========================================================================*/

/* UbxFrame constants */
#define UBX_FRAME_START_BYTE1    0xB5
#define UBX_FRAME_START_BYTE2    0x62
#define UBX_FRAME_HEADER_SIZE    5  /* sync1 + sync2 + msg_id + length(1) */
#define UBX_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define UBX_FRAME_OVERHEAD       (UBX_FRAME_HEADER_SIZE + UBX_FRAME_FOOTER_SIZE)

/* UbxFrame parser states */
typedef enum ubx_frame_parser_state {
    UBX_FRAME_LOOKING_FOR_START1 = 0,
    UBX_FRAME_LOOKING_FOR_START2 = 1,
    UBX_FRAME_GETTING_MSG_ID = 2,
    UBX_FRAME_GETTING_LENGTH = 3,
    UBX_FRAME_GETTING_PAYLOAD = 4
} ubx_frame_parser_state_t;

/* UbxFrame parser state structure */
typedef struct ubx_frame_parser {
    ubx_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} ubx_frame_parser_t;

/* UbxFrame encode buffer structure */
typedef struct ubx_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} ubx_frame_encode_buffer_t;

/**
 * Initialize a UbxFrame parser
 */
static inline void ubx_frame_parser_init(ubx_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = UBX_FRAME_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset UbxFrame parser state
 */
static inline void ubx_frame_parser_reset(ubx_frame_parser_t* parser) {
    parser->state = UBX_FRAME_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with UbxFrame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t ubx_frame_parse_byte(ubx_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case UBX_FRAME_LOOKING_FOR_START1:
            if (byte == UBX_FRAME_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = UBX_FRAME_LOOKING_FOR_START2;
            }
            break;

        case UBX_FRAME_LOOKING_FOR_START2:
            if (byte == UBX_FRAME_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = UBX_FRAME_GETTING_MSG_ID;
            } else if (byte == UBX_FRAME_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = UBX_FRAME_LOOKING_FOR_START2;
            } else {
                parser->state = UBX_FRAME_LOOKING_FOR_START1;
            }
            break;

        case UBX_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = UBX_FRAME_GETTING_LENGTH;
            break;

        case UBX_FRAME_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = UBX_FRAME_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = UBX_FRAME_GETTING_PAYLOAD;
            } else {
                parser->state = UBX_FRAME_LOOKING_FOR_START1;
            }
            break;

        case UBX_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - UBX_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + UBX_FRAME_HEADER_SIZE;
                }
                parser->state = UBX_FRAME_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with UbxFrame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t ubx_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = UBX_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = UBX_FRAME_START_BYTE1;
    buffer[1] = UBX_FRAME_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + UBX_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1 + 1);
    buffer[UBX_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[UBX_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete UbxFrame packet in a buffer
 */
static inline frame_msg_info_t ubx_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < UBX_FRAME_OVERHEAD) {
        return result;
    }

    if (buffer[0] != UBX_FRAME_START_BYTE1) {
        return result;
    }
    if (buffer[1] != UBX_FRAME_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - UBX_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + UBX_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * MavlinkV1Frame Frame Format
 *===========================================================================*/

/* MavlinkV1Frame constants */
#define MAVLINK_V1_FRAME_START_BYTE    0xFE
#define MAVLINK_V1_FRAME_HEADER_SIZE    3  /* stx + msg_id + length(1) */
#define MAVLINK_V1_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define MAVLINK_V1_FRAME_OVERHEAD       (MAVLINK_V1_FRAME_HEADER_SIZE + MAVLINK_V1_FRAME_FOOTER_SIZE)

/* MavlinkV1Frame parser states */
typedef enum mavlink_v1_frame_parser_state {
    MAVLINK_V1_FRAME_LOOKING_FOR_START = 0,
    MAVLINK_V1_FRAME_GETTING_MSG_ID = 1,
    MAVLINK_V1_FRAME_GETTING_LENGTH = 2,
    MAVLINK_V1_FRAME_GETTING_PAYLOAD = 3
} mavlink_v1_frame_parser_state_t;

/* MavlinkV1Frame parser state structure */
typedef struct mavlink_v1_frame_parser {
    mavlink_v1_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} mavlink_v1_frame_parser_t;

/* MavlinkV1Frame encode buffer structure */
typedef struct mavlink_v1_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} mavlink_v1_frame_encode_buffer_t;

/**
 * Initialize a MavlinkV1Frame parser
 */
static inline void mavlink_v1_frame_parser_init(mavlink_v1_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MAVLINK_V1_FRAME_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MavlinkV1Frame parser state
 */
static inline void mavlink_v1_frame_parser_reset(mavlink_v1_frame_parser_t* parser) {
    parser->state = MAVLINK_V1_FRAME_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MavlinkV1Frame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t mavlink_v1_frame_parse_byte(mavlink_v1_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MAVLINK_V1_FRAME_LOOKING_FOR_START:
            if (byte == MAVLINK_V1_FRAME_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = MAVLINK_V1_FRAME_GETTING_MSG_ID;
            }
            break;

        case MAVLINK_V1_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MAVLINK_V1_FRAME_GETTING_LENGTH;
            break;

        case MAVLINK_V1_FRAME_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = MAVLINK_V1_FRAME_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = MAVLINK_V1_FRAME_GETTING_PAYLOAD;
            } else {
                parser->state = MAVLINK_V1_FRAME_LOOKING_FOR_START;
            }
            break;

        case MAVLINK_V1_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - MAVLINK_V1_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 1, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + MAVLINK_V1_FRAME_HEADER_SIZE;
                }
                parser->state = MAVLINK_V1_FRAME_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MavlinkV1Frame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t mavlink_v1_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MAVLINK_V1_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = MAVLINK_V1_FRAME_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MAVLINK_V1_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MavlinkV1Frame packet in a buffer
 */
static inline frame_msg_info_t mavlink_v1_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MAVLINK_V1_FRAME_OVERHEAD) {
        return result;
    }

    if (buffer[0] != MAVLINK_V1_FRAME_START_BYTE) {
        return result;
    }

    size_t msg_length = length - MAVLINK_V1_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + MAVLINK_V1_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * MavlinkV2Frame Frame Format
 *===========================================================================*/

/* MavlinkV2Frame constants */
#define MAVLINK_V2_FRAME_START_BYTE    0xFD
#define MAVLINK_V2_FRAME_HEADER_SIZE    5  /* stx + msg_id + length(1) */
#define MAVLINK_V2_FRAME_FOOTER_SIZE    2  /* crc(2 bytes) */
#define MAVLINK_V2_FRAME_OVERHEAD       (MAVLINK_V2_FRAME_HEADER_SIZE + MAVLINK_V2_FRAME_FOOTER_SIZE)

/* MavlinkV2Frame parser states */
typedef enum mavlink_v2_frame_parser_state {
    MAVLINK_V2_FRAME_LOOKING_FOR_START = 0,
    MAVLINK_V2_FRAME_GETTING_MSG_ID = 1,
    MAVLINK_V2_FRAME_GETTING_LENGTH = 2,
    MAVLINK_V2_FRAME_GETTING_PAYLOAD = 3
} mavlink_v2_frame_parser_state_t;

/* MavlinkV2Frame parser state structure */
typedef struct mavlink_v2_frame_parser {
    mavlink_v2_frame_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    size_t msg_length;  /* From length field */
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} mavlink_v2_frame_parser_t;

/* MavlinkV2Frame encode buffer structure */
typedef struct mavlink_v2_frame_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} mavlink_v2_frame_encode_buffer_t;

/**
 * Initialize a MavlinkV2Frame parser
 */
static inline void mavlink_v2_frame_parser_init(mavlink_v2_frame_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = MAVLINK_V2_FRAME_LOOKING_FOR_START;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset MavlinkV2Frame parser state
 */
static inline void mavlink_v2_frame_parser_reset(mavlink_v2_frame_parser_t* parser) {
    parser->state = MAVLINK_V2_FRAME_LOOKING_FOR_START;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->msg_length = 0;
}

/**
 * Parse a single byte with MavlinkV2Frame format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t mavlink_v2_frame_parse_byte(mavlink_v2_frame_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case MAVLINK_V2_FRAME_LOOKING_FOR_START:
            if (byte == MAVLINK_V2_FRAME_START_BYTE) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = MAVLINK_V2_FRAME_GETTING_MSG_ID;
            }
            break;

        case MAVLINK_V2_FRAME_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            parser->state = MAVLINK_V2_FRAME_GETTING_LENGTH;
            break;

        case MAVLINK_V2_FRAME_GETTING_LENGTH:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_length = byte;
            parser->packet_size = MAVLINK_V2_FRAME_OVERHEAD + parser->msg_length;
            if (parser->packet_size <= parser->buffer_max_size) {
                parser->state = MAVLINK_V2_FRAME_GETTING_PAYLOAD;
            } else {
                parser->state = MAVLINK_V2_FRAME_LOOKING_FOR_START;
            }
            break;

        case MAVLINK_V2_FRAME_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - MAVLINK_V2_FRAME_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 1, msg_length + 1 + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + MAVLINK_V2_FRAME_HEADER_SIZE;
                }
                parser->state = MAVLINK_V2_FRAME_LOOKING_FOR_START;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with MavlinkV2Frame format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t mavlink_v2_frame_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MAVLINK_V2_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = MAVLINK_V2_FRAME_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = (uint8_t)msg_size;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + MAVLINK_V2_FRAME_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MavlinkV2Frame packet in a buffer
 */
static inline frame_msg_info_t mavlink_v2_frame_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < MAVLINK_V2_FRAME_OVERHEAD) {
        return result;
    }

    if (buffer[0] != MAVLINK_V2_FRAME_START_BYTE) {
        return result;
    }

    size_t msg_length = length - MAVLINK_V2_FRAME_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + MAVLINK_V2_FRAME_HEADER_SIZE);
    }

    return result;
}


/*===========================================================================
 * FrameFormatConfig Frame Format
 *===========================================================================*/

/* FrameFormatConfig constants */
#define FRAME_FORMAT_CONFIG_START_BYTE1    0x90
#define FRAME_FORMAT_CONFIG_START_BYTE2    0x91
#define FRAME_FORMAT_CONFIG_HEADER_SIZE    2  /* start_byte1 + start_byte2 + msg_id */
#define FRAME_FORMAT_CONFIG_FOOTER_SIZE    1  /* crc(1 bytes) */
#define FRAME_FORMAT_CONFIG_OVERHEAD       (FRAME_FORMAT_CONFIG_HEADER_SIZE + FRAME_FORMAT_CONFIG_FOOTER_SIZE)

/* FrameFormatConfig parser states */
typedef enum frame_format_config_parser_state {
    FRAME_FORMAT_CONFIG_LOOKING_FOR_START1 = 0,
    FRAME_FORMAT_CONFIG_LOOKING_FOR_START2 = 1,
    FRAME_FORMAT_CONFIG_GETTING_MSG_ID = 2,
    FRAME_FORMAT_CONFIG_GETTING_PAYLOAD = 3
} frame_format_config_parser_state_t;

/* FrameFormatConfig parser state structure */
typedef struct frame_format_config_parser {
    frame_format_config_parser_state_t state;
    uint8_t* buffer;
    size_t buffer_max_size;
    size_t buffer_index;
    size_t packet_size;
    uint8_t msg_id;
    /* User-provided function to get message length from msg_id (for non-length frames) */
    bool (*get_msg_length)(uint8_t msg_id, size_t* length);
} frame_format_config_parser_t;

/* FrameFormatConfig encode buffer structure */
typedef struct frame_format_config_encode_buffer {
    uint8_t* data;
    size_t max_size;
    size_t size;
    bool in_progress;
    size_t reserved_msg_size;
} frame_format_config_encode_buffer_t;

/**
 * Initialize a FrameFormatConfig parser
 */
static inline void frame_format_config_parser_init(frame_format_config_parser_t* parser,
                                        uint8_t* buffer, size_t buffer_size,
                                        bool (*get_msg_length)(uint8_t msg_id, size_t* length)) {
    parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
    parser->buffer = buffer;
    parser->buffer_max_size = buffer_size;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
    parser->get_msg_length = get_msg_length;
}

/**
 * Reset FrameFormatConfig parser state
 */
static inline void frame_format_config_parser_reset(frame_format_config_parser_t* parser) {
    parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
    parser->buffer_index = 0;
    parser->packet_size = 0;
    parser->msg_id = 0;
}

/**
 * Parse a single byte with FrameFormatConfig format
 * Returns frame_msg_info_t with valid=true when a complete valid message is received
 */
static inline frame_msg_info_t frame_format_config_parse_byte(frame_format_config_parser_t* parser, uint8_t byte) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    switch (parser->state) {
        case FRAME_FORMAT_CONFIG_LOOKING_FOR_START1:
            if (byte == FRAME_FORMAT_CONFIG_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START2;
            }
            break;

        case FRAME_FORMAT_CONFIG_LOOKING_FOR_START2:
            if (byte == FRAME_FORMAT_CONFIG_START_BYTE2) {
                parser->buffer[1] = byte;
                parser->buffer_index = 2;
                parser->state = FRAME_FORMAT_CONFIG_GETTING_MSG_ID;
            } else if (byte == FRAME_FORMAT_CONFIG_START_BYTE1) {
                parser->buffer[0] = byte;
                parser->buffer_index = 1;
                parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START2;
            } else {
                parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
            }
            break;

        case FRAME_FORMAT_CONFIG_GETTING_MSG_ID:
            parser->buffer[parser->buffer_index++] = byte;
            parser->msg_id = byte;
            {
                size_t msg_length = 0;
                if (parser->get_msg_length && parser->get_msg_length(byte, &msg_length)) {
                    parser->packet_size = FRAME_FORMAT_CONFIG_OVERHEAD + msg_length;
                    if (parser->packet_size <= parser->buffer_max_size) {
                        parser->state = FRAME_FORMAT_CONFIG_GETTING_PAYLOAD;
                    } else {
                        parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
                    }
                } else {
                    parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
                }
            }
            break;

        case FRAME_FORMAT_CONFIG_GETTING_PAYLOAD:
            if (parser->buffer_index < parser->buffer_max_size) {
                parser->buffer[parser->buffer_index++] = byte;
            }

            if (parser->buffer_index >= parser->packet_size) {
                /* Validate checksum */
                size_t msg_length = parser->packet_size - FRAME_FORMAT_CONFIG_OVERHEAD;
                frame_checksum_t ck = frame_fletcher_checksum(
                    parser->buffer + 2, msg_length + 1);

                if (ck.byte1 == parser->buffer[parser->packet_size - 2] &&
                    ck.byte2 == parser->buffer[parser->packet_size - 1]) {
                    result.valid = true;
                    result.msg_id = parser->msg_id;
                    result.msg_len = msg_length;
                    result.msg_data = parser->buffer + FRAME_FORMAT_CONFIG_HEADER_SIZE;
                }
                parser->state = FRAME_FORMAT_CONFIG_LOOKING_FOR_START1;
            }
            break;
    }

    return result;
}

/**
 * Encode a message with FrameFormatConfig format
 * Returns the number of bytes written, or 0 on failure
 */
static inline size_t frame_format_config_encode(uint8_t* buffer, size_t buffer_size,
                                     uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = FRAME_FORMAT_CONFIG_OVERHEAD + msg_size;
    if (buffer_size < total_size) {
        return 0;
    }

    buffer[0] = FRAME_FORMAT_CONFIG_START_BYTE1;
    buffer[1] = FRAME_FORMAT_CONFIG_START_BYTE2;
    buffer[2] = msg_id;

    /* Write message data */
    if (msg_size > 0 && msg != NULL) {
        memcpy(buffer + FRAME_FORMAT_CONFIG_HEADER_SIZE, msg, msg_size);
    }

    /* Calculate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete FrameFormatConfig packet in a buffer
 */
static inline frame_msg_info_t frame_format_config_validate_packet(const uint8_t* buffer, size_t length) {
    frame_msg_info_t result = {false, 0, 0, NULL};

    if (length < FRAME_FORMAT_CONFIG_OVERHEAD) {
        return result;
    }

    if (buffer[0] != FRAME_FORMAT_CONFIG_START_BYTE1) {
        return result;
    }
    if (buffer[1] != FRAME_FORMAT_CONFIG_START_BYTE2) {
        return result;
    }

    size_t msg_length = length - FRAME_FORMAT_CONFIG_OVERHEAD;

    /* Validate checksum */
    frame_checksum_t ck = frame_fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = (uint8_t*)(buffer + FRAME_FORMAT_CONFIG_HEADER_SIZE);
    }

    return result;
}


