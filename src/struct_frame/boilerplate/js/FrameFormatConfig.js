// Automatically generated frame parser
// Generated by 0.0.1 at Thu Dec  4 20:27:20 2025.

const {
    createFrameMsgInfo, fletcher_checksum,
    validate_payload_with_crc, validate_payload_minimal,
    encode_payload_with_crc, encode_payload_minimal,
} = require('./frame_base');

// =============================================================================
// FrameFormatConfig Frame Format
// =============================================================================

const FrameFormatConfigParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_PAYLOAD: 3
};

/**
 * FrameFormatConfig - Frame format parser and encoder
 */
class FrameFormatConfig {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x71;
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 1;
    static OVERHEAD = 3;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case FrameFormatConfigParserState.LOOKING_FOR_START1:
                if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                }
                break;

            case FrameFormatConfigParserState.LOOKING_FOR_START2:
                if (byte === FrameFormatConfig.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = FrameFormatConfigParserState.GETTING_MSG_ID;
                } else if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = FrameFormatConfig.OVERHEAD + msg_length;
                        this.state = FrameFormatConfigParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    // Use shared payload validation with CRC
                    const validationResult = validate_payload_with_crc(this.buffer, FrameFormatConfig.HEADER_SIZE, 0, 2);
                    if (validationResult.valid) {
                        result.valid = validationResult.valid;
                        result.msg_id = validationResult.msg_id;
                        result.msg_len = validationResult.msg_len;
                        result.msg_data = validationResult.msg_data;
                    }
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(FrameFormatConfig.START_BYTE1);
        output.push(FrameFormatConfig.START_BYTE2);
        // Use shared payload encoding with CRC
        encode_payload_with_crc(output, msg_id, msg, 0, 2);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        if (buffer.length < FrameFormatConfig.OVERHEAD) {
            return createFrameMsgInfo();
        }

        if (buffer[0] !== FrameFormatConfig.START_BYTE1) {
            return createFrameMsgInfo();
        }
        if (buffer[1] !== FrameFormatConfig.START_BYTE2) {
            return createFrameMsgInfo();
        }

        // Use shared payload validation with CRC
        return validate_payload_with_crc(buffer, FrameFormatConfig.HEADER_SIZE, 0, 2);
    }
}

module.exports = {
    FrameFormatConfig,
    FrameFormatConfigParserState,
};
