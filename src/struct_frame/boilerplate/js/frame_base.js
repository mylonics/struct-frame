// Automatically generated frame parser base utilities
// Generated by 0.0.1 at Thu Dec  4 20:27:20 2025.

// Frame format type enumeration
const FrameFormatType = {
    TINY_MINIMAL: 0,
    TINY_DEFAULT: 1,
    TINY_EXTENDED_MSG_IDS: 2,
    TINY_EXTENDED_LENGTH: 3,
    TINY_EXTENDED: 4,
    TINY_SYS_COMP: 5,
    TINY_SEQ: 6,
    TINY_MULTI_SYSTEM_STREAM: 7,
    TINY_EXTENDED_MULTI_SYSTEM_STREAM: 8,
    BASIC_MINIMAL: 9,
    BASIC_DEFAULT: 10,
    BASIC_EXTENDED_MSG_IDS: 11,
    BASIC_EXTENDED_LENGTH: 12,
    BASIC_EXTENDED: 13,
    BASIC_SYS_COMP: 14,
    BASIC_SEQ: 15,
    BASIC_MULTI_SYSTEM_STREAM: 16,
    BASIC_EXTENDED_MULTI_SYSTEM_STREAM: 17,
    UBX_FRAME: 18,
    MAVLINK_V1_FRAME: 19,
    MAVLINK_V2_FRAME: 20,
    FRAME_FORMAT_CONFIG: 21,
};

// Fletcher-16 checksum calculation
function fletcher_checksum(buffer, start = 0, end = undefined) {
    if (end === undefined) {
        end = buffer.length;
    }

    let byte1 = 0;
    let byte2 = 0;

    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }

    return [byte1, byte2];
}

// Create default FrameMsgInfo
function createFrameMsgInfo() {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// Shared Payload Parsing Functions
// =============================================================================
// These functions handle payload validation/encoding independent of framing.
// Frame formats (Tiny/Basic) use these for the common parsing logic.

/**
 * Validate a payload with CRC (shared by Default, Extended, etc. payload types).
 */
function validate_payload_with_crc(buffer, headerSize, lengthBytes, crcStartOffset) {
    const result = createFrameMsgInfo();
    const footerSize = 2; // CRC is always 2 bytes
    const overhead = headerSize + footerSize;

    if (buffer.length < overhead) {
        return result;
    }

    const msgLength = buffer.length - overhead;

    // Calculate expected CRC range: from crcStartOffset to before the CRC bytes
    const crcDataLen = msgLength + 1 + lengthBytes; // msg_id (1) + lengthBytes + payload
    const ck = fletcher_checksum(buffer, crcStartOffset, crcStartOffset + crcDataLen);

    if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
        result.valid = true;
        result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
        result.msg_len = msgLength;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize, buffer.length - footerSize));
    }

    return result;
}

/**
 * Validate a minimal payload (no CRC, no length field).
 */
function validate_payload_minimal(buffer, headerSize) {
    const result = createFrameMsgInfo();

    if (buffer.length < headerSize) {
        return result;
    }

    result.valid = true;
    result.msg_id = buffer[headerSize - 1]; // msg_id is last byte of header
    result.msg_len = buffer.length - headerSize;
    result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, headerSize));

    return result;
}

/**
 * Encode payload with length and CRC (modifies output array in place).
 */
function encode_payload_with_crc(output, msgId, msg, lengthBytes, crcStartOffset) {
    // Add length field
    if (lengthBytes === 1) {
        output.push(msg.length & 0xFF);
    } else {
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
    }

    // Add msg_id
    output.push(msgId);

    // Add payload
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }

    // Calculate and add CRC
    const crcDataLen = msg.length + 1 + lengthBytes;
    const ck = fletcher_checksum(output, crcStartOffset, crcStartOffset + crcDataLen);
    output.push(ck[0]);
    output.push(ck[1]);
}

/**
 * Encode minimal payload (no length, no CRC).
 */
function encode_payload_minimal(output, msgId, msg) {
    output.push(msgId);
    for (let i = 0; i < msg.length; i++) {
        output.push(msg[i]);
    }
}

module.exports = {
    FrameFormatType,
    fletcher_checksum,
    createFrameMsgInfo,
    validate_payload_with_crc,
    validate_payload_minimal,
    encode_payload_with_crc,
    encode_payload_minimal,
};
