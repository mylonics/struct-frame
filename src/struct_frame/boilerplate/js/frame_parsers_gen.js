// Automatically generated frame parser
// Generated by 0.0.1 at Sun Nov 30 16:50:10 2025.

// Frame format type enumeration
const FrameFormatType = {
    MINIMAL_FRAME: 0,
    BASIC_FRAME: 1,
    BASIC_FRAME_NO_CRC: 2,
    TINY_FRAME: 3,
    TINY_FRAME_NO_CRC: 4,
    MINIMAL_FRAME_WITH_LEN: 5,
    MINIMAL_FRAME_WITH_LEN_NO_CRC: 6,
    BASIC_FRAME_WITH_LEN: 7,
    BASIC_FRAME_WITH_LEN_NO_CRC: 8,
    TINY_FRAME_WITH_LEN: 9,
    TINY_FRAME_WITH_LEN_NO_CRC: 10,
    MINIMAL_FRAME_WITH_LEN16: 11,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC: 12,
    BASIC_FRAME_WITH_LEN16: 13,
    BASIC_FRAME_WITH_LEN16_NO_CRC: 14,
    TINY_FRAME_WITH_LEN16: 15,
    TINY_FRAME_WITH_LEN16_NO_CRC: 16,
    BASIC_FRAME_WITH_SYS_COMP: 17,
    UBX_FRAME: 18,
    MAVLINK_V1_FRAME: 19,
    MAVLINK_V2_FRAME: 20,
    FRAME_FORMAT_CONFIG: 21,
};

// Fletcher-16 checksum calculation
function fletcher_checksum(buffer, start = 0, end = undefined) {
    if (end === undefined) {
        end = buffer.length;
    }
    
    let byte1 = 0;
    let byte2 = 0;
    
    for (let i = start; i < end; i++) {
        byte1 = (byte1 + buffer[i]) % 256;
        byte2 = (byte2 + byte1) % 256;
    }
    
    return [byte1, byte2];
}

// Create default FrameMsgInfo
function createFrameMsgInfo() {
    return {
        valid: false,
        msg_id: 0,
        msg_len: 0,
        msg_data: new Uint8Array(0)
    };
}

// =============================================================================
// MinimalFrame Frame Format
// =============================================================================

const MinimalFrameParserState = {
    GETTING_MSG_ID: 0,
    GETTING_PAYLOAD: 1
};

/**
 * MinimalFrame - Frame format parser and encoder
 */
class MinimalFrame {
    static HEADER_SIZE = 1;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 3;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = MinimalFrameParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = MinimalFrame.OVERHEAD + msg_length;
                        this.state = MinimalFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = MinimalFrameParserState.GETTING_MSG_ID;
                    }
                } else {
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;

            case MinimalFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MinimalFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrame.HEADER_SIZE, this.packet_size - MinimalFrame.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrame.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrame.HEADER_SIZE, buffer.length - MinimalFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrame Frame Format
// =============================================================================

const BasicFrameParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_PAYLOAD: 3
};

/**
 * BasicFrame - Frame format parser and encoder
 */
class BasicFrame {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x91;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 5;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = BasicFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameParserState.LOOKING_FOR_START1:
                if (byte === BasicFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameParserState.LOOKING_FOR_START2:
                if (byte === BasicFrame.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrame.OVERHEAD + msg_length;
                        this.state = BasicFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - BasicFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrame.HEADER_SIZE, this.packet_size - BasicFrame.FOOTER_SIZE));
                    }
                    this.state = BasicFrameParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrame.START_BYTE1);
        output.push(BasicFrame.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrame.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrame.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrame.HEADER_SIZE, buffer.length - BasicFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameNoCrc Frame Format
// =============================================================================

const BasicFrameNoCrcParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_PAYLOAD: 3
};

/**
 * BasicFrameNoCrc - Frame format parser and encoder
 */
class BasicFrameNoCrc {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x95;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 3;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameNoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameNoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameNoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameNoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrameNoCrc.OVERHEAD + msg_length;
                        this.state = BasicFrameNoCrcParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameNoCrc.HEADER_SIZE));
                    this.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameNoCrc.START_BYTE1);
        output.push(BasicFrameNoCrc.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameNoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameNoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrame Frame Format
// =============================================================================

const TinyFrameParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_PAYLOAD: 2
};

/**
 * TinyFrame - Frame format parser and encoder
 */
class TinyFrame {
    static START_BYTE = 0x70;
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 4;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = TinyFrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameParserState.LOOKING_FOR_START:
                if (byte === TinyFrame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = TinyFrame.OVERHEAD + msg_length;
                        this.state = TinyFrameParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = TinyFrameParserState.LOOKING_FOR_START;
                    }
                } else {
                    this.state = TinyFrameParserState.LOOKING_FOR_START;
                }
                break;

            case TinyFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - TinyFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrame.HEADER_SIZE, this.packet_size - TinyFrame.FOOTER_SIZE));
                    }
                    this.state = TinyFrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrame.START_BYTE);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrame.HEADER_SIZE, buffer.length - TinyFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameNoCrc Frame Format
// =============================================================================

const TinyFrameNoCrcParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_PAYLOAD: 2
};

/**
 * TinyFrameNoCrc - Frame format parser and encoder
 */
class TinyFrameNoCrc {
    static START_BYTE = 0x72;
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameNoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameNoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameNoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = TinyFrameNoCrc.OVERHEAD + msg_length;
                        this.state = TinyFrameNoCrcParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                    }
                } else {
                    this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                }
                break;

            case TinyFrameNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameNoCrc.HEADER_SIZE));
                    this.state = TinyFrameNoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrameNoCrc.START_BYTE);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameNoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen Frame Format
// =============================================================================

const MinimalFrameWithLenParserState = {
    GETTING_MSG_ID: 0,
    GETTING_LENGTH: 1,
    GETTING_PAYLOAD: 2
};

/**
 * MinimalFrameWithLen - Frame format parser and encoder
 */
class MinimalFrameWithLen {
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 4;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLenParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MinimalFrameWithLen.OVERHEAD + this.msg_length;
                this.state = MinimalFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case MinimalFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MinimalFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen.HEADER_SIZE, this.packet_size - MinimalFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameWithLenParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen.OVERHEAD;

        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen.HEADER_SIZE, buffer.length - MinimalFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLenNoCrc Frame Format
// =============================================================================

const MinimalFrameWithLenNoCrcParserState = {
    GETTING_MSG_ID: 0,
    GETTING_LENGTH: 1,
    GETTING_PAYLOAD: 2
};

/**
 * MinimalFrameWithLenNoCrc - Frame format parser and encoder
 */
class MinimalFrameWithLenNoCrc {
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 2;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MinimalFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - MinimalFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen Frame Format
// =============================================================================

const BasicFrameWithLenParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * BasicFrameWithLen - Frame format parser and encoder
 */
class BasicFrameWithLen {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x92;
    static HEADER_SIZE = 4;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 6;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLenParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLenParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLenParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLenParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = BasicFrameWithLen.OVERHEAD + this.msg_length;
                this.state = BasicFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case BasicFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - BasicFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen.HEADER_SIZE, this.packet_size - BasicFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithLenParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithLen.START_BYTE1);
        output.push(BasicFrameWithLen.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen.HEADER_SIZE, buffer.length - BasicFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameWithLenNoCrc Frame Format
// =============================================================================

const BasicFrameWithLenNoCrcParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * BasicFrameWithLenNoCrc - Frame format parser and encoder
 */
class BasicFrameWithLenNoCrc {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x96;
    static HEADER_SIZE = 4;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 4;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLenNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLenNoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLenNoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = BasicFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithLenNoCrc.START_BYTE1);
        output.push(BasicFrameWithLenNoCrc.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLenNoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLenNoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen Frame Format
// =============================================================================

const TinyFrameWithLenParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * TinyFrameWithLen - Frame format parser and encoder
 */
class TinyFrameWithLen {
    static START_BYTE = 0x71;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 5;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLenParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLenParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLenParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLenParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLenParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = TinyFrameWithLen.OVERHEAD + this.msg_length;
                this.state = TinyFrameWithLenParserState.GETTING_PAYLOAD;
                break;

            case TinyFrameWithLenParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - TinyFrameWithLen.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen.HEADER_SIZE, this.packet_size - TinyFrameWithLen.FOOTER_SIZE));
                    }
                    this.state = TinyFrameWithLenParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrameWithLen.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen.OVERHEAD;

        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen.HEADER_SIZE, buffer.length - TinyFrameWithLen.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameWithLenNoCrc Frame Format
// =============================================================================

const TinyFrameWithLenNoCrcParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * TinyFrameWithLenNoCrc - Frame format parser and encoder
 */
class TinyFrameWithLenNoCrc {
    static START_BYTE = 0x73;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 3;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLenNoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLenNoCrcParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = TinyFrameWithLenNoCrc.OVERHEAD + this.msg_length;
                this.state = TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD;
                break;

            case TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameWithLenNoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLenNoCrc.HEADER_SIZE));
                    this.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrameWithLenNoCrc.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLenNoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLenNoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLenNoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLenNoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen16 Frame Format
// =============================================================================

const MinimalFrameWithLen16ParserState = {
    GETTING_MSG_ID: 0,
    GETTING_LENGTH: 1,
    GETTING_PAYLOAD: 2
};

/**
 * MinimalFrameWithLen16 - Frame format parser and encoder
 */
class MinimalFrameWithLen16 {
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 5;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 2) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = MinimalFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = MinimalFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case MinimalFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MinimalFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 0, 0 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen16.HEADER_SIZE, this.packet_size - MinimalFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 0, 0 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen16.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen16.OVERHEAD;

        const ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[0];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen16.HEADER_SIZE, buffer.length - MinimalFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MinimalFrameWithLen16NoCrc Frame Format
// =============================================================================

const MinimalFrameWithLen16NoCrcParserState = {
    GETTING_MSG_ID: 0,
    GETTING_LENGTH: 1,
    GETTING_PAYLOAD: 2
};

/**
 * MinimalFrameWithLen16NoCrc - Frame format parser and encoder
 */
class MinimalFrameWithLen16NoCrc {
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 3;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 2) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = MinimalFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - MinimalFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(MinimalFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MinimalFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }


        const msg_length = buffer.length - MinimalFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MinimalFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen16 Frame Format
// =============================================================================

const BasicFrameWithLen16ParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * BasicFrameWithLen16 - Frame format parser and encoder
 */
class BasicFrameWithLen16 {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x93;
    static HEADER_SIZE = 5;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 7;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLen16ParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen16.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLen16ParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen16.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLen16ParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen16.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 4) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = BasicFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = BasicFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case BasicFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - BasicFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen16.HEADER_SIZE, this.packet_size - BasicFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithLen16.START_BYTE1);
        output.push(BasicFrameWithLen16.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen16.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen16.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen16.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen16.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen16.HEADER_SIZE, buffer.length - BasicFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// BasicFrameWithLen16NoCrc Frame Format
// =============================================================================

const BasicFrameWithLen16NoCrcParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * BasicFrameWithLen16NoCrc - Frame format parser and encoder
 */
class BasicFrameWithLen16NoCrc {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x97;
    static HEADER_SIZE = 5;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 5;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithLen16NoCrc.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithLen16NoCrc.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 4) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = BasicFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - BasicFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithLen16NoCrc.START_BYTE1);
        output.push(BasicFrameWithLen16NoCrc.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithLen16NoCrc.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithLen16NoCrc.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen16 Frame Format
// =============================================================================

const TinyFrameWithLen16ParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * TinyFrameWithLen16 - Frame format parser and encoder
 */
class TinyFrameWithLen16 {
    static START_BYTE = 0x74;
    static HEADER_SIZE = 4;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 6;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLen16ParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen16.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLen16ParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLen16ParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLen16ParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLen16ParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 3) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = TinyFrameWithLen16.OVERHEAD + this.msg_length;
                    this.state = TinyFrameWithLen16ParserState.GETTING_PAYLOAD;
                }
                break;

            case TinyFrameWithLen16ParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - TinyFrameWithLen16.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 2);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen16.HEADER_SIZE, this.packet_size - TinyFrameWithLen16.FOOTER_SIZE));
                    }
                    this.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrameWithLen16.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 2);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen16.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen16.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen16.OVERHEAD;

        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 2);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen16.HEADER_SIZE, buffer.length - TinyFrameWithLen16.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// TinyFrameWithLen16NoCrc Frame Format
// =============================================================================

const TinyFrameWithLen16NoCrcParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * TinyFrameWithLen16NoCrc - Frame format parser and encoder
 */
class TinyFrameWithLen16NoCrc {
    static START_BYTE = 0x75;
    static HEADER_SIZE = 4;
    static FOOTER_SIZE = 0;
    static OVERHEAD = 4;
    static LENGTH_BYTES = 2;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
        this.length_lo = 0;
    }

    reset() {
        this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START:
                if (byte === TinyFrameWithLen16NoCrc.START_BYTE) {
                    this.buffer = [byte];
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH;
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                if (this.buffer.length === 3) {
                    this.length_lo = byte;
                } else {
                    this.msg_length = this.length_lo | (byte << 8);
                    this.packet_size = TinyFrameWithLen16NoCrc.OVERHEAD + this.msg_length;
                    this.state = TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    result.valid = true;
                    result.msg_id = this.msg_id;
                    result.msg_len = this.packet_size - TinyFrameWithLen16NoCrc.OVERHEAD;
                    result.msg_data = new Uint8Array(this.buffer.slice(TinyFrameWithLen16NoCrc.HEADER_SIZE));
                    this.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(TinyFrameWithLen16NoCrc.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        output.push((msg.length >> 8) & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < TinyFrameWithLen16NoCrc.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== TinyFrameWithLen16NoCrc.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - TinyFrameWithLen16NoCrc.OVERHEAD;

        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, TinyFrameWithLen16NoCrc.HEADER_SIZE));

        return result;
    }
}


// =============================================================================
// BasicFrameWithSysComp Frame Format
// =============================================================================

const BasicFrameWithSysCompParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_PAYLOAD: 3
};

/**
 * BasicFrameWithSysComp - Frame format parser and encoder
 */
class BasicFrameWithSysComp {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x94;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 5;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case BasicFrameWithSysCompParserState.LOOKING_FOR_START1:
                if (byte === BasicFrameWithSysComp.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2;
                }
                break;

            case BasicFrameWithSysCompParserState.LOOKING_FOR_START2:
                if (byte === BasicFrameWithSysComp.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = BasicFrameWithSysCompParserState.GETTING_MSG_ID;
                } else if (byte === BasicFrameWithSysComp.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2;
                } else {
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithSysCompParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = BasicFrameWithSysComp.OVERHEAD + msg_length;
                        this.state = BasicFrameWithSysCompParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;

            case BasicFrameWithSysCompParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - BasicFrameWithSysComp.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(BasicFrameWithSysComp.HEADER_SIZE, this.packet_size - BasicFrameWithSysComp.FOOTER_SIZE));
                    }
                    this.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(BasicFrameWithSysComp.START_BYTE1);
        output.push(BasicFrameWithSysComp.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < BasicFrameWithSysComp.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== BasicFrameWithSysComp.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== BasicFrameWithSysComp.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - BasicFrameWithSysComp.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, BasicFrameWithSysComp.HEADER_SIZE, buffer.length - BasicFrameWithSysComp.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// UbxFrame Frame Format
// =============================================================================

const UbxFrameParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_LENGTH: 3,
    GETTING_PAYLOAD: 4
};

/**
 * UbxFrame - Frame format parser and encoder
 */
class UbxFrame {
    static START_BYTE1 = 0xB5;
    static START_BYTE2 = 0x62;
    static HEADER_SIZE = 5;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 7;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = UbxFrameParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case UbxFrameParserState.LOOKING_FOR_START1:
                if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                }
                break;

            case UbxFrameParserState.LOOKING_FOR_START2:
                if (byte === UbxFrame.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = UbxFrameParserState.GETTING_MSG_ID;
                } else if (byte === UbxFrame.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = UbxFrameParserState.LOOKING_FOR_START2;
                } else {
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;

            case UbxFrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = UbxFrameParserState.GETTING_LENGTH;
                break;

            case UbxFrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = UbxFrame.OVERHEAD + this.msg_length;
                this.state = UbxFrameParserState.GETTING_PAYLOAD;
                break;

            case UbxFrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - UbxFrame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(UbxFrame.HEADER_SIZE, this.packet_size - UbxFrame.FOOTER_SIZE));
                    }
                    this.state = UbxFrameParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(UbxFrame.START_BYTE1);
        output.push(UbxFrame.START_BYTE2);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < UbxFrame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== UbxFrame.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== UbxFrame.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - UbxFrame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, UbxFrame.HEADER_SIZE, buffer.length - UbxFrame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MavlinkV1Frame Frame Format
// =============================================================================

const MavlinkV1FrameParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * MavlinkV1Frame - Frame format parser and encoder
 */
class MavlinkV1Frame {
    static START_BYTE = 0xFE;
    static HEADER_SIZE = 3;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 5;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MavlinkV1FrameParserState.LOOKING_FOR_START:
                if (byte === MavlinkV1Frame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = MavlinkV1FrameParserState.GETTING_MSG_ID;
                }
                break;

            case MavlinkV1FrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MavlinkV1FrameParserState.GETTING_LENGTH;
                break;

            case MavlinkV1FrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MavlinkV1Frame.OVERHEAD + this.msg_length;
                this.state = MavlinkV1FrameParserState.GETTING_PAYLOAD;
                break;

            case MavlinkV1FrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MavlinkV1Frame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MavlinkV1Frame.HEADER_SIZE, this.packet_size - MavlinkV1Frame.FOOTER_SIZE));
                    }
                    this.state = MavlinkV1FrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(MavlinkV1Frame.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MavlinkV1Frame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== MavlinkV1Frame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - MavlinkV1Frame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MavlinkV1Frame.HEADER_SIZE, buffer.length - MavlinkV1Frame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// MavlinkV2Frame Frame Format
// =============================================================================

const MavlinkV2FrameParserState = {
    LOOKING_FOR_START: 0,
    GETTING_MSG_ID: 1,
    GETTING_LENGTH: 2,
    GETTING_PAYLOAD: 3
};

/**
 * MavlinkV2Frame - Frame format parser and encoder
 */
class MavlinkV2Frame {
    static START_BYTE = 0xFD;
    static HEADER_SIZE = 5;
    static FOOTER_SIZE = 2;
    static OVERHEAD = 7;
    static LENGTH_BYTES = 1;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    reset() {
        this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
        this.msg_length = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case MavlinkV2FrameParserState.LOOKING_FOR_START:
                if (byte === MavlinkV2Frame.START_BYTE) {
                    this.buffer = [byte];
                    this.state = MavlinkV2FrameParserState.GETTING_MSG_ID;
                }
                break;

            case MavlinkV2FrameParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                this.state = MavlinkV2FrameParserState.GETTING_LENGTH;
                break;

            case MavlinkV2FrameParserState.GETTING_LENGTH:
                this.buffer.push(byte);
                this.msg_length = byte;
                this.packet_size = MavlinkV2Frame.OVERHEAD + this.msg_length;
                this.state = MavlinkV2FrameParserState.GETTING_PAYLOAD;
                break;

            case MavlinkV2FrameParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - MavlinkV2Frame.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 1, 1 + msg_length + 1 + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(MavlinkV2Frame.HEADER_SIZE, this.packet_size - MavlinkV2Frame.FOOTER_SIZE));
                    }
                    this.state = MavlinkV2FrameParserState.LOOKING_FOR_START;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(MavlinkV2Frame.START_BYTE);
        output.push(msg_id);
        output.push(msg.length & 0xFF);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 1, 1 + msg.length + 1 + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < MavlinkV2Frame.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== MavlinkV2Frame.START_BYTE) {
            return result;
        }

        const msg_length = buffer.length - MavlinkV2Frame.OVERHEAD;

        const ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[1];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, MavlinkV2Frame.HEADER_SIZE, buffer.length - MavlinkV2Frame.FOOTER_SIZE));
        }

        return result;
    }
}


// =============================================================================
// FrameFormatConfig Frame Format
// =============================================================================

const FrameFormatConfigParserState = {
    LOOKING_FOR_START1: 0,
    LOOKING_FOR_START2: 1,
    GETTING_MSG_ID: 2,
    GETTING_PAYLOAD: 3
};

/**
 * FrameFormatConfig - Frame format parser and encoder
 */
class FrameFormatConfig {
    static START_BYTE1 = 0x90;
    static START_BYTE2 = 0x91;
    static HEADER_SIZE = 2;
    static FOOTER_SIZE = 1;
    static OVERHEAD = 3;

    constructor(get_msg_length) {
        this.get_msg_length = get_msg_length;
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    reset() {
        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
        this.buffer = [];
        this.packet_size = 0;
        this.msg_id = 0;
    }

    parse_byte(byte) {
        const result = createFrameMsgInfo();

        switch (this.state) {
            case FrameFormatConfigParserState.LOOKING_FOR_START1:
                if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                }
                break;

            case FrameFormatConfigParserState.LOOKING_FOR_START2:
                if (byte === FrameFormatConfig.START_BYTE2) {
                    this.buffer.push(byte);
                    this.state = FrameFormatConfigParserState.GETTING_MSG_ID;
                } else if (byte === FrameFormatConfig.START_BYTE1) {
                    this.buffer = [byte];
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START2;
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_MSG_ID:
                this.buffer.push(byte);
                this.msg_id = byte;
                if (this.get_msg_length) {
                    const msg_length = this.get_msg_length(byte);
                    if (msg_length !== undefined) {
                        this.packet_size = FrameFormatConfig.OVERHEAD + msg_length;
                        this.state = FrameFormatConfigParserState.GETTING_PAYLOAD;
                    } else {
                        this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                    }
                } else {
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;

            case FrameFormatConfigParserState.GETTING_PAYLOAD:
                this.buffer.push(byte);

                if (this.buffer.length >= this.packet_size) {
                    const msg_length = this.packet_size - FrameFormatConfig.OVERHEAD;
                    const ck = fletcher_checksum(this.buffer, 2, 2 + msg_length + 1);
                    if (ck[0] === this.buffer[this.buffer.length - 2] && ck[1] === this.buffer[this.buffer.length - 1]) {
                        result.valid = true;
                        result.msg_id = this.msg_id;
                        result.msg_len = msg_length;
                        result.msg_data = new Uint8Array(this.buffer.slice(FrameFormatConfig.HEADER_SIZE, this.packet_size - FrameFormatConfig.FOOTER_SIZE));
                    }
                    this.state = FrameFormatConfigParserState.LOOKING_FOR_START1;
                }
                break;
        }

        return result;
    }

    static encode(msg_id, msg) {
        const output = [];
        output.push(FrameFormatConfig.START_BYTE1);
        output.push(FrameFormatConfig.START_BYTE2);
        output.push(msg_id);
        for (let i = 0; i < msg.length; i++) {
            output.push(msg[i]);
        }
        const ck = fletcher_checksum(output, 2, 2 + msg.length + 1);
        output.push(ck[0]);
        output.push(ck[1]);
        return new Uint8Array(output);
    }

    static validate_packet(buffer) {
        const result = createFrameMsgInfo();

        if (buffer.length < FrameFormatConfig.OVERHEAD) {
            return result;
        }

        if (buffer[0] !== FrameFormatConfig.START_BYTE1) {
            return result;
        }
        if (buffer[1] !== FrameFormatConfig.START_BYTE2) {
            return result;
        }

        const msg_length = buffer.length - FrameFormatConfig.OVERHEAD;

        const ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1);
        if (ck[0] === buffer[buffer.length - 2] && ck[1] === buffer[buffer.length - 1]) {
            result.valid = true;
            result.msg_id = buffer[2];
            result.msg_len = msg_length;
            result.msg_data = new Uint8Array(Array.prototype.slice.call(buffer, FrameFormatConfig.HEADER_SIZE, buffer.length - FrameFormatConfig.FOOTER_SIZE));
        }

        return result;
    }
}


// Exports
module.exports = {
    FrameFormatType,
    fletcher_checksum,
    createFrameMsgInfo,
    MinimalFrame,
    MinimalFrameParserState,
    BasicFrame,
    BasicFrameParserState,
    BasicFrameNoCrc,
    BasicFrameNoCrcParserState,
    TinyFrame,
    TinyFrameParserState,
    TinyFrameNoCrc,
    TinyFrameNoCrcParserState,
    MinimalFrameWithLen,
    MinimalFrameWithLenParserState,
    MinimalFrameWithLenNoCrc,
    MinimalFrameWithLenNoCrcParserState,
    BasicFrameWithLen,
    BasicFrameWithLenParserState,
    BasicFrameWithLenNoCrc,
    BasicFrameWithLenNoCrcParserState,
    TinyFrameWithLen,
    TinyFrameWithLenParserState,
    TinyFrameWithLenNoCrc,
    TinyFrameWithLenNoCrcParserState,
    MinimalFrameWithLen16,
    MinimalFrameWithLen16ParserState,
    MinimalFrameWithLen16NoCrc,
    MinimalFrameWithLen16NoCrcParserState,
    BasicFrameWithLen16,
    BasicFrameWithLen16ParserState,
    BasicFrameWithLen16NoCrc,
    BasicFrameWithLen16NoCrcParserState,
    TinyFrameWithLen16,
    TinyFrameWithLen16ParserState,
    TinyFrameWithLen16NoCrc,
    TinyFrameWithLen16NoCrcParserState,
    BasicFrameWithSysComp,
    BasicFrameWithSysCompParserState,
    UbxFrame,
    UbxFrameParserState,
    MavlinkV1Frame,
    MavlinkV1FrameParserState,
    MavlinkV2Frame,
    MavlinkV2FrameParserState,
    FrameFormatConfig,
    FrameFormatConfigParserState,
};
