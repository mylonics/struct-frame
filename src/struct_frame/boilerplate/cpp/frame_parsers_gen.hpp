/* Automatically generated frame parser header */
/* Generated by 0.0.1 at Sun Nov 30 16:50:10 2025. */

#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <functional>

namespace FrameParsers {

// Frame format type enumeration
enum class FrameFormatType {
    MINIMAL_FRAME = 0,
    BASIC_FRAME = 1,
    BASIC_FRAME_NO_CRC = 2,
    TINY_FRAME = 3,
    TINY_FRAME_NO_CRC = 4,
    MINIMAL_FRAME_WITH_LEN = 5,
    MINIMAL_FRAME_WITH_LEN_NO_CRC = 6,
    BASIC_FRAME_WITH_LEN = 7,
    BASIC_FRAME_WITH_LEN_NO_CRC = 8,
    TINY_FRAME_WITH_LEN = 9,
    TINY_FRAME_WITH_LEN_NO_CRC = 10,
    MINIMAL_FRAME_WITH_LEN16 = 11,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12,
    BASIC_FRAME_WITH_LEN16 = 13,
    BASIC_FRAME_WITH_LEN16_NO_CRC = 14,
    TINY_FRAME_WITH_LEN16 = 15,
    TINY_FRAME_WITH_LEN16_NO_CRC = 16,
    BASIC_FRAME_WITH_SYS_COMP = 17,
    UBX_FRAME = 18,
    MAVLINK_V1_FRAME = 19,
    MAVLINK_V2_FRAME = 20,
    FRAME_FORMAT_CONFIG = 21,
};

// Checksum result
struct FrameChecksum {
    uint8_t byte1;
    uint8_t byte2;
};

// Fletcher-16 checksum calculation
inline FrameChecksum fletcher_checksum(const uint8_t* data, size_t length) {
    FrameChecksum ck{0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = static_cast<uint8_t>(ck.byte1 + data[i]);
        ck.byte2 = static_cast<uint8_t>(ck.byte2 + ck.byte1);
    }
    return ck;
}

// Parse result
struct FrameMsgInfo {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;
    
    FrameMsgInfo() : valid(false), msg_id(0), msg_len(0), msg_data(nullptr) {}
    FrameMsgInfo(bool v, uint8_t id, size_t len, uint8_t* data)
        : valid(v), msg_id(id), msg_len(len), msg_data(data) {}
};

// =============================================================================
// MinimalFrame Frame Format
// =============================================================================

enum class MinimalFrameParserState : uint8_t {
    GettingMsgId = 0,
    GettingPayload = 1
};

// MinimalFrame constants
constexpr size_t MINIMAL_FRAME_HEADER_SIZE = 1;
constexpr size_t MINIMAL_FRAME_FOOTER_SIZE = 2;
constexpr size_t MINIMAL_FRAME_OVERHEAD = MINIMAL_FRAME_HEADER_SIZE + MINIMAL_FRAME_FOOTER_SIZE;

/**
 * MinimalFrame Encode Buffer
 */
class MinimalFrameEncodeBuffer {
public:
    MinimalFrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MINIMAL_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MINIMAL_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 0, msg_size + 1);
        packet_start[MINIMAL_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[MINIMAL_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MinimalFrame Frame Parser
 */
class MinimalFrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MinimalFrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MinimalFrameParserState::GettingMsgId),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MinimalFrameParserState::GettingMsgId;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MinimalFrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = MINIMAL_FRAME_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = MinimalFrameParserState::GettingPayload;
                    } else {
                        state_ = MinimalFrameParserState::GettingMsgId;
                    }
                } else {
                    state_ = MinimalFrameParserState::GettingMsgId;
                }
                break;
            }

            case MinimalFrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - MINIMAL_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 0, msg_length + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + MINIMAL_FRAME_HEADER_SIZE;
                    }
                    state_ = MinimalFrameParserState::GettingMsgId;
                }
                break;
        }

        return result;
    }

private:
    MinimalFrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MinimalFrame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t minimal_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MINIMAL_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_size + 1);
    buffer[MINIMAL_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrame packet in a buffer
 */
inline FrameMsgInfo minimal_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MINIMAL_FRAME_OVERHEAD) return result;


    size_t msg_length = length - MINIMAL_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + MINIMAL_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// BasicFrame Frame Format
// =============================================================================

enum class BasicFrameParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingPayload = 3
};

// BasicFrame constants
constexpr uint8_t BASIC_FRAME_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_START_BYTE2 = 0x91;
constexpr size_t BASIC_FRAME_HEADER_SIZE = 3;
constexpr size_t BASIC_FRAME_FOOTER_SIZE = 2;
constexpr size_t BASIC_FRAME_OVERHEAD = BASIC_FRAME_HEADER_SIZE + BASIC_FRAME_FOOTER_SIZE;

/**
 * BasicFrame Encode Buffer
 */
class BasicFrameEncodeBuffer {
public:
    BasicFrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_START_BYTE1;
        packet_start[1] = BASIC_FRAME_START_BYTE2;
        packet_start[2] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1);
        packet_start[BASIC_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[BASIC_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrame Frame Parser
 */
class BasicFrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameParserState::LookingForStart1:
                if (byte == BASIC_FRAME_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameParserState::LookingForStart2;
                }
                break;

            case BasicFrameParserState::LookingForStart2:
                if (byte == BASIC_FRAME_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameParserState::LookingForStart1;
                }
                break;

            case BasicFrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = BASIC_FRAME_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = BasicFrameParserState::GettingPayload;
                    } else {
                        state_ = BasicFrameParserState::LookingForStart1;
                    }
                } else {
                    state_ = BasicFrameParserState::LookingForStart1;
                }
                break;
            }

            case BasicFrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - BASIC_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + BASIC_FRAME_HEADER_SIZE;
                    }
                    state_ = BasicFrameParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_START_BYTE1;
    buffer[1] = BASIC_FRAME_START_BYTE2;
    buffer[2] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[BASIC_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrame packet in a buffer
 */
inline FrameMsgInfo basic_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// BasicFrameNoCrc Frame Format
// =============================================================================

enum class BasicFrameNoCrcParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingPayload = 3
};

// BasicFrameNoCrc constants
constexpr uint8_t BASIC_FRAME_NO_CRC_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_NO_CRC_START_BYTE2 = 0x95;
constexpr size_t BASIC_FRAME_NO_CRC_HEADER_SIZE = 3;
constexpr size_t BASIC_FRAME_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t BASIC_FRAME_NO_CRC_OVERHEAD = BASIC_FRAME_NO_CRC_HEADER_SIZE + BASIC_FRAME_NO_CRC_FOOTER_SIZE;

/**
 * BasicFrameNoCrc Encode Buffer
 */
class BasicFrameNoCrcEncodeBuffer {
public:
    BasicFrameNoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_NO_CRC_START_BYTE1;
        packet_start[1] = BASIC_FRAME_NO_CRC_START_BYTE2;
        packet_start[2] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameNoCrc Frame Parser
 */
class BasicFrameNoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameNoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameNoCrcParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameNoCrcParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameNoCrcParserState::LookingForStart1:
                if (byte == BASIC_FRAME_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameNoCrcParserState::LookingForStart2;
                }
                break;

            case BasicFrameNoCrcParserState::LookingForStart2:
                if (byte == BASIC_FRAME_NO_CRC_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameNoCrcParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameNoCrcParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameNoCrcParserState::LookingForStart1;
                }
                break;

            case BasicFrameNoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = BASIC_FRAME_NO_CRC_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = BasicFrameNoCrcParserState::GettingPayload;
                    } else {
                        state_ = BasicFrameNoCrcParserState::LookingForStart1;
                    }
                } else {
                    state_ = BasicFrameNoCrcParserState::LookingForStart1;
                }
                break;
            }

            case BasicFrameNoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - BASIC_FRAME_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + BASIC_FRAME_NO_CRC_HEADER_SIZE;
                    state_ = BasicFrameNoCrcParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameNoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameNoCrc packet in a buffer
 */
inline FrameMsgInfo basic_frame_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_NO_CRC_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_NO_CRC_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// TinyFrame Frame Format
// =============================================================================

enum class TinyFrameParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingPayload = 2
};

// TinyFrame constants
constexpr uint8_t TINY_FRAME_START_BYTE = 0x70;
constexpr size_t TINY_FRAME_HEADER_SIZE = 2;
constexpr size_t TINY_FRAME_FOOTER_SIZE = 2;
constexpr size_t TINY_FRAME_OVERHEAD = TINY_FRAME_HEADER_SIZE + TINY_FRAME_FOOTER_SIZE;

/**
 * TinyFrame Encode Buffer
 */
class TinyFrameEncodeBuffer {
public:
    TinyFrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_START_BYTE;
        packet_start[1] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1);
        packet_start[TINY_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[TINY_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrame Frame Parser
 */
class TinyFrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameParserState::LookingForStart:
                if (byte == TINY_FRAME_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameParserState::GettingMsgId;
                }
                break;

            case TinyFrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = TINY_FRAME_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = TinyFrameParserState::GettingPayload;
                    } else {
                        state_ = TinyFrameParserState::LookingForStart;
                    }
                } else {
                    state_ = TinyFrameParserState::LookingForStart;
                }
                break;
            }

            case TinyFrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - TINY_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + TINY_FRAME_HEADER_SIZE;
                    }
                    state_ = TinyFrameParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_START_BYTE;
    buffer[1] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1);
    buffer[TINY_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrame packet in a buffer
 */
inline FrameMsgInfo tiny_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// TinyFrameNoCrc Frame Format
// =============================================================================

enum class TinyFrameNoCrcParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingPayload = 2
};

// TinyFrameNoCrc constants
constexpr uint8_t TINY_FRAME_NO_CRC_START_BYTE = 0x72;
constexpr size_t TINY_FRAME_NO_CRC_HEADER_SIZE = 2;
constexpr size_t TINY_FRAME_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t TINY_FRAME_NO_CRC_OVERHEAD = TINY_FRAME_NO_CRC_HEADER_SIZE + TINY_FRAME_NO_CRC_FOOTER_SIZE;

/**
 * TinyFrameNoCrc Encode Buffer
 */
class TinyFrameNoCrcEncodeBuffer {
public:
    TinyFrameNoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_NO_CRC_START_BYTE;
        packet_start[1] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameNoCrc Frame Parser
 */
class TinyFrameNoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameNoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameNoCrcParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameNoCrcParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameNoCrcParserState::LookingForStart:
                if (byte == TINY_FRAME_NO_CRC_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameNoCrcParserState::GettingMsgId;
                }
                break;

            case TinyFrameNoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = TINY_FRAME_NO_CRC_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = TinyFrameNoCrcParserState::GettingPayload;
                    } else {
                        state_ = TinyFrameNoCrcParserState::LookingForStart;
                    }
                } else {
                    state_ = TinyFrameNoCrcParserState::LookingForStart;
                }
                break;
            }

            case TinyFrameNoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - TINY_FRAME_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + TINY_FRAME_NO_CRC_HEADER_SIZE;
                    state_ = TinyFrameNoCrcParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameNoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_NO_CRC_START_BYTE;
    buffer[1] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameNoCrc packet in a buffer
 */
inline FrameMsgInfo tiny_frame_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_NO_CRC_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// MinimalFrameWithLen Frame Format
// =============================================================================

enum class MinimalFrameWithLenParserState : uint8_t {
    GettingMsgId = 0,
    GettingLength = 1,
    GettingPayload = 2
};

// MinimalFrameWithLen constants
constexpr size_t MINIMAL_FRAME_WITH_LEN_HEADER_SIZE = 2;
constexpr size_t MINIMAL_FRAME_WITH_LEN_FOOTER_SIZE = 2;
constexpr size_t MINIMAL_FRAME_WITH_LEN_OVERHEAD = MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN_FOOTER_SIZE;
constexpr size_t MINIMAL_FRAME_WITH_LEN_LENGTH_BYTES = 1;

/**
 * MinimalFrameWithLen Encode Buffer
 */
class MinimalFrameWithLenEncodeBuffer {
public:
    MinimalFrameWithLenEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MINIMAL_FRAME_WITH_LEN_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = msg_id;
        packet_start[1] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 0, msg_size + 1 + 1);
        packet_start[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MinimalFrameWithLen Frame Parser
 */
class MinimalFrameWithLenParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MinimalFrameWithLenParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MinimalFrameWithLenParserState::GettingMsgId),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MinimalFrameWithLenParserState::GettingMsgId;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MinimalFrameWithLenParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MinimalFrameWithLenParserState::GettingLength;
                break;
            }

            case MinimalFrameWithLenParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = MINIMAL_FRAME_WITH_LEN_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = MinimalFrameWithLenParserState::GettingPayload;
                } else {
                    state_ = MinimalFrameWithLenParserState::GettingMsgId;
                }
                break;

            case MinimalFrameWithLenParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - MINIMAL_FRAME_WITH_LEN_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 0, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE;
                    }
                    state_ = MinimalFrameWithLenParserState::GettingMsgId;
                }
                break;
        }

        return result;
    }

private:
    MinimalFrameWithLenParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MinimalFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t minimal_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = msg_id;
    buffer[1] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_size + 1 + 1);
    buffer[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen packet in a buffer
 */
inline FrameMsgInfo minimal_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MINIMAL_FRAME_WITH_LEN_OVERHEAD) return result;


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + MINIMAL_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// MinimalFrameWithLenNoCrc Frame Format
// =============================================================================

enum class MinimalFrameWithLenNoCrcParserState : uint8_t {
    GettingMsgId = 0,
    GettingLength = 1,
    GettingPayload = 2
};

// MinimalFrameWithLenNoCrc constants
constexpr size_t MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE = 2;
constexpr size_t MINIMAL_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD = MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE;
constexpr size_t MINIMAL_FRAME_WITH_LEN_NO_CRC_LENGTH_BYTES = 1;

/**
 * MinimalFrameWithLenNoCrc Encode Buffer
 */
class MinimalFrameWithLenNoCrcEncodeBuffer {
public:
    MinimalFrameWithLenNoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = msg_id;
        packet_start[1] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MinimalFrameWithLenNoCrc Frame Parser
 */
class MinimalFrameWithLenNoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MinimalFrameWithLenNoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MinimalFrameWithLenNoCrcParserState::GettingMsgId),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MinimalFrameWithLenNoCrcParserState::GettingMsgId;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MinimalFrameWithLenNoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MinimalFrameWithLenNoCrcParserState::GettingLength;
                break;
            }

            case MinimalFrameWithLenNoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = MinimalFrameWithLenNoCrcParserState::GettingPayload;
                } else {
                    state_ = MinimalFrameWithLenNoCrcParserState::GettingMsgId;
                }
                break;

            case MinimalFrameWithLenNoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                    state_ = MinimalFrameWithLenNoCrcParserState::GettingMsgId;
                }
                break;
        }

        return result;
    }

private:
    MinimalFrameWithLenNoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MinimalFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t minimal_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = msg_id;
    buffer[1] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLenNoCrc packet in a buffer
 */
inline FrameMsgInfo minimal_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD) return result;


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[0];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + MINIMAL_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// BasicFrameWithLen Frame Format
// =============================================================================

enum class BasicFrameWithLenParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingLength = 3,
    GettingPayload = 4
};

// BasicFrameWithLen constants
constexpr uint8_t BASIC_FRAME_WITH_LEN_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_WITH_LEN_START_BYTE2 = 0x92;
constexpr size_t BASIC_FRAME_WITH_LEN_HEADER_SIZE = 4;
constexpr size_t BASIC_FRAME_WITH_LEN_FOOTER_SIZE = 2;
constexpr size_t BASIC_FRAME_WITH_LEN_OVERHEAD = BASIC_FRAME_WITH_LEN_HEADER_SIZE + BASIC_FRAME_WITH_LEN_FOOTER_SIZE;
constexpr size_t BASIC_FRAME_WITH_LEN_LENGTH_BYTES = 1;

/**
 * BasicFrameWithLen Encode Buffer
 */
class BasicFrameWithLenEncodeBuffer {
public:
    BasicFrameWithLenEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_WITH_LEN_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_WITH_LEN_START_BYTE1;
        packet_start[1] = BASIC_FRAME_WITH_LEN_START_BYTE2;
        packet_start[2] = msg_id;
        packet_start[3] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1 + 1);
        packet_start[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameWithLen Frame Parser
 */
class BasicFrameWithLenParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameWithLenParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameWithLenParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameWithLenParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameWithLenParserState::LookingForStart1:
                if (byte == BASIC_FRAME_WITH_LEN_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLenParserState::LookingForStart2;
                }
                break;

            case BasicFrameWithLenParserState::LookingForStart2:
                if (byte == BASIC_FRAME_WITH_LEN_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameWithLenParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_WITH_LEN_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLenParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameWithLenParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLenParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = BasicFrameWithLenParserState::GettingLength;
                break;
            }

            case BasicFrameWithLenParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = BASIC_FRAME_WITH_LEN_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = BasicFrameWithLenParserState::GettingPayload;
                } else {
                    state_ = BasicFrameWithLenParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLenParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - BASIC_FRAME_WITH_LEN_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + BASIC_FRAME_WITH_LEN_HEADER_SIZE;
                    }
                    state_ = BasicFrameWithLenParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameWithLenParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_WITH_LEN_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1 + 1);
    buffer[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen packet in a buffer
 */
inline FrameMsgInfo basic_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_WITH_LEN_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_WITH_LEN_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_WITH_LEN_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_WITH_LEN_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// BasicFrameWithLenNoCrc Frame Format
// =============================================================================

enum class BasicFrameWithLenNoCrcParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingLength = 3,
    GettingPayload = 4
};

// BasicFrameWithLenNoCrc constants
constexpr uint8_t BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2 = 0x96;
constexpr size_t BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE = 4;
constexpr size_t BASIC_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD = BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + BASIC_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE;
constexpr size_t BASIC_FRAME_WITH_LEN_NO_CRC_LENGTH_BYTES = 1;

/**
 * BasicFrameWithLenNoCrc Encode Buffer
 */
class BasicFrameWithLenNoCrcEncodeBuffer {
public:
    BasicFrameWithLenNoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1;
        packet_start[1] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2;
        packet_start[2] = msg_id;
        packet_start[3] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameWithLenNoCrc Frame Parser
 */
class BasicFrameWithLenNoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameWithLenNoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameWithLenNoCrcParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameWithLenNoCrcParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameWithLenNoCrcParserState::LookingForStart1:
                if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLenNoCrcParserState::LookingForStart2;
                }
                break;

            case BasicFrameWithLenNoCrcParserState::LookingForStart2:
                if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameWithLenNoCrcParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLenNoCrcParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameWithLenNoCrcParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLenNoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = BasicFrameWithLenNoCrcParserState::GettingLength;
                break;
            }

            case BasicFrameWithLenNoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = BasicFrameWithLenNoCrcParserState::GettingPayload;
                } else {
                    state_ = BasicFrameWithLenNoCrcParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLenNoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                    state_ = BasicFrameWithLenNoCrcParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameWithLenNoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameWithLenNoCrc packet in a buffer
 */
inline FrameMsgInfo basic_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_WITH_LEN_NO_CRC_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// TinyFrameWithLen Frame Format
// =============================================================================

enum class TinyFrameWithLenParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// TinyFrameWithLen constants
constexpr uint8_t TINY_FRAME_WITH_LEN_START_BYTE = 0x71;
constexpr size_t TINY_FRAME_WITH_LEN_HEADER_SIZE = 3;
constexpr size_t TINY_FRAME_WITH_LEN_FOOTER_SIZE = 2;
constexpr size_t TINY_FRAME_WITH_LEN_OVERHEAD = TINY_FRAME_WITH_LEN_HEADER_SIZE + TINY_FRAME_WITH_LEN_FOOTER_SIZE;
constexpr size_t TINY_FRAME_WITH_LEN_LENGTH_BYTES = 1;

/**
 * TinyFrameWithLen Encode Buffer
 */
class TinyFrameWithLenEncodeBuffer {
public:
    TinyFrameWithLenEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_WITH_LEN_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_WITH_LEN_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1 + 1);
        packet_start[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameWithLen Frame Parser
 */
class TinyFrameWithLenParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameWithLenParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameWithLenParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameWithLenParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameWithLenParserState::LookingForStart:
                if (byte == TINY_FRAME_WITH_LEN_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameWithLenParserState::GettingMsgId;
                }
                break;

            case TinyFrameWithLenParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = TinyFrameWithLenParserState::GettingLength;
                break;
            }

            case TinyFrameWithLenParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = TINY_FRAME_WITH_LEN_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = TinyFrameWithLenParserState::GettingPayload;
                } else {
                    state_ = TinyFrameWithLenParserState::LookingForStart;
                }
                break;

            case TinyFrameWithLenParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - TINY_FRAME_WITH_LEN_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + TINY_FRAME_WITH_LEN_HEADER_SIZE;
                    }
                    state_ = TinyFrameWithLenParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameWithLenParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameWithLen format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_with_len_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_WITH_LEN_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_WITH_LEN_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_WITH_LEN_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen packet in a buffer
 */
inline FrameMsgInfo tiny_frame_with_len_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_WITH_LEN_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_WITH_LEN_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_WITH_LEN_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_WITH_LEN_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// TinyFrameWithLenNoCrc Frame Format
// =============================================================================

enum class TinyFrameWithLenNoCrcParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// TinyFrameWithLenNoCrc constants
constexpr uint8_t TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE = 0x73;
constexpr size_t TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE = 3;
constexpr size_t TINY_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD = TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE + TINY_FRAME_WITH_LEN_NO_CRC_FOOTER_SIZE;
constexpr size_t TINY_FRAME_WITH_LEN_NO_CRC_LENGTH_BYTES = 1;

/**
 * TinyFrameWithLenNoCrc Encode Buffer
 */
class TinyFrameWithLenNoCrcEncodeBuffer {
public:
    TinyFrameWithLenNoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameWithLenNoCrc Frame Parser
 */
class TinyFrameWithLenNoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameWithLenNoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameWithLenNoCrcParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameWithLenNoCrcParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameWithLenNoCrcParserState::LookingForStart:
                if (byte == TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameWithLenNoCrcParserState::GettingMsgId;
                }
                break;

            case TinyFrameWithLenNoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = TinyFrameWithLenNoCrcParserState::GettingLength;
                break;
            }

            case TinyFrameWithLenNoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = TinyFrameWithLenNoCrcParserState::GettingPayload;
                } else {
                    state_ = TinyFrameWithLenNoCrcParserState::LookingForStart;
                }
                break;

            case TinyFrameWithLenNoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE;
                    state_ = TinyFrameWithLenNoCrcParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameWithLenNoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameWithLenNoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_with_len_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameWithLenNoCrc packet in a buffer
 */
inline FrameMsgInfo tiny_frame_with_len_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_WITH_LEN_NO_CRC_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_WITH_LEN_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_WITH_LEN_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// MinimalFrameWithLen16 Frame Format
// =============================================================================

enum class MinimalFrameWithLen16ParserState : uint8_t {
    GettingMsgId = 0,
    GettingLength = 1,
    GettingPayload = 2
};

// MinimalFrameWithLen16 constants
constexpr size_t MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE = 3;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_FOOTER_SIZE = 2;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_OVERHEAD = MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN16_FOOTER_SIZE;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_LENGTH_BYTES = 2;

/**
 * MinimalFrameWithLen16 Encode Buffer
 */
class MinimalFrameWithLen16EncodeBuffer {
public:
    MinimalFrameWithLen16EncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MINIMAL_FRAME_WITH_LEN16_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = msg_id;
        packet_start[1] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[2] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 0, msg_size + 1 + 2);
        packet_start[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MinimalFrameWithLen16 Frame Parser
 */
class MinimalFrameWithLen16Parser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MinimalFrameWithLen16Parser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MinimalFrameWithLen16ParserState::GettingMsgId),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MinimalFrameWithLen16ParserState::GettingMsgId;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MinimalFrameWithLen16ParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MinimalFrameWithLen16ParserState::GettingLength;
                break;
            }

            case MinimalFrameWithLen16ParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 2) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = MINIMAL_FRAME_WITH_LEN16_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = MinimalFrameWithLen16ParserState::GettingPayload;
                    } else {
                        state_ = MinimalFrameWithLen16ParserState::GettingMsgId;
                    }
                }
                break;

            case MinimalFrameWithLen16ParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - MINIMAL_FRAME_WITH_LEN16_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 0, msg_length + 1 + 2);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE;
                    }
                    state_ = MinimalFrameWithLen16ParserState::GettingMsgId;
                }
                break;
        }

        return result;
    }

private:
    MinimalFrameWithLen16ParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MinimalFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t minimal_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = msg_id;
    buffer[1] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[2] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_size + 1 + 2);
    buffer[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen16 packet in a buffer
 */
inline FrameMsgInfo minimal_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MINIMAL_FRAME_WITH_LEN16_OVERHEAD) return result;


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN16_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 0, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[0];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + MINIMAL_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// MinimalFrameWithLen16NoCrc Frame Format
// =============================================================================

enum class MinimalFrameWithLen16NoCrcParserState : uint8_t {
    GettingMsgId = 0,
    GettingLength = 1,
    GettingPayload = 2
};

// MinimalFrameWithLen16NoCrc constants
constexpr size_t MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE = 3;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD = MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + MINIMAL_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE;
constexpr size_t MINIMAL_FRAME_WITH_LEN16_NO_CRC_LENGTH_BYTES = 2;

/**
 * MinimalFrameWithLen16NoCrc Encode Buffer
 */
class MinimalFrameWithLen16NoCrcEncodeBuffer {
public:
    MinimalFrameWithLen16NoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = msg_id;
        packet_start[1] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[2] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MinimalFrameWithLen16NoCrc Frame Parser
 */
class MinimalFrameWithLen16NoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MinimalFrameWithLen16NoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MinimalFrameWithLen16NoCrcParserState::GettingMsgId),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MinimalFrameWithLen16NoCrcParserState::GettingMsgId;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MinimalFrameWithLen16NoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MinimalFrameWithLen16NoCrcParserState::GettingLength;
                break;
            }

            case MinimalFrameWithLen16NoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 2) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = MinimalFrameWithLen16NoCrcParserState::GettingPayload;
                    } else {
                        state_ = MinimalFrameWithLen16NoCrcParserState::GettingMsgId;
                    }
                }
                break;

            case MinimalFrameWithLen16NoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                    state_ = MinimalFrameWithLen16NoCrcParserState::GettingMsgId;
                }
                break;
        }

        return result;
    }

private:
    MinimalFrameWithLen16NoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MinimalFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t minimal_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = msg_id;
    buffer[1] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[2] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete MinimalFrameWithLen16NoCrc packet in a buffer
 */
inline FrameMsgInfo minimal_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) return result;


    size_t msg_length = length - MINIMAL_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[0];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + MINIMAL_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// BasicFrameWithLen16 Frame Format
// =============================================================================

enum class BasicFrameWithLen16ParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingLength = 3,
    GettingPayload = 4
};

// BasicFrameWithLen16 constants
constexpr uint8_t BASIC_FRAME_WITH_LEN16_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_WITH_LEN16_START_BYTE2 = 0x93;
constexpr size_t BASIC_FRAME_WITH_LEN16_HEADER_SIZE = 5;
constexpr size_t BASIC_FRAME_WITH_LEN16_FOOTER_SIZE = 2;
constexpr size_t BASIC_FRAME_WITH_LEN16_OVERHEAD = BASIC_FRAME_WITH_LEN16_HEADER_SIZE + BASIC_FRAME_WITH_LEN16_FOOTER_SIZE;
constexpr size_t BASIC_FRAME_WITH_LEN16_LENGTH_BYTES = 2;

/**
 * BasicFrameWithLen16 Encode Buffer
 */
class BasicFrameWithLen16EncodeBuffer {
public:
    BasicFrameWithLen16EncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_WITH_LEN16_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_WITH_LEN16_START_BYTE1;
        packet_start[1] = BASIC_FRAME_WITH_LEN16_START_BYTE2;
        packet_start[2] = msg_id;
        packet_start[3] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[4] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1 + 2);
        packet_start[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameWithLen16 Frame Parser
 */
class BasicFrameWithLen16Parser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameWithLen16Parser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameWithLen16ParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameWithLen16ParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameWithLen16ParserState::LookingForStart1:
                if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLen16ParserState::LookingForStart2;
                }
                break;

            case BasicFrameWithLen16ParserState::LookingForStart2:
                if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameWithLen16ParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_WITH_LEN16_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLen16ParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameWithLen16ParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLen16ParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = BasicFrameWithLen16ParserState::GettingLength;
                break;
            }

            case BasicFrameWithLen16ParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 4) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = BASIC_FRAME_WITH_LEN16_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = BasicFrameWithLen16ParserState::GettingPayload;
                    } else {
                        state_ = BasicFrameWithLen16ParserState::LookingForStart1;
                    }
                }
                break;

            case BasicFrameWithLen16ParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - BASIC_FRAME_WITH_LEN16_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1 + 2);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + BASIC_FRAME_WITH_LEN16_HEADER_SIZE;
                    }
                    state_ = BasicFrameWithLen16ParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameWithLen16ParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_WITH_LEN16_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN16_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[4] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1 + 2);
    buffer[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen16 packet in a buffer
 */
inline FrameMsgInfo basic_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_WITH_LEN16_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_WITH_LEN16_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_WITH_LEN16_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_WITH_LEN16_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// BasicFrameWithLen16NoCrc Frame Format
// =============================================================================

enum class BasicFrameWithLen16NoCrcParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingLength = 3,
    GettingPayload = 4
};

// BasicFrameWithLen16NoCrc constants
constexpr uint8_t BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2 = 0x97;
constexpr size_t BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE = 5;
constexpr size_t BASIC_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD = BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + BASIC_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE;
constexpr size_t BASIC_FRAME_WITH_LEN16_NO_CRC_LENGTH_BYTES = 2;

/**
 * BasicFrameWithLen16NoCrc Encode Buffer
 */
class BasicFrameWithLen16NoCrcEncodeBuffer {
public:
    BasicFrameWithLen16NoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1;
        packet_start[1] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2;
        packet_start[2] = msg_id;
        packet_start[3] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[4] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameWithLen16NoCrc Frame Parser
 */
class BasicFrameWithLen16NoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameWithLen16NoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameWithLen16NoCrcParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameWithLen16NoCrcParserState::LookingForStart1:
                if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart2;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState::LookingForStart2:
                if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameWithLen16NoCrcParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithLen16NoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = BasicFrameWithLen16NoCrcParserState::GettingLength;
                break;
            }

            case BasicFrameWithLen16NoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 4) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = BasicFrameWithLen16NoCrcParserState::GettingPayload;
                    } else {
                        state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart1;
                    }
                }
                break;

            case BasicFrameWithLen16NoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                    state_ = BasicFrameWithLen16NoCrcParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameWithLen16NoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[4] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete BasicFrameWithLen16NoCrc packet in a buffer
 */
inline FrameMsgInfo basic_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_WITH_LEN16_NO_CRC_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[2];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// TinyFrameWithLen16 Frame Format
// =============================================================================

enum class TinyFrameWithLen16ParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// TinyFrameWithLen16 constants
constexpr uint8_t TINY_FRAME_WITH_LEN16_START_BYTE = 0x74;
constexpr size_t TINY_FRAME_WITH_LEN16_HEADER_SIZE = 4;
constexpr size_t TINY_FRAME_WITH_LEN16_FOOTER_SIZE = 2;
constexpr size_t TINY_FRAME_WITH_LEN16_OVERHEAD = TINY_FRAME_WITH_LEN16_HEADER_SIZE + TINY_FRAME_WITH_LEN16_FOOTER_SIZE;
constexpr size_t TINY_FRAME_WITH_LEN16_LENGTH_BYTES = 2;

/**
 * TinyFrameWithLen16 Encode Buffer
 */
class TinyFrameWithLen16EncodeBuffer {
public:
    TinyFrameWithLen16EncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_WITH_LEN16_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1 + 2);
        packet_start[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameWithLen16 Frame Parser
 */
class TinyFrameWithLen16Parser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameWithLen16Parser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameWithLen16ParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameWithLen16ParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameWithLen16ParserState::LookingForStart:
                if (byte == TINY_FRAME_WITH_LEN16_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameWithLen16ParserState::GettingMsgId;
                }
                break;

            case TinyFrameWithLen16ParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = TinyFrameWithLen16ParserState::GettingLength;
                break;
            }

            case TinyFrameWithLen16ParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 3) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = TinyFrameWithLen16ParserState::GettingPayload;
                    } else {
                        state_ = TinyFrameWithLen16ParserState::LookingForStart;
                    }
                }
                break;

            case TinyFrameWithLen16ParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - TINY_FRAME_WITH_LEN16_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1 + 2);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + TINY_FRAME_WITH_LEN16_HEADER_SIZE;
                    }
                    state_ = TinyFrameWithLen16ParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameWithLen16ParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameWithLen16 format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_with_len16_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN16_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_WITH_LEN16_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1 + 2);
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[TINY_FRAME_WITH_LEN16_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen16 packet in a buffer
 */
inline FrameMsgInfo tiny_frame_with_len16_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_WITH_LEN16_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_WITH_LEN16_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_WITH_LEN16_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1 + 2);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_WITH_LEN16_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// TinyFrameWithLen16NoCrc Frame Format
// =============================================================================

enum class TinyFrameWithLen16NoCrcParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// TinyFrameWithLen16NoCrc constants
constexpr uint8_t TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE = 0x75;
constexpr size_t TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE = 4;
constexpr size_t TINY_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE = 0;
constexpr size_t TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD = TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE + TINY_FRAME_WITH_LEN16_NO_CRC_FOOTER_SIZE;
constexpr size_t TINY_FRAME_WITH_LEN16_NO_CRC_LENGTH_BYTES = 2;

/**
 * TinyFrameWithLen16NoCrc Encode Buffer
 */
class TinyFrameWithLen16NoCrcEncodeBuffer {
public:
    TinyFrameWithLen16NoCrcEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size & 0xFF);
        packet_start[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
        }


        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * TinyFrameWithLen16NoCrc Frame Parser
 */
class TinyFrameWithLen16NoCrcParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    TinyFrameWithLen16NoCrcParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(TinyFrameWithLen16NoCrcParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          length_lo_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = TinyFrameWithLen16NoCrcParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case TinyFrameWithLen16NoCrcParserState::LookingForStart:
                if (byte == TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = TinyFrameWithLen16NoCrcParserState::GettingMsgId;
                }
                break;

            case TinyFrameWithLen16NoCrcParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = TinyFrameWithLen16NoCrcParserState::GettingLength;
                break;
            }

            case TinyFrameWithLen16NoCrcParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                if (buffer_index_ == 3) {
                    length_lo_ = byte;
                } else {
                    msg_length_ = length_lo_ | (static_cast<size_t>(byte) << 8);
                    packet_size_ = TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_length_;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = TinyFrameWithLen16NoCrcParserState::GettingPayload;
                    } else {
                        state_ = TinyFrameWithLen16NoCrcParserState::LookingForStart;
                    }
                }
                break;

            case TinyFrameWithLen16NoCrcParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    result.valid = true;
                    result.msg_id = msg_id_;
                    result.msg_len = packet_size_ - TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;
                    result.msg_data = buffer_ + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE;
                    state_ = TinyFrameWithLen16NoCrcParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    TinyFrameWithLen16NoCrcParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    uint8_t length_lo_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with TinyFrameWithLen16NoCrc format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t tiny_frame_with_len16_no_crc_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size & 0xFF);
    buffer[3] = static_cast<uint8_t>((msg_size >> 8) & 0xFF);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE, msg, msg_size);
    }


    return total_size;
}

/**
 * Validate a complete TinyFrameWithLen16NoCrc packet in a buffer
 */
inline FrameMsgInfo tiny_frame_with_len16_no_crc_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD) return result;

    if (buffer[0] != TINY_FRAME_WITH_LEN16_NO_CRC_START_BYTE) return result;

    size_t msg_length = length - TINY_FRAME_WITH_LEN16_NO_CRC_OVERHEAD;

    result.valid = true;
    result.msg_id = buffer[1];
    result.msg_len = msg_length;
    result.msg_data = const_cast<uint8_t*>(buffer + TINY_FRAME_WITH_LEN16_NO_CRC_HEADER_SIZE);

    return result;
}


// =============================================================================
// BasicFrameWithSysComp Frame Format
// =============================================================================

enum class BasicFrameWithSysCompParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingPayload = 3
};

// BasicFrameWithSysComp constants
constexpr uint8_t BASIC_FRAME_WITH_SYS_COMP_START_BYTE1 = 0x90;
constexpr uint8_t BASIC_FRAME_WITH_SYS_COMP_START_BYTE2 = 0x94;
constexpr size_t BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE = 3;
constexpr size_t BASIC_FRAME_WITH_SYS_COMP_FOOTER_SIZE = 2;
constexpr size_t BASIC_FRAME_WITH_SYS_COMP_OVERHEAD = BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + BASIC_FRAME_WITH_SYS_COMP_FOOTER_SIZE;

/**
 * BasicFrameWithSysComp Encode Buffer
 */
class BasicFrameWithSysCompEncodeBuffer {
public:
    BasicFrameWithSysCompEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = BASIC_FRAME_WITH_SYS_COMP_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE1;
        packet_start[1] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE2;
        packet_start[2] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1);
        packet_start[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * BasicFrameWithSysComp Frame Parser
 */
class BasicFrameWithSysCompParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    BasicFrameWithSysCompParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(BasicFrameWithSysCompParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = BasicFrameWithSysCompParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case BasicFrameWithSysCompParserState::LookingForStart1:
                if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithSysCompParserState::LookingForStart2;
                }
                break;

            case BasicFrameWithSysCompParserState::LookingForStart2:
                if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = BasicFrameWithSysCompParserState::GettingMsgId;
                } else if (byte == BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = BasicFrameWithSysCompParserState::LookingForStart2;
                } else {
                    state_ = BasicFrameWithSysCompParserState::LookingForStart1;
                }
                break;

            case BasicFrameWithSysCompParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = BASIC_FRAME_WITH_SYS_COMP_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = BasicFrameWithSysCompParserState::GettingPayload;
                    } else {
                        state_ = BasicFrameWithSysCompParserState::LookingForStart1;
                    }
                } else {
                    state_ = BasicFrameWithSysCompParserState::LookingForStart1;
                }
                break;
            }

            case BasicFrameWithSysCompParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - BASIC_FRAME_WITH_SYS_COMP_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE;
                    }
                    state_ = BasicFrameWithSysCompParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    BasicFrameWithSysCompParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with BasicFrameWithSysComp format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t basic_frame_with_sys_comp_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = BASIC_FRAME_WITH_SYS_COMP_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE1;
    buffer[1] = BASIC_FRAME_WITH_SYS_COMP_START_BYTE2;
    buffer[2] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete BasicFrameWithSysComp packet in a buffer
 */
inline FrameMsgInfo basic_frame_with_sys_comp_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < BASIC_FRAME_WITH_SYS_COMP_OVERHEAD) return result;

    if (buffer[0] != BASIC_FRAME_WITH_SYS_COMP_START_BYTE1) return result;
    if (buffer[1] != BASIC_FRAME_WITH_SYS_COMP_START_BYTE2) return result;

    size_t msg_length = length - BASIC_FRAME_WITH_SYS_COMP_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + BASIC_FRAME_WITH_SYS_COMP_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// UbxFrame Frame Format
// =============================================================================

enum class UbxFrameParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingLength = 3,
    GettingPayload = 4
};

// UbxFrame constants
constexpr uint8_t UBX_FRAME_START_BYTE1 = 0xB5;
constexpr uint8_t UBX_FRAME_START_BYTE2 = 0x62;
constexpr size_t UBX_FRAME_HEADER_SIZE = 5;
constexpr size_t UBX_FRAME_FOOTER_SIZE = 2;
constexpr size_t UBX_FRAME_OVERHEAD = UBX_FRAME_HEADER_SIZE + UBX_FRAME_FOOTER_SIZE;
constexpr size_t UBX_FRAME_LENGTH_BYTES = 1;

/**
 * UbxFrame Encode Buffer
 */
class UbxFrameEncodeBuffer {
public:
    UbxFrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = UBX_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = UBX_FRAME_START_BYTE1;
        packet_start[1] = UBX_FRAME_START_BYTE2;
        packet_start[2] = msg_id;
        packet_start[3] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + UBX_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1 + 1);
        packet_start[UBX_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[UBX_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * UbxFrame Frame Parser
 */
class UbxFrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    UbxFrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(UbxFrameParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = UbxFrameParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case UbxFrameParserState::LookingForStart1:
                if (byte == UBX_FRAME_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = UbxFrameParserState::LookingForStart2;
                }
                break;

            case UbxFrameParserState::LookingForStart2:
                if (byte == UBX_FRAME_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = UbxFrameParserState::GettingMsgId;
                } else if (byte == UBX_FRAME_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = UbxFrameParserState::LookingForStart2;
                } else {
                    state_ = UbxFrameParserState::LookingForStart1;
                }
                break;

            case UbxFrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = UbxFrameParserState::GettingLength;
                break;
            }

            case UbxFrameParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = UBX_FRAME_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = UbxFrameParserState::GettingPayload;
                } else {
                    state_ = UbxFrameParserState::LookingForStart1;
                }
                break;

            case UbxFrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - UBX_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + UBX_FRAME_HEADER_SIZE;
                    }
                    state_ = UbxFrameParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    UbxFrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with UbxFrame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t ubx_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = UBX_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = UBX_FRAME_START_BYTE1;
    buffer[1] = UBX_FRAME_START_BYTE2;
    buffer[2] = msg_id;
    buffer[3] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + UBX_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1 + 1);
    buffer[UBX_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[UBX_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete UbxFrame packet in a buffer
 */
inline FrameMsgInfo ubx_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < UBX_FRAME_OVERHEAD) return result;

    if (buffer[0] != UBX_FRAME_START_BYTE1) return result;
    if (buffer[1] != UBX_FRAME_START_BYTE2) return result;

    size_t msg_length = length - UBX_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + UBX_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// MavlinkV1Frame Frame Format
// =============================================================================

enum class MavlinkV1FrameParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// MavlinkV1Frame constants
constexpr uint8_t MAVLINK_V1_FRAME_START_BYTE = 0xFE;
constexpr size_t MAVLINK_V1_FRAME_HEADER_SIZE = 3;
constexpr size_t MAVLINK_V1_FRAME_FOOTER_SIZE = 2;
constexpr size_t MAVLINK_V1_FRAME_OVERHEAD = MAVLINK_V1_FRAME_HEADER_SIZE + MAVLINK_V1_FRAME_FOOTER_SIZE;
constexpr size_t MAVLINK_V1_FRAME_LENGTH_BYTES = 1;

/**
 * MavlinkV1Frame Encode Buffer
 */
class MavlinkV1FrameEncodeBuffer {
public:
    MavlinkV1FrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MAVLINK_V1_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = MAVLINK_V1_FRAME_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MAVLINK_V1_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1 + 1);
        packet_start[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MavlinkV1Frame Frame Parser
 */
class MavlinkV1FrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MavlinkV1FrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MavlinkV1FrameParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MavlinkV1FrameParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MavlinkV1FrameParserState::LookingForStart:
                if (byte == MAVLINK_V1_FRAME_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = MavlinkV1FrameParserState::GettingMsgId;
                }
                break;

            case MavlinkV1FrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MavlinkV1FrameParserState::GettingLength;
                break;
            }

            case MavlinkV1FrameParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = MAVLINK_V1_FRAME_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = MavlinkV1FrameParserState::GettingPayload;
                } else {
                    state_ = MavlinkV1FrameParserState::LookingForStart;
                }
                break;

            case MavlinkV1FrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - MAVLINK_V1_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + MAVLINK_V1_FRAME_HEADER_SIZE;
                    }
                    state_ = MavlinkV1FrameParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    MavlinkV1FrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MavlinkV1Frame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t mavlink_v1_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MAVLINK_V1_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = MAVLINK_V1_FRAME_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MAVLINK_V1_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MAVLINK_V1_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MavlinkV1Frame packet in a buffer
 */
inline FrameMsgInfo mavlink_v1_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MAVLINK_V1_FRAME_OVERHEAD) return result;

    if (buffer[0] != MAVLINK_V1_FRAME_START_BYTE) return result;

    size_t msg_length = length - MAVLINK_V1_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + MAVLINK_V1_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// MavlinkV2Frame Frame Format
// =============================================================================

enum class MavlinkV2FrameParserState : uint8_t {
    LookingForStart = 0,
    GettingMsgId = 1,
    GettingLength = 2,
    GettingPayload = 3
};

// MavlinkV2Frame constants
constexpr uint8_t MAVLINK_V2_FRAME_START_BYTE = 0xFD;
constexpr size_t MAVLINK_V2_FRAME_HEADER_SIZE = 5;
constexpr size_t MAVLINK_V2_FRAME_FOOTER_SIZE = 2;
constexpr size_t MAVLINK_V2_FRAME_OVERHEAD = MAVLINK_V2_FRAME_HEADER_SIZE + MAVLINK_V2_FRAME_FOOTER_SIZE;
constexpr size_t MAVLINK_V2_FRAME_LENGTH_BYTES = 1;

/**
 * MavlinkV2Frame Encode Buffer
 */
class MavlinkV2FrameEncodeBuffer {
public:
    MavlinkV2FrameEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = MAVLINK_V2_FRAME_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = MAVLINK_V2_FRAME_START_BYTE;
        packet_start[1] = msg_id;
        packet_start[2] = static_cast<uint8_t>(msg_size);

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + MAVLINK_V2_FRAME_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 1, msg_size + 1 + 1);
        packet_start[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * MavlinkV2Frame Frame Parser
 */
class MavlinkV2FrameParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    MavlinkV2FrameParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(MavlinkV2FrameParserState::LookingForStart),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          msg_length_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = MavlinkV2FrameParserState::LookingForStart;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
        msg_length_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case MavlinkV2FrameParserState::LookingForStart:
                if (byte == MAVLINK_V2_FRAME_START_BYTE) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = MavlinkV2FrameParserState::GettingMsgId;
                }
                break;

            case MavlinkV2FrameParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                state_ = MavlinkV2FrameParserState::GettingLength;
                break;
            }

            case MavlinkV2FrameParserState::GettingLength:
                buffer_[buffer_index_++] = byte;
                msg_length_ = byte;
                packet_size_ = MAVLINK_V2_FRAME_OVERHEAD + msg_length_;
                if (packet_size_ <= buffer_max_size_) {
                    state_ = MavlinkV2FrameParserState::GettingPayload;
                } else {
                    state_ = MavlinkV2FrameParserState::LookingForStart;
                }
                break;

            case MavlinkV2FrameParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - MAVLINK_V2_FRAME_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 1, msg_length + 1 + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + MAVLINK_V2_FRAME_HEADER_SIZE;
                    }
                    state_ = MavlinkV2FrameParserState::LookingForStart;
                }
                break;
        }

        return result;
    }

private:
    MavlinkV2FrameParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    size_t msg_length_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with MavlinkV2Frame format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t mavlink_v2_frame_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = MAVLINK_V2_FRAME_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = MAVLINK_V2_FRAME_START_BYTE;
    buffer[1] = msg_id;
    buffer[2] = static_cast<uint8_t>(msg_size);

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + MAVLINK_V2_FRAME_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_size + 1 + 1);
    buffer[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[MAVLINK_V2_FRAME_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete MavlinkV2Frame packet in a buffer
 */
inline FrameMsgInfo mavlink_v2_frame_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < MAVLINK_V2_FRAME_OVERHEAD) return result;

    if (buffer[0] != MAVLINK_V2_FRAME_START_BYTE) return result;

    size_t msg_length = length - MAVLINK_V2_FRAME_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 1, msg_length + 1 + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[1];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + MAVLINK_V2_FRAME_HEADER_SIZE);
    }

    return result;
}


// =============================================================================
// FrameFormatConfig Frame Format
// =============================================================================

enum class FrameFormatConfigParserState : uint8_t {
    LookingForStart1 = 0,
    LookingForStart2 = 1,
    GettingMsgId = 2,
    GettingPayload = 3
};

// FrameFormatConfig constants
constexpr uint8_t FRAME_FORMAT_CONFIG_START_BYTE1 = 0x90;
constexpr uint8_t FRAME_FORMAT_CONFIG_START_BYTE2 = 0x91;
constexpr size_t FRAME_FORMAT_CONFIG_HEADER_SIZE = 2;
constexpr size_t FRAME_FORMAT_CONFIG_FOOTER_SIZE = 1;
constexpr size_t FRAME_FORMAT_CONFIG_OVERHEAD = FRAME_FORMAT_CONFIG_HEADER_SIZE + FRAME_FORMAT_CONFIG_FOOTER_SIZE;

/**
 * FrameFormatConfig Encode Buffer
 */
class FrameFormatConfigEncodeBuffer {
public:
    FrameFormatConfigEncodeBuffer(uint8_t* data, size_t max_size)
        : data_(data), max_size_(max_size), size_(0), in_progress_(false) {}

    void reset() {
        size_ = 0;
        in_progress_ = false;
    }

    uint8_t* data() { return data_; }
    const uint8_t* data() const { return data_; }
    size_t size() const { return size_; }
    size_t max_size() const { return max_size_; }
    bool in_progress() const { return in_progress_; }

    /**
     * Encode a message into the buffer
     */
    bool encode(uint8_t msg_id, const void* msg, size_t msg_size) {
        if (in_progress_) return false;

        size_t total_size = FRAME_FORMAT_CONFIG_OVERHEAD + msg_size;
        if (size_ + total_size > max_size_) return false;

        uint8_t* packet_start = data_ + size_;

        // Write header
        packet_start[0] = FRAME_FORMAT_CONFIG_START_BYTE1;
        packet_start[1] = FRAME_FORMAT_CONFIG_START_BYTE2;
        packet_start[2] = msg_id;

        // Write message data
        if (msg_size > 0 && msg != nullptr) {
            std::memcpy(packet_start + FRAME_FORMAT_CONFIG_HEADER_SIZE, msg, msg_size);
        }

        // Calculate checksum
        FrameChecksum ck = fletcher_checksum(packet_start + 2, msg_size + 1);
        packet_start[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size] = ck.byte1;
        packet_start[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size + 1] = ck.byte2;

        size_ += total_size;
        return true;
    }

private:
    uint8_t* data_;
    size_t max_size_;
    size_t size_;
    bool in_progress_;
};

/**
 * FrameFormatConfig Frame Parser
 */
class FrameFormatConfigParser {
public:
    using MsgLengthCallback = std::function<bool(uint8_t msg_id, size_t* length)>;

    FrameFormatConfigParser(uint8_t* buffer, size_t buffer_size, MsgLengthCallback msg_length_cb = nullptr)
        : state_(FrameFormatConfigParserState::LookingForStart1),
          buffer_(buffer),
          buffer_max_size_(buffer_size),
          buffer_index_(0),
          packet_size_(0),
          msg_id_(0),
          get_msg_length_(std::move(msg_length_cb)) {}

    void reset() {
        state_ = FrameFormatConfigParserState::LookingForStart1;
        buffer_index_ = 0;
        packet_size_ = 0;
        msg_id_ = 0;
    }

    /**
     * Parse a single byte
     * Returns FrameMsgInfo with valid=true when a complete valid message is received
     */
    FrameMsgInfo parse_byte(uint8_t byte) {
        FrameMsgInfo result;

        switch (state_) {
            case FrameFormatConfigParserState::LookingForStart1:
                if (byte == FRAME_FORMAT_CONFIG_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = FrameFormatConfigParserState::LookingForStart2;
                }
                break;

            case FrameFormatConfigParserState::LookingForStart2:
                if (byte == FRAME_FORMAT_CONFIG_START_BYTE2) {
                    buffer_[1] = byte;
                    buffer_index_ = 2;
                    state_ = FrameFormatConfigParserState::GettingMsgId;
                } else if (byte == FRAME_FORMAT_CONFIG_START_BYTE1) {
                    buffer_[0] = byte;
                    buffer_index_ = 1;
                    state_ = FrameFormatConfigParserState::LookingForStart2;
                } else {
                    state_ = FrameFormatConfigParserState::LookingForStart1;
                }
                break;

            case FrameFormatConfigParserState::GettingMsgId: {
                buffer_[buffer_index_++] = byte;
                msg_id_ = byte;

                size_t msg_length = 0;
                if (get_msg_length_ && get_msg_length_(byte, &msg_length)) {
                    packet_size_ = FRAME_FORMAT_CONFIG_OVERHEAD + msg_length;
                    if (packet_size_ <= buffer_max_size_) {
                        state_ = FrameFormatConfigParserState::GettingPayload;
                    } else {
                        state_ = FrameFormatConfigParserState::LookingForStart1;
                    }
                } else {
                    state_ = FrameFormatConfigParserState::LookingForStart1;
                }
                break;
            }

            case FrameFormatConfigParserState::GettingPayload:
                if (buffer_index_ < buffer_max_size_) {
                    buffer_[buffer_index_++] = byte;
                }

                if (buffer_index_ >= packet_size_) {
                    // Validate checksum
                    size_t msg_length = packet_size_ - FRAME_FORMAT_CONFIG_OVERHEAD;
                    FrameChecksum ck = fletcher_checksum(buffer_ + 2, msg_length + 1);

                    if (ck.byte1 == buffer_[packet_size_ - 2] &&
                        ck.byte2 == buffer_[packet_size_ - 1]) {
                        result.valid = true;
                        result.msg_id = msg_id_;
                        result.msg_len = msg_length;
                        result.msg_data = buffer_ + FRAME_FORMAT_CONFIG_HEADER_SIZE;
                    }
                    state_ = FrameFormatConfigParserState::LookingForStart1;
                }
                break;
        }

        return result;
    }

private:
    FrameFormatConfigParserState state_;
    uint8_t* buffer_;
    size_t buffer_max_size_;
    size_t buffer_index_;
    size_t packet_size_;
    uint8_t msg_id_;
    MsgLengthCallback get_msg_length_;
};

/**
 * Encode a message with FrameFormatConfig format
 * Returns the number of bytes written, or 0 on failure
 */
inline size_t frame_format_config_encode(uint8_t* buffer, size_t buffer_size,
                                           uint8_t msg_id, const uint8_t* msg, size_t msg_size) {
    size_t total_size = FRAME_FORMAT_CONFIG_OVERHEAD + msg_size;
    if (buffer_size < total_size) return 0;

    buffer[0] = FRAME_FORMAT_CONFIG_START_BYTE1;
    buffer[1] = FRAME_FORMAT_CONFIG_START_BYTE2;
    buffer[2] = msg_id;

    if (msg_size > 0 && msg != nullptr) {
        std::memcpy(buffer + FRAME_FORMAT_CONFIG_HEADER_SIZE, msg, msg_size);
    }

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_size + 1);
    buffer[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size] = ck.byte1;
    buffer[FRAME_FORMAT_CONFIG_HEADER_SIZE + msg_size + 1] = ck.byte2;

    return total_size;
}

/**
 * Validate a complete FrameFormatConfig packet in a buffer
 */
inline FrameMsgInfo frame_format_config_validate_packet(const uint8_t* buffer, size_t length) {
    FrameMsgInfo result;

    if (length < FRAME_FORMAT_CONFIG_OVERHEAD) return result;

    if (buffer[0] != FRAME_FORMAT_CONFIG_START_BYTE1) return result;
    if (buffer[1] != FRAME_FORMAT_CONFIG_START_BYTE2) return result;

    size_t msg_length = length - FRAME_FORMAT_CONFIG_OVERHEAD;

    FrameChecksum ck = fletcher_checksum(buffer + 2, msg_length + 1);
    if (ck.byte1 == buffer[length - 2] && ck.byte2 == buffer[length - 1]) {
        result.valid = true;
        result.msg_id = buffer[2];
        result.msg_len = msg_length;
        result.msg_data = const_cast<uint8_t*>(buffer + FRAME_FORMAT_CONFIG_HEADER_SIZE);
    }

    return result;
}


}  // namespace FrameParsers
