/* Automatically generated frame parser base utilities */
/* Generated by 0.0.1 at Wed Dec  3 17:57:16 2025. */

#pragma once

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <functional>

namespace FrameParsers {

// Frame format type enumeration
enum class FrameFormatType {
    MINIMAL_FRAME = 0,
    BASIC_FRAME = 1,
    BASIC_FRAME_NO_CRC = 2,
    TINY_FRAME = 3,
    TINY_FRAME_NO_CRC = 4,
    MINIMAL_FRAME_WITH_LEN = 5,
    MINIMAL_FRAME_WITH_LEN_NO_CRC = 6,
    BASIC_FRAME_WITH_LEN = 7,
    BASIC_FRAME_WITH_LEN_NO_CRC = 8,
    TINY_FRAME_WITH_LEN = 9,
    TINY_FRAME_WITH_LEN_NO_CRC = 10,
    MINIMAL_FRAME_WITH_LEN16 = 11,
    MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12,
    BASIC_FRAME_WITH_LEN16 = 13,
    BASIC_FRAME_WITH_LEN16_NO_CRC = 14,
    TINY_FRAME_WITH_LEN16 = 15,
    TINY_FRAME_WITH_LEN16_NO_CRC = 16,
    BASIC_FRAME_WITH_SYS_COMP = 17,
    UBX_FRAME = 18,
    MAVLINK_V1_FRAME = 19,
    MAVLINK_V2_FRAME = 20,
    FRAME_FORMAT_CONFIG = 21,
};

// Checksum result
struct FrameChecksum {
    uint8_t byte1;
    uint8_t byte2;
};

// Fletcher-16 checksum calculation
inline FrameChecksum fletcher_checksum(const uint8_t* data, size_t length) {
    FrameChecksum ck{0, 0};
    for (size_t i = 0; i < length; i++) {
        ck.byte1 = static_cast<uint8_t>(ck.byte1 + data[i]);
        ck.byte2 = static_cast<uint8_t>(ck.byte2 + ck.byte1);
    }
    return ck;
}

// Parse result
struct FrameMsgInfo {
    bool valid;
    uint8_t msg_id;
    size_t msg_len;
    uint8_t* msg_data;

    FrameMsgInfo() : valid(false), msg_id(0), msg_len(0), msg_data(nullptr) {}
    FrameMsgInfo(bool v, uint8_t id, size_t len, uint8_t* data)
        : valid(v), msg_id(id), msg_len(len), msg_data(data) {}
};

}  // namespace FrameParsers
