# Automatically generated frame parser
# Generated by 0.0.1 at Thu Dec  4 20:27:20 2025.

from enum import Enum
from typing import Callable, List, Union
from .frame_base import (
    FrameMsgInfo, fletcher_checksum,
    validate_payload_with_crc, validate_payload_minimal,
    encode_payload_with_crc, encode_payload_minimal,
)

# =============================================================================
# FrameFormatConfig Frame Format
# =============================================================================

class FrameFormatConfigParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_PAYLOAD = 3


class FrameFormatConfig:
    """
    FrameFormatConfig - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x71] [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x71
    HEADER_SIZE = 2
    FOOTER_SIZE = 1
    OVERHEAD = 3

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the FrameFormatConfig parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = FrameFormatConfigParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == FrameFormatConfigParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START2

        elif self.state == FrameFormatConfigParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = FrameFormatConfigParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START2
            else:
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        elif self.state == FrameFormatConfigParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = FrameFormatConfigParserState.GETTING_PAYLOAD
                else:
                    self.state = FrameFormatConfigParserState.LOOKING_FOR_START1
            else:
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        elif self.state == FrameFormatConfigParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Use shared payload validation with CRC
                result = validate_payload_with_crc(self.buffer, self.HEADER_SIZE, 0, 2)
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with FrameFormatConfig format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        # Use shared payload encoding with CRC
        encode_payload_with_crc(output, msg_id, msg, 0, 2)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete FrameFormatConfig packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        if len(buffer) < FrameFormatConfig.OVERHEAD:
            return FrameMsgInfo()

        if buffer[0] != FrameFormatConfig.START_BYTE1:
            return FrameMsgInfo()
        if buffer[1] != FrameFormatConfig.START_BYTE2:
            return FrameMsgInfo()

        # Use shared payload validation with CRC
        return validate_payload_with_crc(buffer, FrameFormatConfig.HEADER_SIZE, 0, 2)
