# Automatically generated frame parser
# Generated by 0.0.1 at Fri Dec 19 13:09:54 2025.
# Uses header + payload architecture for composable frame formats.
# Now uses modular structure with frame_headers/ and payload_types/ submodules.

from typing import Optional, Callable, List
try:
    # Try relative imports (when used as a package)
    from .frame_headers import (
        HeaderType, HeaderConfig,
        BASIC_START_BYTE, PAYLOAD_TYPE_BASE, UBX_SYNC1, UBX_SYNC2,
        MAVLINK_V1_STX, MAVLINK_V2_STX,
        HEADER_NONE_CONFIG, HEADER_TINY_CONFIG, HEADER_BASIC_CONFIG,
        HEADER_UBX_CONFIG, HEADER_MAVLINK_V1_CONFIG, HEADER_MAVLINK_V2_CONFIG,
        is_tiny_start_byte, get_payload_type_from_tiny
    )
    from .payload_types import (
        PayloadType, MAX_PAYLOAD_TYPE, PayloadConfig,
        PAYLOAD_MINIMAL_CONFIG, PAYLOAD_DEFAULT_CONFIG,
        PAYLOAD_EXTENDED_MSG_IDS_CONFIG, PAYLOAD_EXTENDED_LENGTH_CONFIG,
        PAYLOAD_EXTENDED_CONFIG, PAYLOAD_SYS_COMP_CONFIG,
        PAYLOAD_SEQ_CONFIG, PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,
        PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG
    )
    from .utils import fletcher_checksum, FrameMsgInfo, ParserState, Profile
except ImportError:
    # Fall back to absolute imports (when used as a standalone file)
    from frame_headers import (
        HeaderType, HeaderConfig,
        BASIC_START_BYTE, PAYLOAD_TYPE_BASE, UBX_SYNC1, UBX_SYNC2,
        MAVLINK_V1_STX, MAVLINK_V2_STX,
        HEADER_NONE_CONFIG, HEADER_TINY_CONFIG, HEADER_BASIC_CONFIG,
        HEADER_UBX_CONFIG, HEADER_MAVLINK_V1_CONFIG, HEADER_MAVLINK_V2_CONFIG,
        is_tiny_start_byte, get_payload_type_from_tiny
    )
    from payload_types import (
        PayloadType, MAX_PAYLOAD_TYPE, PayloadConfig,
        PAYLOAD_MINIMAL_CONFIG, PAYLOAD_DEFAULT_CONFIG,
        PAYLOAD_EXTENDED_MSG_IDS_CONFIG, PAYLOAD_EXTENDED_LENGTH_CONFIG,
        PAYLOAD_EXTENDED_CONFIG, PAYLOAD_SYS_COMP_CONFIG,
        PAYLOAD_SEQ_CONFIG, PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,
        PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG
    )
    from utils import fletcher_checksum, FrameMsgInfo, ParserState, Profile

# Payload configurations mapping
PAYLOAD_CONFIGS = {
    PayloadType.MINIMAL: PAYLOAD_MINIMAL_CONFIG,
    PayloadType.DEFAULT: PAYLOAD_DEFAULT_CONFIG,
    PayloadType.EXTENDED_MSG_IDS: PAYLOAD_EXTENDED_MSG_IDS_CONFIG,
    PayloadType.EXTENDED_LENGTH: PAYLOAD_EXTENDED_LENGTH_CONFIG,
    PayloadType.EXTENDED: PAYLOAD_EXTENDED_CONFIG,
    PayloadType.SYS_COMP: PAYLOAD_SYS_COMP_CONFIG,
    PayloadType.SEQ: PAYLOAD_SEQ_CONFIG,
    PayloadType.MULTI_SYSTEM_STREAM: PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,
    PayloadType.EXTENDED_MULTI_SYSTEM_STREAM: PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG,
}


# =============================================================================
# Parser
# =============================================================================

class Parser:
    """
    Frame parser that can detect and parse multiple frame types.
    
    Supports:
    - Basic frames: [0x90] [0x70+payload_type] [payload...]
    - Tiny frames:  [0x70+payload_type] [payload...]
    - None frames:  [payload...] (no start bytes)
    
    The payload type (0-8) determines the payload structure.
    """

    def __init__(self,
                 get_msg_length: Callable[[int], int] = None,
                 enabled_headers: Optional[List[HeaderType]] = None,
                 enabled_payloads: Optional[List[PayloadType]] = None,
                 # Legacy parameters (deprecated):
                 enable_basic: bool = True,
                 enable_tiny: bool = True,
                 enable_none: bool = False,
                 default_payload_type: PayloadType = PayloadType.DEFAULT):
        """
        Initialize parser.
        
        Args:
            get_msg_length: Callback to get message length from msg_id (required for Minimal payloads)
            enabled_headers: List of header types to accept (None = all supported)
            enabled_payloads: List of payload types to accept (None = all)
            enable_basic: (Deprecated) Enable Basic frame parsing
            enable_tiny: (Deprecated) Enable Tiny frame parsing
            enable_none: (Deprecated) Enable None frame parsing
            default_payload_type: Default payload type for None frames
        """
        self.get_msg_length = get_msg_length
        
        # Handle new registration API
        if enabled_headers is not None:
            self.enabled_headers = set(enabled_headers)
        else:
            # Use legacy parameters
            self.enabled_headers = set()
            if enable_basic:
                self.enabled_headers.add(HeaderType.BASIC)
            if enable_tiny:
                self.enabled_headers.add(HeaderType.TINY)
            if enable_none:
                self.enabled_headers.add(HeaderType.NONE)
        
        if enabled_payloads is not None:
            self.enabled_payloads = set(enabled_payloads)
        else:
            # Accept all payload types
            self.enabled_payloads = set(PayloadType)
        
        self.default_payload_type = default_payload_type
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = ParserState.LOOKING_FOR_START
        self.header_type: Optional[HeaderType] = None
        self.payload_type: Optional[PayloadType] = None
        self.payload_config: Optional[PayloadConfig] = None
        self.buffer: List[int] = []
        self.header_bytes_remaining = 0
        self.payload_bytes_remaining = 0
        self.footer_bytes_remaining = 0
        # Parsed header fields
        self.msg_id = 0
        self.msg_len = 0
        self.package_id = 0
        self.sequence = 0
        self.system_id = 0
        self.component_id = 0
        self.header_field_index = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte.
        
        Returns:
            FrameMsgInfo with valid=True when a complete message is received
        """
        result = FrameMsgInfo()

        if self.state == ParserState.LOOKING_FOR_START:
            result = self._handle_looking_for_start(byte)
        elif self.state == ParserState.GOT_BASIC_START:
            result = self._handle_got_basic_start(byte)
        elif self.state == ParserState.GOT_UBX_SYNC1:
            result = self._handle_got_ubx_sync1(byte)
        elif self.state == ParserState.PARSING_HEADER:
            result = self._handle_parsing_header(byte)
        elif self.state == ParserState.PARSING_PAYLOAD:
            result = self._handle_parsing_payload(byte)
        elif self.state == ParserState.PARSING_FOOTER:
            result = self._handle_parsing_footer(byte)

        return result

    def _handle_looking_for_start(self, byte: int) -> FrameMsgInfo:
        """Handle LOOKING_FOR_START state"""
        # Check for Basic frame (0x90)
        if HeaderType.BASIC in self.enabled_headers and byte == BASIC_START_BYTE:
            self.state = ParserState.GOT_BASIC_START
            self.header_type = HeaderType.BASIC
            self.buffer = [byte]
        # Check for Tiny frame (0x70-0x78)
        elif HeaderType.TINY in self.enabled_headers and PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:
            payload_type_value = byte - PAYLOAD_TYPE_BASE
            payload_type = PayloadType(payload_type_value)
            if payload_type in self.enabled_payloads:
                self._start_payload_parsing(HeaderType.TINY, payload_type, [byte])
        # Check for UBX (0xB5)
        elif HeaderType.UBX in self.enabled_headers and byte == UBX_SYNC1:
            self.state = ParserState.GOT_UBX_SYNC1
            self.buffer = [byte]
        # Check for Mavlink V1 (0xFE)
        elif HeaderType.MAVLINK_V1 in self.enabled_headers and byte == MAVLINK_V1_STX:
            self.header_type = HeaderType.MAVLINK_V1
            # TODO: Implement Mavlink V1 parsing
            self.reset()
        # Check for Mavlink V2 (0xFD)
        elif HeaderType.MAVLINK_V2 in self.enabled_headers and byte == MAVLINK_V2_STX:
            self.header_type = HeaderType.MAVLINK_V2
            # TODO: Implement Mavlink V2 parsing
            self.reset()
        # None frame (no start bytes) - treat as payload directly
        elif HeaderType.NONE in self.enabled_headers:
            if self.default_payload_type in self.enabled_payloads:
                self._start_payload_parsing(HeaderType.NONE, self.default_payload_type, [])
                return self._handle_parsing_header(byte)
        return FrameMsgInfo()

    def _handle_got_basic_start(self, byte: int) -> FrameMsgInfo:
        """Handle GOT_BASIC_START state - waiting for payload type byte"""
        if PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:
            payload_type_value = byte - PAYLOAD_TYPE_BASE
            payload_type = PayloadType(payload_type_value)
            if payload_type in self.enabled_payloads:
                self.buffer.append(byte)
                self._start_payload_parsing(HeaderType.BASIC, payload_type, self.buffer)
            else:
                # Payload type not enabled, reset
                self.reset()
        else:
            # Invalid second byte, reset
            self.reset()
        return FrameMsgInfo()

    def _handle_got_ubx_sync1(self, byte: int) -> FrameMsgInfo:
        """Handle GOT_UBX_SYNC1 state - waiting for second sync byte"""
        if byte == UBX_SYNC2:
            self.buffer.append(byte)
            self.header_type = HeaderType.UBX
            # TODO: Implement UBX payload parsing
            self.reset()
        else:
            self.reset()
        return FrameMsgInfo()

    def _start_payload_parsing(self, header_type: HeaderType, payload_type: PayloadType, buffer: List[int]):
        """Initialize payload parsing after header detection"""
        self.header_type = header_type
        self.payload_type = payload_type
        self.payload_config = PAYLOAD_CONFIGS.get(payload_type)
        self.buffer = buffer.copy()
        self.header_field_index = 0
        self.state = ParserState.PARSING_HEADER

    def _handle_parsing_header(self, byte: int) -> FrameMsgInfo:
        """Parse payload header fields based on payload type"""
        self.buffer.append(byte)
        config = self.payload_config
        if config is None:
            self.reset()
            return FrameMsgInfo()

        # Parse header fields in order based on payload type
        # Order: [SEQ] [SYS_ID] [COMP_ID] [LEN/LEN16] [PKG_ID] [MSG_ID]
        field_order = []
        if config.has_sequence:
            field_order.append('sequence')
        if config.has_system_id:
            field_order.append('system_id')
        if config.has_component_id:
            field_order.append('component_id')
        if config.has_length:
            if config.length_bytes == 2:
                field_order.append('length_lo')
                field_order.append('length_hi')
            else:
                field_order.append('length')
        if config.has_package_id:
            field_order.append('package_id')
        field_order.append('msg_id')

        if self.header_field_index < len(field_order):
            field_name = field_order[self.header_field_index]
            if field_name == 'sequence':
                self.sequence = byte
            elif field_name == 'system_id':
                self.system_id = byte
            elif field_name == 'component_id':
                self.component_id = byte
            elif field_name == 'length':
                self.msg_len = byte
            elif field_name == 'length_lo':
                self.msg_len = byte
            elif field_name == 'length_hi':
                self.msg_len |= (byte << 8)
            elif field_name == 'package_id':
                self.package_id = byte
            elif field_name == 'msg_id':
                self.msg_id = byte
            self.header_field_index += 1

        # Check if header is complete
        if self.header_field_index >= len(field_order):
            # Determine payload length
            if config.has_length:
                self.payload_bytes_remaining = self.msg_len
            elif self.get_msg_length:
                self.payload_bytes_remaining = self.get_msg_length(self.msg_id)
            else:
                # No length field and no callback - can't determine length
                self.reset()
                return FrameMsgInfo()
            
            self.footer_bytes_remaining = config.footer_size
            self.state = ParserState.PARSING_PAYLOAD if self.payload_bytes_remaining > 0 else ParserState.PARSING_FOOTER

        return FrameMsgInfo()

    def _handle_parsing_payload(self, byte: int) -> FrameMsgInfo:
        """Parse message payload data"""
        self.buffer.append(byte)
        self.payload_bytes_remaining -= 1

        if self.payload_bytes_remaining <= 0:
            if self.footer_bytes_remaining > 0:
                self.state = ParserState.PARSING_FOOTER
            else:
                return self._complete_message()
        return FrameMsgInfo()

    def _handle_parsing_footer(self, byte: int) -> FrameMsgInfo:
        """Parse footer (CRC) bytes"""
        self.buffer.append(byte)
        self.footer_bytes_remaining -= 1

        if self.footer_bytes_remaining <= 0:
            return self._complete_message()
        return FrameMsgInfo()

    def _complete_message(self) -> FrameMsgInfo:
        """Validate and return completed message"""
        config = self.payload_config
        if config is None:
            self.reset()
            return FrameMsgInfo()

        # Validate CRC if present
        if config.has_crc:
            # CRC is calculated from after start bytes to before CRC
            header_size = 0
            if self.header_type == HeaderType.BASIC:
                header_size = 2
            elif self.header_type == HeaderType.TINY:
                header_size = 1
            crc_start = header_size
            crc_end = len(self.buffer) - config.crc_bytes
            calc_crc = fletcher_checksum(self.buffer, crc_start, crc_end)
            recv_crc = (self.buffer[-2], self.buffer[-1])
            if calc_crc != recv_crc:
                self.reset()
                return FrameMsgInfo()

        # Extract message data
        header_size = 0
        if self.header_type == HeaderType.BASIC:
            header_size = 2
        elif self.header_type == HeaderType.TINY:
            header_size = 1
        payload_header_size = config.header_size
        data_start = header_size + payload_header_size
        data_end = len(self.buffer) - config.footer_size
        msg_data = bytes(self.buffer[data_start:data_end])

        result = FrameMsgInfo(
            valid=True,
            header_type=self.header_type,
            payload_type=self.payload_type,
            msg_id=self.msg_id,
            msg_len=len(msg_data),
            msg_data=msg_data,
            package_id=self.package_id,
            sequence=self.sequence,
            system_id=self.system_id,
            component_id=self.component_id,
        )
        self.reset()
        return result

    def encode(self, msg_id: int, msg: bytes,
               header_type: HeaderType = HeaderType.BASIC,
               payload_type: PayloadType = PayloadType.DEFAULT,
               package_id: int = 0,
               sequence: int = 0,
               system_id: int = 0,
               component_id: int = 0) -> bytes:
        """
        Encode a message with specified header and payload type.
        
        Args:
            msg_id: Message ID (0-255)
            msg: Message data bytes
            header_type: Header type (BASIC, TINY, or NONE)
            payload_type: Payload type (MINIMAL, DEFAULT, etc.)
            package_id: Package ID for EXTENDED_MSG_IDS payloads
            sequence: Sequence number for SEQ payloads
            system_id: System ID for SYS_COMP payloads
            component_id: Component ID for SYS_COMP payloads
        
        Returns:
            Encoded frame bytes
        """
        config = PAYLOAD_CONFIGS.get(payload_type)
        if config is None:
            raise ValueError(f"Unknown payload type: {payload_type}")

        output = []

        # Add header start bytes
        if header_type == HeaderType.BASIC:
            output.append(BASIC_START_BYTE)
            output.append(PAYLOAD_TYPE_BASE + payload_type.value)
        elif header_type == HeaderType.TINY:
            output.append(PAYLOAD_TYPE_BASE + payload_type.value)
        # NONE has no start bytes

        # Add payload header fields in order
        if config.has_sequence:
            output.append(sequence & 0xFF)
        if config.has_system_id:
            output.append(system_id & 0xFF)
        if config.has_component_id:
            output.append(component_id & 0xFF)
        if config.has_length:
            if config.length_bytes == 2:
                output.append(len(msg) & 0xFF)
                output.append((len(msg) >> 8) & 0xFF)
            else:
                output.append(len(msg) & 0xFF)
        if config.has_package_id:
            output.append(package_id & 0xFF)
        output.append(msg_id & 0xFF)

        # Add message data
        output.extend(msg)

        # Add CRC if needed
        if config.has_crc:
            # CRC calculated from after start bytes
            crc_start = 0
            if header_type == HeaderType.BASIC:
                crc_start = 2
            elif header_type == HeaderType.TINY:
                crc_start = 1
            crc = fletcher_checksum(output, crc_start)
            output.append(crc[0])
            output.append(crc[1])

        return bytes(output)

    def encode_basic(self, msg_id: int, msg: bytes,
                     payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:
        """Encode with Basic header"""
        return self.encode(msg_id, msg, HeaderType.BASIC, payload_type, **kwargs)

    def encode_tiny(self, msg_id: int, msg: bytes,
                    payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:
        """Encode with Tiny header"""
        return self.encode(msg_id, msg, HeaderType.TINY, payload_type, **kwargs)

