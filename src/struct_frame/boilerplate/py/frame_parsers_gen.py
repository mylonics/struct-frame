# Automatically generated frame parser
# Generated by 0.0.1 at Sun Nov 30 16:50:10 2025.

from enum import Enum
from typing import Optional, Callable, Dict, List, Tuple, Union
from dataclasses import dataclass

# Frame format type enumeration
class FrameFormatType(Enum):
    MINIMAL_FRAME = 0
    BASIC_FRAME = 1
    BASIC_FRAME_NO_CRC = 2
    TINY_FRAME = 3
    TINY_FRAME_NO_CRC = 4
    MINIMAL_FRAME_WITH_LEN = 5
    MINIMAL_FRAME_WITH_LEN_NO_CRC = 6
    BASIC_FRAME_WITH_LEN = 7
    BASIC_FRAME_WITH_LEN_NO_CRC = 8
    TINY_FRAME_WITH_LEN = 9
    TINY_FRAME_WITH_LEN_NO_CRC = 10
    MINIMAL_FRAME_WITH_LEN16 = 11
    MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12
    BASIC_FRAME_WITH_LEN16 = 13
    BASIC_FRAME_WITH_LEN16_NO_CRC = 14
    TINY_FRAME_WITH_LEN16 = 15
    TINY_FRAME_WITH_LEN16_NO_CRC = 16
    BASIC_FRAME_WITH_SYS_COMP = 17
    UBX_FRAME = 18
    MAVLINK_V1_FRAME = 19
    MAVLINK_V2_FRAME = 20
    FRAME_FORMAT_CONFIG = 21


def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)
    
    byte1 = 0
    byte2 = 0
    
    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256
    
    return (byte1, byte2)


@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''


# =============================================================================
# MinimalFrame Frame Format
# =============================================================================

class MinimalFrameParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_PAYLOAD = 1


class MinimalFrame:
    """
    MinimalFrame - Frame format parser and encoder
    
    Format: [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    HEADER_SIZE = 1
    FOOTER_SIZE = 2
    OVERHEAD = 3

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = MinimalFrameParserState.GETTING_PAYLOAD
                else:
                    self.state = MinimalFrameParserState.GETTING_MSG_ID
            else:
                self.state = MinimalFrameParserState.GETTING_MSG_ID

        elif self.state == MinimalFrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 0, 0 + msg_length + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MinimalFrameParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.extend(msg)
        ck = fletcher_checksum(output, 0, 0 + len(msg) + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrame.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[0]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MinimalFrame.HEADER_SIZE:len(buffer) - MinimalFrame.FOOTER_SIZE])

        return result


# =============================================================================
# BasicFrame Frame Format
# =============================================================================

class BasicFrameParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_PAYLOAD = 3


class BasicFrame:
    """
    BasicFrame - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x91] [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x91
    HEADER_SIZE = 3
    FOOTER_SIZE = 2
    OVERHEAD = 5

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameParserState.LOOKING_FOR_START2

        if self.state == BasicFrameParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = BasicFrameParserState.GETTING_PAYLOAD
                else:
                    self.state = BasicFrameParserState.LOOKING_FOR_START1
            else:
                self.state = BasicFrameParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = BasicFrameParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrame.OVERHEAD:
            return result

        if buffer[0] != BasicFrame.START_BYTE1:
            return result
        if buffer[1] != BasicFrame.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[BasicFrame.HEADER_SIZE:len(buffer) - BasicFrame.FOOTER_SIZE])

        return result


# =============================================================================
# BasicFrameNoCrc Frame Format
# =============================================================================

class BasicFrameNoCrcParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_PAYLOAD = 3


class BasicFrameNoCrc:
    """
    BasicFrameNoCrc - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x95] [MSG_ID] [MSG...]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x95
    HEADER_SIZE = 3
    FOOTER_SIZE = 0
    OVERHEAD = 3

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameNoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameNoCrcParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2

        if self.state == BasicFrameNoCrcParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameNoCrcParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameNoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = BasicFrameNoCrcParserState.GETTING_PAYLOAD
                else:
                    self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1
            else:
                self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameNoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = BasicFrameNoCrcParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameNoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameNoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameNoCrc.OVERHEAD:
            return result

        if buffer[0] != BasicFrameNoCrc.START_BYTE1:
            return result
        if buffer[1] != BasicFrameNoCrc.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameNoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[2]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[BasicFrameNoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# TinyFrame Frame Format
# =============================================================================

class TinyFrameParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_PAYLOAD = 2


class TinyFrame:
    """
    TinyFrame - Frame format parser and encoder
    
    Format: [START_BYTE=0x70] [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE = 0x70
    HEADER_SIZE = 2
    FOOTER_SIZE = 2
    OVERHEAD = 4

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameParserState.GETTING_MSG_ID

        elif self.state == TinyFrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = TinyFrameParserState.GETTING_PAYLOAD
                else:
                    self.state = TinyFrameParserState.LOOKING_FOR_START
            else:
                self.state = TinyFrameParserState.LOOKING_FOR_START

        elif self.state == TinyFrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 1, 1 + msg_length + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = TinyFrameParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.extend(msg)
        ck = fletcher_checksum(output, 1, 1 + len(msg) + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrame.OVERHEAD:
            return result

        if buffer[0] != TinyFrame.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[1]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[TinyFrame.HEADER_SIZE:len(buffer) - TinyFrame.FOOTER_SIZE])

        return result


# =============================================================================
# TinyFrameNoCrc Frame Format
# =============================================================================

class TinyFrameNoCrcParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_PAYLOAD = 2


class TinyFrameNoCrc:
    """
    TinyFrameNoCrc - Frame format parser and encoder
    
    Format: [START_BYTE=0x72] [MSG_ID] [MSG...]
    """

    START_BYTE = 0x72
    HEADER_SIZE = 2
    FOOTER_SIZE = 0
    OVERHEAD = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrameNoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameNoCrcParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameNoCrcParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameNoCrcParserState.GETTING_MSG_ID

        elif self.state == TinyFrameNoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = TinyFrameNoCrcParserState.GETTING_PAYLOAD
                else:
                    self.state = TinyFrameNoCrcParserState.LOOKING_FOR_START
            else:
                self.state = TinyFrameNoCrcParserState.LOOKING_FOR_START

        elif self.state == TinyFrameNoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = TinyFrameNoCrcParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrameNoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrameNoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrameNoCrc.OVERHEAD:
            return result

        if buffer[0] != TinyFrameNoCrc.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrameNoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[1]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[TinyFrameNoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# MinimalFrameWithLen Frame Format
# =============================================================================

class MinimalFrameWithLenParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_LENGTH = 1
    GETTING_PAYLOAD = 2


class MinimalFrameWithLen:
    """
    MinimalFrameWithLen - Frame format parser and encoder
    
    Format: [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    HEADER_SIZE = 2
    FOOTER_SIZE = 2
    OVERHEAD = 4
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrameWithLen parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameWithLenParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameWithLenParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MinimalFrameWithLenParserState.GETTING_LENGTH

        elif self.state == MinimalFrameWithLenParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = MinimalFrameWithLenParserState.GETTING_PAYLOAD

        elif self.state == MinimalFrameWithLenParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 0, 0 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MinimalFrameWithLenParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrameWithLen format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 0, 0 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrameWithLen packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrameWithLen.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrameWithLen.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[0]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MinimalFrameWithLen.HEADER_SIZE:len(buffer) - MinimalFrameWithLen.FOOTER_SIZE])

        return result


# =============================================================================
# MinimalFrameWithLenNoCrc Frame Format
# =============================================================================

class MinimalFrameWithLenNoCrcParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_LENGTH = 1
    GETTING_PAYLOAD = 2


class MinimalFrameWithLenNoCrc:
    """
    MinimalFrameWithLenNoCrc - Frame format parser and encoder
    
    Format: [MSG_ID] [LEN] [MSG...]
    """

    HEADER_SIZE = 2
    FOOTER_SIZE = 0
    OVERHEAD = 2
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrameWithLenNoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH

        elif self.state == MinimalFrameWithLenNoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD

        elif self.state == MinimalFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = MinimalFrameWithLenNoCrcParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrameWithLenNoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrameWithLenNoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrameWithLenNoCrc.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrameWithLenNoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[0]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[MinimalFrameWithLenNoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# BasicFrameWithLen Frame Format
# =============================================================================

class BasicFrameWithLenParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class BasicFrameWithLen:
    """
    BasicFrameWithLen - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x92] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x92
    HEADER_SIZE = 4
    FOOTER_SIZE = 2
    OVERHEAD = 6
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameWithLen parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameWithLenParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameWithLenParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLenParserState.LOOKING_FOR_START2

        if self.state == BasicFrameWithLenParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameWithLenParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLenParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameWithLenParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithLenParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = BasicFrameWithLenParserState.GETTING_LENGTH

        elif self.state == BasicFrameWithLenParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = BasicFrameWithLenParserState.GETTING_PAYLOAD

        elif self.state == BasicFrameWithLenParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = BasicFrameWithLenParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameWithLen format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameWithLen packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameWithLen.OVERHEAD:
            return result

        if buffer[0] != BasicFrameWithLen.START_BYTE1:
            return result
        if buffer[1] != BasicFrameWithLen.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameWithLen.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[BasicFrameWithLen.HEADER_SIZE:len(buffer) - BasicFrameWithLen.FOOTER_SIZE])

        return result


# =============================================================================
# BasicFrameWithLenNoCrc Frame Format
# =============================================================================

class BasicFrameWithLenNoCrcParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class BasicFrameWithLenNoCrc:
    """
    BasicFrameWithLenNoCrc - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x96] [MSG_ID] [LEN] [MSG...]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x96
    HEADER_SIZE = 4
    FOOTER_SIZE = 0
    OVERHEAD = 4
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameWithLenNoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2

        if self.state == BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithLenNoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = BasicFrameWithLenNoCrcParserState.GETTING_LENGTH

        elif self.state == BasicFrameWithLenNoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD

        elif self.state == BasicFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = BasicFrameWithLenNoCrcParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameWithLenNoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameWithLenNoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameWithLenNoCrc.OVERHEAD:
            return result

        if buffer[0] != BasicFrameWithLenNoCrc.START_BYTE1:
            return result
        if buffer[1] != BasicFrameWithLenNoCrc.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameWithLenNoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[2]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[BasicFrameWithLenNoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# TinyFrameWithLen Frame Format
# =============================================================================

class TinyFrameWithLenParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class TinyFrameWithLen:
    """
    TinyFrameWithLen - Frame format parser and encoder
    
    Format: [START_BYTE=0x71] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE = 0x71
    HEADER_SIZE = 3
    FOOTER_SIZE = 2
    OVERHEAD = 5
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrameWithLen parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameWithLenParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameWithLenParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameWithLenParserState.GETTING_MSG_ID

        elif self.state == TinyFrameWithLenParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = TinyFrameWithLenParserState.GETTING_LENGTH

        elif self.state == TinyFrameWithLenParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = TinyFrameWithLenParserState.GETTING_PAYLOAD

        elif self.state == TinyFrameWithLenParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 1, 1 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = TinyFrameWithLenParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrameWithLen format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 1, 1 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrameWithLen packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrameWithLen.OVERHEAD:
            return result

        if buffer[0] != TinyFrameWithLen.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrameWithLen.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[1]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[TinyFrameWithLen.HEADER_SIZE:len(buffer) - TinyFrameWithLen.FOOTER_SIZE])

        return result


# =============================================================================
# TinyFrameWithLenNoCrc Frame Format
# =============================================================================

class TinyFrameWithLenNoCrcParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class TinyFrameWithLenNoCrc:
    """
    TinyFrameWithLenNoCrc - Frame format parser and encoder
    
    Format: [START_BYTE=0x73] [MSG_ID] [LEN] [MSG...]
    """

    START_BYTE = 0x73
    HEADER_SIZE = 3
    FOOTER_SIZE = 0
    OVERHEAD = 3
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrameWithLenNoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID

        elif self.state == TinyFrameWithLenNoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = TinyFrameWithLenNoCrcParserState.GETTING_LENGTH

        elif self.state == TinyFrameWithLenNoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD

        elif self.state == TinyFrameWithLenNoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = TinyFrameWithLenNoCrcParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrameWithLenNoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrameWithLenNoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrameWithLenNoCrc.OVERHEAD:
            return result

        if buffer[0] != TinyFrameWithLenNoCrc.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrameWithLenNoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[1]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[TinyFrameWithLenNoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# MinimalFrameWithLen16 Frame Format
# =============================================================================

class MinimalFrameWithLen16ParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_LENGTH = 1
    GETTING_PAYLOAD = 2


class MinimalFrameWithLen16:
    """
    MinimalFrameWithLen16 - Frame format parser and encoder
    
    Format: [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
    """

    HEADER_SIZE = 3
    FOOTER_SIZE = 2
    OVERHEAD = 5
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrameWithLen16 parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameWithLen16ParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MinimalFrameWithLen16ParserState.GETTING_LENGTH

        elif self.state == MinimalFrameWithLen16ParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 2:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = MinimalFrameWithLen16ParserState.GETTING_PAYLOAD

        elif self.state == MinimalFrameWithLen16ParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 0, 0 + msg_length + 1 + 2)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MinimalFrameWithLen16ParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrameWithLen16 format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 0, 0 + len(msg) + 1 + 2)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrameWithLen16 packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrameWithLen16.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrameWithLen16.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 2)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[0]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MinimalFrameWithLen16.HEADER_SIZE:len(buffer) - MinimalFrameWithLen16.FOOTER_SIZE])

        return result


# =============================================================================
# MinimalFrameWithLen16NoCrc Frame Format
# =============================================================================

class MinimalFrameWithLen16NoCrcParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_LENGTH = 1
    GETTING_PAYLOAD = 2


class MinimalFrameWithLen16NoCrc:
    """
    MinimalFrameWithLen16NoCrc - Frame format parser and encoder
    
    Format: [MSG_ID] [LEN16] [MSG...]
    """

    HEADER_SIZE = 3
    FOOTER_SIZE = 0
    OVERHEAD = 3
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrameWithLen16NoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH

        elif self.state == MinimalFrameWithLen16NoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 2:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD

        elif self.state == MinimalFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = MinimalFrameWithLen16NoCrcParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrameWithLen16NoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrameWithLen16NoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrameWithLen16NoCrc.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrameWithLen16NoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[0]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[MinimalFrameWithLen16NoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# BasicFrameWithLen16 Frame Format
# =============================================================================

class BasicFrameWithLen16ParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class BasicFrameWithLen16:
    """
    BasicFrameWithLen16 - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x93] [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x93
    HEADER_SIZE = 5
    FOOTER_SIZE = 2
    OVERHEAD = 7
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameWithLen16 parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameWithLen16ParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2

        if self.state == BasicFrameWithLen16ParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameWithLen16ParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithLen16ParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = BasicFrameWithLen16ParserState.GETTING_LENGTH

        elif self.state == BasicFrameWithLen16ParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 4:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = BasicFrameWithLen16ParserState.GETTING_PAYLOAD

        elif self.state == BasicFrameWithLen16ParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1 + 2)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = BasicFrameWithLen16ParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameWithLen16 format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1 + 2)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameWithLen16 packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameWithLen16.OVERHEAD:
            return result

        if buffer[0] != BasicFrameWithLen16.START_BYTE1:
            return result
        if buffer[1] != BasicFrameWithLen16.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameWithLen16.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 2)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[BasicFrameWithLen16.HEADER_SIZE:len(buffer) - BasicFrameWithLen16.FOOTER_SIZE])

        return result


# =============================================================================
# BasicFrameWithLen16NoCrc Frame Format
# =============================================================================

class BasicFrameWithLen16NoCrcParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class BasicFrameWithLen16NoCrc:
    """
    BasicFrameWithLen16NoCrc - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x97] [MSG_ID] [LEN16] [MSG...]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x97
    HEADER_SIZE = 5
    FOOTER_SIZE = 0
    OVERHEAD = 5
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameWithLen16NoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2

        if self.state == BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH

        elif self.state == BasicFrameWithLen16NoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 4:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD

        elif self.state == BasicFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = BasicFrameWithLen16NoCrcParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameWithLen16NoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameWithLen16NoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameWithLen16NoCrc.OVERHEAD:
            return result

        if buffer[0] != BasicFrameWithLen16NoCrc.START_BYTE1:
            return result
        if buffer[1] != BasicFrameWithLen16NoCrc.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameWithLen16NoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[2]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[BasicFrameWithLen16NoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# TinyFrameWithLen16 Frame Format
# =============================================================================

class TinyFrameWithLen16ParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class TinyFrameWithLen16:
    """
    TinyFrameWithLen16 - Frame format parser and encoder
    
    Format: [START_BYTE=0x74] [MSG_ID] [LEN16] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE = 0x74
    HEADER_SIZE = 4
    FOOTER_SIZE = 2
    OVERHEAD = 6
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrameWithLen16 parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameWithLen16ParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameWithLen16ParserState.GETTING_MSG_ID

        elif self.state == TinyFrameWithLen16ParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = TinyFrameWithLen16ParserState.GETTING_LENGTH

        elif self.state == TinyFrameWithLen16ParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 3:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = TinyFrameWithLen16ParserState.GETTING_PAYLOAD

        elif self.state == TinyFrameWithLen16ParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 1, 1 + msg_length + 1 + 2)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = TinyFrameWithLen16ParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrameWithLen16 format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 1, 1 + len(msg) + 1 + 2)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrameWithLen16 packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrameWithLen16.OVERHEAD:
            return result

        if buffer[0] != TinyFrameWithLen16.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrameWithLen16.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 2)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[1]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[TinyFrameWithLen16.HEADER_SIZE:len(buffer) - TinyFrameWithLen16.FOOTER_SIZE])

        return result


# =============================================================================
# TinyFrameWithLen16NoCrc Frame Format
# =============================================================================

class TinyFrameWithLen16NoCrcParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class TinyFrameWithLen16NoCrc:
    """
    TinyFrameWithLen16NoCrc - Frame format parser and encoder
    
    Format: [START_BYTE=0x75] [MSG_ID] [LEN16] [MSG...]
    """

    START_BYTE = 0x75
    HEADER_SIZE = 4
    FOOTER_SIZE = 0
    OVERHEAD = 4
    LENGTH_BYTES = 2

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the TinyFrameWithLen16NoCrc parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0
        self.length_lo = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID

        elif self.state == TinyFrameWithLen16NoCrcParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH

        elif self.state == TinyFrameWithLen16NoCrcParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            if len(self.buffer) == 3:
                self.length_lo = byte
            else:
                self.msg_length = self.length_lo | (byte << 8)
                self.packet_size = self.OVERHEAD + self.msg_length
                self.state = TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD

        elif self.state == TinyFrameWithLen16NoCrcParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                result.valid = True
                result.msg_id = self.msg_id
                result.msg_len = self.packet_size - self.OVERHEAD
                result.msg_data = bytes(self.buffer[self.HEADER_SIZE:])
                self.state = TinyFrameWithLen16NoCrcParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with TinyFrameWithLen16NoCrc format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
        output.extend(msg)
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete TinyFrameWithLen16NoCrc packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < TinyFrameWithLen16NoCrc.OVERHEAD:
            return result

        if buffer[0] != TinyFrameWithLen16NoCrc.START_BYTE:
            return result

        msg_length = len(buffer) - TinyFrameWithLen16NoCrc.OVERHEAD

        result.valid = True
        result.msg_id = buffer[1]
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[TinyFrameWithLen16NoCrc.HEADER_SIZE:])

        return result


# =============================================================================
# BasicFrameWithSysComp Frame Format
# =============================================================================

class BasicFrameWithSysCompParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_PAYLOAD = 3


class BasicFrameWithSysComp:
    """
    BasicFrameWithSysComp - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x94] [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x94
    HEADER_SIZE = 3
    FOOTER_SIZE = 2
    OVERHEAD = 5

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the BasicFrameWithSysComp parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == BasicFrameWithSysCompParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2

        if self.state == BasicFrameWithSysCompParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = BasicFrameWithSysCompParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START2
            else:
                self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithSysCompParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = BasicFrameWithSysCompParserState.GETTING_PAYLOAD
                else:
                    self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1
            else:
                self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1

        elif self.state == BasicFrameWithSysCompParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = BasicFrameWithSysCompParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with BasicFrameWithSysComp format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete BasicFrameWithSysComp packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < BasicFrameWithSysComp.OVERHEAD:
            return result

        if buffer[0] != BasicFrameWithSysComp.START_BYTE1:
            return result
        if buffer[1] != BasicFrameWithSysComp.START_BYTE2:
            return result

        msg_length = len(buffer) - BasicFrameWithSysComp.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[BasicFrameWithSysComp.HEADER_SIZE:len(buffer) - BasicFrameWithSysComp.FOOTER_SIZE])

        return result


# =============================================================================
# UbxFrame Frame Format
# =============================================================================

class UbxFrameParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_LENGTH = 3
    GETTING_PAYLOAD = 4


class UbxFrame:
    """
    UbxFrame - Frame format parser and encoder
    
    Format: [SYNC1=0xB5] [SYNC2=0x62] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0xB5
    START_BYTE2 = 0x62
    HEADER_SIZE = 5
    FOOTER_SIZE = 2
    OVERHEAD = 7
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the UbxFrame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = UbxFrameParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == UbxFrameParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = UbxFrameParserState.LOOKING_FOR_START2

        if self.state == UbxFrameParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = UbxFrameParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = UbxFrameParserState.LOOKING_FOR_START2
            else:
                self.state = UbxFrameParserState.LOOKING_FOR_START1

        elif self.state == UbxFrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = UbxFrameParserState.GETTING_LENGTH

        elif self.state == UbxFrameParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = UbxFrameParserState.GETTING_PAYLOAD

        elif self.state == UbxFrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = UbxFrameParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with UbxFrame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete UbxFrame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < UbxFrame.OVERHEAD:
            return result

        if buffer[0] != UbxFrame.START_BYTE1:
            return result
        if buffer[1] != UbxFrame.START_BYTE2:
            return result

        msg_length = len(buffer) - UbxFrame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[UbxFrame.HEADER_SIZE:len(buffer) - UbxFrame.FOOTER_SIZE])

        return result


# =============================================================================
# MavlinkV1Frame Frame Format
# =============================================================================

class MavlinkV1FrameParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class MavlinkV1Frame:
    """
    MavlinkV1Frame - Frame format parser and encoder
    
    Format: [STX=0xFE] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE = 0xFE
    HEADER_SIZE = 3
    FOOTER_SIZE = 2
    OVERHEAD = 5
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MavlinkV1Frame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MavlinkV1FrameParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MavlinkV1FrameParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = MavlinkV1FrameParserState.GETTING_MSG_ID

        elif self.state == MavlinkV1FrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MavlinkV1FrameParserState.GETTING_LENGTH

        elif self.state == MavlinkV1FrameParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = MavlinkV1FrameParserState.GETTING_PAYLOAD

        elif self.state == MavlinkV1FrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 1, 1 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MavlinkV1FrameParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MavlinkV1Frame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 1, 1 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MavlinkV1Frame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MavlinkV1Frame.OVERHEAD:
            return result

        if buffer[0] != MavlinkV1Frame.START_BYTE:
            return result

        msg_length = len(buffer) - MavlinkV1Frame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[1]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MavlinkV1Frame.HEADER_SIZE:len(buffer) - MavlinkV1Frame.FOOTER_SIZE])

        return result


# =============================================================================
# MavlinkV2Frame Frame Format
# =============================================================================

class MavlinkV2FrameParserState(Enum):
    LOOKING_FOR_START = 0
    GETTING_MSG_ID = 1
    GETTING_LENGTH = 2
    GETTING_PAYLOAD = 3


class MavlinkV2Frame:
    """
    MavlinkV2Frame - Frame format parser and encoder
    
    Format: [STX=0xFD] [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE = 0xFD
    HEADER_SIZE = 5
    FOOTER_SIZE = 2
    OVERHEAD = 7
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MavlinkV2Frame parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MavlinkV2FrameParserState.LOOKING_FOR_START
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MavlinkV2FrameParserState.LOOKING_FOR_START:
            if byte == self.START_BYTE:
                self.buffer = [byte]
                self.state = MavlinkV2FrameParserState.GETTING_MSG_ID

        elif self.state == MavlinkV2FrameParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MavlinkV2FrameParserState.GETTING_LENGTH

        elif self.state == MavlinkV2FrameParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = MavlinkV2FrameParserState.GETTING_PAYLOAD

        elif self.state == MavlinkV2FrameParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 1, 1 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MavlinkV2FrameParserState.LOOKING_FOR_START

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MavlinkV2Frame format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE)
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 1, 1 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MavlinkV2Frame packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MavlinkV2Frame.OVERHEAD:
            return result

        if buffer[0] != MavlinkV2Frame.START_BYTE:
            return result

        msg_length = len(buffer) - MavlinkV2Frame.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 1, 1 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[1]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MavlinkV2Frame.HEADER_SIZE:len(buffer) - MavlinkV2Frame.FOOTER_SIZE])

        return result


# =============================================================================
# FrameFormatConfig Frame Format
# =============================================================================

class FrameFormatConfigParserState(Enum):
    LOOKING_FOR_START1 = 0
    LOOKING_FOR_START2 = 1
    GETTING_MSG_ID = 2
    GETTING_PAYLOAD = 3


class FrameFormatConfig:
    """
    FrameFormatConfig - Frame format parser and encoder
    
    Format: [START_BYTE1=0x90] [START_BYTE2=0x91] [MSG_ID] [MSG...] [CRC1] [CRC2]
    """

    START_BYTE1 = 0x90
    START_BYTE2 = 0x91
    HEADER_SIZE = 2
    FOOTER_SIZE = 1
    OVERHEAD = 3

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the FrameFormatConfig parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = FrameFormatConfigParserState.LOOKING_FOR_START1
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == FrameFormatConfigParserState.LOOKING_FOR_START1:
            if byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START2

        if self.state == FrameFormatConfigParserState.LOOKING_FOR_START2:
            if byte == self.START_BYTE2:
                self.buffer.append(byte)
                self.state = FrameFormatConfigParserState.GETTING_MSG_ID
            elif byte == self.START_BYTE1:
                self.buffer = [byte]
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START2
            else:
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        elif self.state == FrameFormatConfigParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            if self.get_msg_length:
                msg_length = self.get_msg_length(byte)
                if msg_length is not None:
                    self.packet_size = self.OVERHEAD + msg_length
                    self.state = FrameFormatConfigParserState.GETTING_PAYLOAD
                else:
                    self.state = FrameFormatConfigParserState.LOOKING_FOR_START1
            else:
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        elif self.state == FrameFormatConfigParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 2, 2 + msg_length + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = FrameFormatConfigParserState.LOOKING_FOR_START1

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with FrameFormatConfig format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(self.START_BYTE1)
        output.append(self.START_BYTE2)
        output.append(msg_id)
        output.extend(msg)
        ck = fletcher_checksum(output, 2, 2 + len(msg) + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete FrameFormatConfig packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < FrameFormatConfig.OVERHEAD:
            return result

        if buffer[0] != FrameFormatConfig.START_BYTE1:
            return result
        if buffer[1] != FrameFormatConfig.START_BYTE2:
            return result

        msg_length = len(buffer) - FrameFormatConfig.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 2, 2 + msg_length + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[2]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[FrameFormatConfig.HEADER_SIZE:len(buffer) - FrameFormatConfig.FOOTER_SIZE])

        return result


