# Automatically generated frame parser base utilities
# Generated by 0.0.1 at Thu Dec  4 20:27:20 2025.

from enum import Enum
from typing import List, Tuple, Union
from dataclasses import dataclass

# Frame format type enumeration
class FrameFormatType(Enum):
    TINY_MINIMAL = 0
    TINY_DEFAULT = 1
    TINY_EXTENDED_MSG_IDS = 2
    TINY_EXTENDED_LENGTH = 3
    TINY_EXTENDED = 4
    TINY_SYS_COMP = 5
    TINY_SEQ = 6
    TINY_MULTI_SYSTEM_STREAM = 7
    TINY_EXTENDED_MULTI_SYSTEM_STREAM = 8
    BASIC_MINIMAL = 9
    BASIC_DEFAULT = 10
    BASIC_EXTENDED_MSG_IDS = 11
    BASIC_EXTENDED_LENGTH = 12
    BASIC_EXTENDED = 13
    BASIC_SYS_COMP = 14
    BASIC_SEQ = 15
    BASIC_MULTI_SYSTEM_STREAM = 16
    BASIC_EXTENDED_MULTI_SYSTEM_STREAM = 17
    UBX_FRAME = 18
    MAVLINK_V1_FRAME = 19
    MAVLINK_V2_FRAME = 20
    FRAME_FORMAT_CONFIG = 21


def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)

    byte1 = 0
    byte2 = 0

    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256

    return (byte1, byte2)


@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''


# =============================================================================
# Shared Payload Parsing Functions
# =============================================================================
# These functions handle payload validation/encoding independent of framing.
# Frame formats (Tiny/Basic) use these for the common parsing logic.

def validate_payload_with_crc(buffer: Union[bytes, List[int]], header_size: int,
                              length_bytes: int, crc_start_offset: int = 0) -> FrameMsgInfo:
    """
    Validate a payload with CRC (shared by Default, Extended, etc. payload types).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + length + msg_id + extra fields)
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset from start of buffer where CRC calculation begins
        
    Returns:
        FrameMsgInfo with valid=True if checksum matches
    """
    result = FrameMsgInfo()
    footer_size = 2  # CRC is always 2 bytes
    overhead = header_size + footer_size
    
    if len(buffer) < overhead:
        return result
    
    msg_length = len(buffer) - overhead
    
    # Calculate expected CRC range: from crc_start_offset to before the CRC bytes
    crc_data_len = msg_length + 1 + length_bytes  # msg_id (1) + length_bytes + payload
    ck = fletcher_checksum(buffer, crc_start_offset, crc_start_offset + crc_data_len)
    
    if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
        result.valid = True
        result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
        result.msg_len = msg_length
        result.msg_data = bytes(buffer[header_size:len(buffer) - footer_size])
    
    return result


def validate_payload_minimal(buffer: Union[bytes, List[int]], header_size: int) -> FrameMsgInfo:
    """
    Validate a minimal payload (no CRC, no length field).
    
    Args:
        buffer: Complete packet buffer (including any start bytes)
        header_size: Size of header (start_bytes + msg_id)
        
    Returns:
        FrameMsgInfo with packet data
    """
    result = FrameMsgInfo()
    
    if len(buffer) < header_size:
        return result
    
    result.valid = True
    result.msg_id = buffer[header_size - 1]  # msg_id is last byte of header
    result.msg_len = len(buffer) - header_size
    result.msg_data = bytes(buffer[header_size:])
    
    return result


def encode_payload_with_crc(output: list, msg_id: int, msg: bytes,
                            length_bytes: int, crc_start_offset: int) -> None:
    """
    Encode payload with length and CRC (modifies output list in place).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
        length_bytes: Number of length bytes (1 or 2)
        crc_start_offset: Offset in output where CRC calculation begins
    """
    # Add length field
    if length_bytes == 1:
        output.append(len(msg) & 0xFF)
    else:
        output.append(len(msg) & 0xFF)
        output.append((len(msg) >> 8) & 0xFF)
    
    # Add msg_id
    output.append(msg_id)
    
    # Add payload
    output.extend(msg)
    
    # Calculate and add CRC
    crc_data_len = len(msg) + 1 + length_bytes
    ck = fletcher_checksum(output, crc_start_offset, crc_start_offset + crc_data_len)
    output.append(ck[0])
    output.append(ck[1])


def encode_payload_minimal(output: list, msg_id: int, msg: bytes) -> None:
    """
    Encode minimal payload (no length, no CRC).
    
    Args:
        output: Output list to append to (already contains start bytes)
        msg_id: Message ID
        msg: Message payload data
    """
    output.append(msg_id)
    output.extend(msg)
