# Automatically generated frame parser base utilities
# Generated by 0.0.1 at Wed Dec  3 17:57:16 2025.

from enum import Enum
from typing import List, Tuple, Union
from dataclasses import dataclass

# Frame format type enumeration
class FrameFormatType(Enum):
    MINIMAL_FRAME = 0
    BASIC_FRAME = 1
    BASIC_FRAME_NO_CRC = 2
    TINY_FRAME = 3
    TINY_FRAME_NO_CRC = 4
    MINIMAL_FRAME_WITH_LEN = 5
    MINIMAL_FRAME_WITH_LEN_NO_CRC = 6
    BASIC_FRAME_WITH_LEN = 7
    BASIC_FRAME_WITH_LEN_NO_CRC = 8
    TINY_FRAME_WITH_LEN = 9
    TINY_FRAME_WITH_LEN_NO_CRC = 10
    MINIMAL_FRAME_WITH_LEN16 = 11
    MINIMAL_FRAME_WITH_LEN16_NO_CRC = 12
    BASIC_FRAME_WITH_LEN16 = 13
    BASIC_FRAME_WITH_LEN16_NO_CRC = 14
    TINY_FRAME_WITH_LEN16 = 15
    TINY_FRAME_WITH_LEN16_NO_CRC = 16
    BASIC_FRAME_WITH_SYS_COMP = 17
    UBX_FRAME = 18
    MAVLINK_V1_FRAME = 19
    MAVLINK_V2_FRAME = 20
    FRAME_FORMAT_CONFIG = 21


def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)

    byte1 = 0
    byte2 = 0

    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256

    return (byte1, byte2)


@dataclass
class FrameMsgInfo:
    """Parse result containing message information"""
    valid: bool = False
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''
