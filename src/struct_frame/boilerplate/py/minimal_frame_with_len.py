# Automatically generated frame parser
# Generated by 0.0.1 at Wed Dec  3 17:57:16 2025.

from enum import Enum
from typing import Callable, List, Union
from .frame_base import FrameMsgInfo, fletcher_checksum

# =============================================================================
# MinimalFrameWithLen Frame Format
# =============================================================================

class MinimalFrameWithLenParserState(Enum):
    GETTING_MSG_ID = 0
    GETTING_LENGTH = 1
    GETTING_PAYLOAD = 2


class MinimalFrameWithLen:
    """
    MinimalFrameWithLen - Frame format parser and encoder
    
    Format: [MSG_ID] [LEN] [MSG...] [CRC1] [CRC2]
    """

    HEADER_SIZE = 2
    FOOTER_SIZE = 2
    OVERHEAD = 4
    LENGTH_BYTES = 1

    def __init__(self, get_msg_length: Callable[[int], int] = None):
        """
        Initialize the MinimalFrameWithLen parser
        
        Args:
            get_msg_length: Callback function to get message length from msg_id
                            Required for formats without a length field
        """
        self.get_msg_length = get_msg_length
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = MinimalFrameWithLenParserState.GETTING_MSG_ID
        self.buffer = []
        self.packet_size = 0
        self.msg_id = 0
        self.msg_length = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte
        
        Returns:
            FrameMsgInfo with valid=True when a complete valid message is received
        """
        result = FrameMsgInfo()

        if self.state == MinimalFrameWithLenParserState.GETTING_MSG_ID:
            self.buffer.append(byte)
            self.msg_id = byte
            self.state = MinimalFrameWithLenParserState.GETTING_LENGTH

        elif self.state == MinimalFrameWithLenParserState.GETTING_LENGTH:
            self.buffer.append(byte)
            self.msg_length = byte
            self.packet_size = self.OVERHEAD + self.msg_length
            self.state = MinimalFrameWithLenParserState.GETTING_PAYLOAD

        elif self.state == MinimalFrameWithLenParserState.GETTING_PAYLOAD:
            self.buffer.append(byte)

            if len(self.buffer) >= self.packet_size:
                # Validate checksum
                msg_length = self.packet_size - self.OVERHEAD
                ck = fletcher_checksum(self.buffer, 0, 0 + msg_length + 1 + 1)
                if ck[0] == self.buffer[-2] and ck[1] == self.buffer[-1]:
                    result.valid = True
                    result.msg_id = self.msg_id
                    result.msg_len = msg_length
                    result.msg_data = bytes(self.buffer[self.HEADER_SIZE:self.packet_size - self.FOOTER_SIZE])
                self.state = MinimalFrameWithLenParserState.GETTING_MSG_ID

        return result

    def encode(self, msg_id: int, msg: bytes) -> bytes:
        """
        Encode a message with MinimalFrameWithLen format
        
        Args:
            msg_id: Message ID
            msg: Message data bytes
        
        Returns:
            Encoded frame as bytes
        """
        output = []
        output.append(msg_id)
        output.append(len(msg) & 0xFF)
        output.extend(msg)
        ck = fletcher_checksum(output, 0, 0 + len(msg) + 1 + 1)
        output.append(ck[0])
        output.append(ck[1])
        return bytes(output)

    def encode_msg(self, msg) -> bytes:
        """Encode a message object (must have msg_id and pack() method)"""
        return self.encode(msg.msg_id, msg.pack())

    @staticmethod
    def validate_packet(buffer: Union[bytes, List[int]]) -> FrameMsgInfo:
        """
        Validate a complete MinimalFrameWithLen packet in a buffer
        
        Args:
            buffer: Buffer containing the complete packet
        
        Returns:
            FrameMsgInfo with valid=True if packet is valid
        """
        result = FrameMsgInfo()

        if len(buffer) < MinimalFrameWithLen.OVERHEAD:
            return result


        msg_length = len(buffer) - MinimalFrameWithLen.OVERHEAD

        # Validate checksum
        ck = fletcher_checksum(buffer, 0, 0 + msg_length + 1 + 1)
        if ck[0] == buffer[-2] and ck[1] == buffer[-1]:
            result.valid = True
            result.msg_id = buffer[0]
            result.msg_len = msg_length
            result.msg_data = bytes(buffer[MinimalFrameWithLen.HEADER_SIZE:len(buffer) - MinimalFrameWithLen.FOOTER_SIZE])

        return result
