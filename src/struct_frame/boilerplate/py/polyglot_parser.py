# Automatically generated polyglot frame parser
# Generated by 0.0.1 at Fri Dec 19 12:12:50 2025.
# Uses header + payload architecture for composable frame formats.

from enum import Enum
from typing import Union, Optional, Callable, List, Tuple
from dataclasses import dataclass

# =============================================================================
# Header Types - Define start byte patterns
# =============================================================================

class HeaderType(Enum):
    """Header types defining start byte patterns"""
    NONE = 0       # No start bytes
    TINY = 1       # 1 start byte [0x70+PayloadType]
    BASIC = 2      # 2 start bytes [0x90] [0x70+PayloadType]
    UBX = 3        # 2 start bytes [0xB5] [0x62]
    MAVLINK_V1 = 4 # 1 start byte [0xFE]
    MAVLINK_V2 = 5 # 1 start byte [0xFD]


# =============================================================================
# Payload Types - Define header/footer structure
# =============================================================================

class PayloadType(Enum):
    """Payload types defining header/footer structure"""
    MINIMAL = 0                      # [MSG_ID] [PACKET]
    DEFAULT = 1                      # [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]
    EXTENDED_MSG_IDS = 2             # [LEN] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]
    EXTENDED_LENGTH = 3              # [LEN16] [MSG_ID] [PACKET] [CRC1] [CRC2]
    EXTENDED = 4                     # [LEN16] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]
    SYS_COMP = 5                     # [SYS_ID] [COMP_ID] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]
    SEQ = 6                          # [SEQ] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]
    MULTI_SYSTEM_STREAM = 7          # [SEQ] [SYS_ID] [COMP_ID] [LEN] [MSG_ID] [PACKET] [CRC1] [CRC2]
    EXTENDED_MULTI_SYSTEM_STREAM = 8 # [SEQ] [SYS_ID] [COMP_ID] [LEN16] [PKG_ID] [MSG_ID] [PACKET] [CRC1] [CRC2]


# =============================================================================
# Constants
# =============================================================================

# Start byte constants
BASIC_START_BYTE = 0x90
PAYLOAD_TYPE_BASE = 0x70  # Payload type encoded as 0x70 + PayloadType.value
UBX_SYNC1 = 0xB5
UBX_SYNC2 = 0x62
MAVLINK_V1_STX = 0xFE
MAVLINK_V2_STX = 0xFD

# Maximum payload type value (for range checking)
MAX_PAYLOAD_TYPE = 8


# =============================================================================
# Payload Configuration
# =============================================================================

@dataclass
class PayloadConfig:
    """Configuration for a payload type"""
    payload_type: PayloadType
    has_crc: bool
    crc_bytes: int
    has_length: bool
    length_bytes: int  # 1 or 2
    has_sequence: bool
    has_system_id: bool
    has_component_id: bool
    has_package_id: bool

    @property
    def header_size(self) -> int:
        """Size of payload header (before message data)"""
        size = 1  # msg_id
        if self.has_length:
            size += self.length_bytes
        if self.has_sequence:
            size += 1
        if self.has_system_id:
            size += 1
        if self.has_component_id:
            size += 1
        if self.has_package_id:
            size += 1
        return size

    @property
    def footer_size(self) -> int:
        """Size of payload footer (CRC)"""
        return self.crc_bytes

    @property
    def overhead(self) -> int:
        """Total overhead (header + footer)"""
        return self.header_size + self.footer_size


# Payload type configurations
PAYLOAD_CONFIGS = {
    PayloadType.MINIMAL: PayloadConfig(
        payload_type=PayloadType.MINIMAL,
        has_crc=False,
        crc_bytes=0,
        has_length=False,
        length_bytes=1,
        has_sequence=False,
        has_system_id=False,
        has_component_id=False,
        has_package_id=False,
    ),
    PayloadType.DEFAULT: PayloadConfig(
        payload_type=PayloadType.DEFAULT,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=1,
        has_sequence=False,
        has_system_id=False,
        has_component_id=False,
        has_package_id=False,
    ),
    PayloadType.EXTENDED_MSG_IDS: PayloadConfig(
        payload_type=PayloadType.EXTENDED_MSG_IDS,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=1,
        has_sequence=False,
        has_system_id=False,
        has_component_id=False,
        has_package_id=True,
    ),
    PayloadType.EXTENDED_LENGTH: PayloadConfig(
        payload_type=PayloadType.EXTENDED_LENGTH,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=2,
        has_sequence=False,
        has_system_id=False,
        has_component_id=False,
        has_package_id=False,
    ),
    PayloadType.EXTENDED: PayloadConfig(
        payload_type=PayloadType.EXTENDED,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=2,
        has_sequence=False,
        has_system_id=False,
        has_component_id=False,
        has_package_id=True,
    ),
    PayloadType.SYS_COMP: PayloadConfig(
        payload_type=PayloadType.SYS_COMP,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=1,
        has_sequence=False,
        has_system_id=True,
        has_component_id=True,
        has_package_id=False,
    ),
    PayloadType.SEQ: PayloadConfig(
        payload_type=PayloadType.SEQ,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=1,
        has_sequence=True,
        has_system_id=False,
        has_component_id=False,
        has_package_id=False,
    ),
    PayloadType.MULTI_SYSTEM_STREAM: PayloadConfig(
        payload_type=PayloadType.MULTI_SYSTEM_STREAM,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=1,
        has_sequence=True,
        has_system_id=True,
        has_component_id=True,
        has_package_id=False,
    ),
    PayloadType.EXTENDED_MULTI_SYSTEM_STREAM: PayloadConfig(
        payload_type=PayloadType.EXTENDED_MULTI_SYSTEM_STREAM,
        has_crc=True,
        crc_bytes=2,
        has_length=True,
        length_bytes=2,
        has_sequence=True,
        has_system_id=True,
        has_component_id=True,
        has_package_id=True,
    ),
}


# =============================================================================
# Utilities
# =============================================================================

def fletcher_checksum(buffer: Union[bytes, List[int]], start: int = 0, end: int = None) -> Tuple[int, int]:
    """Calculate Fletcher-16 checksum over the given data"""
    if end is None:
        end = len(buffer)
    byte1 = 0
    byte2 = 0
    for x in range(start, end):
        byte1 = (byte1 + buffer[x]) % 256
        byte2 = (byte2 + byte1) % 256
    return (byte1, byte2)


@dataclass
class FrameMsgInfo:
    """Result from frame parsing"""
    valid: bool = False
    header_type: Optional[HeaderType] = None
    payload_type: Optional[PayloadType] = None
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''
    # Optional extended fields
    package_id: int = 0
    sequence: int = 0
    system_id: int = 0
    component_id: int = 0


class ParserState(Enum):
    """Parser state machine states"""
    LOOKING_FOR_START = 0
    GOT_BASIC_START = 1  # Got 0x90, waiting for payload type byte
    GOT_UBX_SYNC1 = 2    # Got 0xB5, waiting for 0x62
    PARSING_HEADER = 3   # Parsing payload header fields
    PARSING_PAYLOAD = 4  # Parsing message data
    PARSING_FOOTER = 5   # Parsing CRC


# =============================================================================
# Polyglot Parser
# =============================================================================

class PolyglotParser:
    """
    Polyglot frame parser that can detect and parse multiple frame types.
    
    Supports:
    - Basic frames: [0x90] [0x70+payload_type] [payload...]
    - Tiny frames:  [0x70+payload_type] [payload...]
    - None frames:  [payload...] (no start bytes)
    
    The payload type (0-8) determines the payload structure.
    """

    def __init__(self,
                 get_msg_length: Callable[[int], int] = None,
                 enable_basic: bool = True,
                 enable_tiny: bool = True,
                 enable_none: bool = False,
                 default_payload_type: PayloadType = PayloadType.DEFAULT):
        """
        Initialize polyglot parser.
        
        Args:
            get_msg_length: Callback to get message length from msg_id (required for Minimal payloads)
            enable_basic: Enable Basic frame parsing (default: True)
            enable_tiny: Enable Tiny frame parsing (default: True)
            enable_none: Enable None frame parsing (default: False, requires external sync)
            default_payload_type: Default payload type for None frames
        """
        self.get_msg_length = get_msg_length
        self.enable_basic = enable_basic
        self.enable_tiny = enable_tiny
        self.enable_none = enable_none
        self.default_payload_type = default_payload_type
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = ParserState.LOOKING_FOR_START
        self.header_type: Optional[HeaderType] = None
        self.payload_type: Optional[PayloadType] = None
        self.payload_config: Optional[PayloadConfig] = None
        self.buffer: List[int] = []
        self.header_bytes_remaining = 0
        self.payload_bytes_remaining = 0
        self.footer_bytes_remaining = 0
        # Parsed header fields
        self.msg_id = 0
        self.msg_len = 0
        self.package_id = 0
        self.sequence = 0
        self.system_id = 0
        self.component_id = 0
        self.header_field_index = 0

    def parse_byte(self, byte: int) -> FrameMsgInfo:
        """
        Parse a single byte.
        
        Returns:
            FrameMsgInfo with valid=True when a complete message is received
        """
        result = FrameMsgInfo()

        if self.state == ParserState.LOOKING_FOR_START:
            result = self._handle_looking_for_start(byte)
        elif self.state == ParserState.GOT_BASIC_START:
            result = self._handle_got_basic_start(byte)
        elif self.state == ParserState.GOT_UBX_SYNC1:
            result = self._handle_got_ubx_sync1(byte)
        elif self.state == ParserState.PARSING_HEADER:
            result = self._handle_parsing_header(byte)
        elif self.state == ParserState.PARSING_PAYLOAD:
            result = self._handle_parsing_payload(byte)
        elif self.state == ParserState.PARSING_FOOTER:
            result = self._handle_parsing_footer(byte)

        return result

    def _handle_looking_for_start(self, byte: int) -> FrameMsgInfo:
        """Handle LOOKING_FOR_START state"""
        # Check for Basic frame (0x90)
        if self.enable_basic and byte == BASIC_START_BYTE:
            self.state = ParserState.GOT_BASIC_START
            self.header_type = HeaderType.BASIC
            self.buffer = [byte]
        # Check for Tiny frame (0x70-0x78)
        elif self.enable_tiny and PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:
            payload_type_value = byte - PAYLOAD_TYPE_BASE
            self._start_payload_parsing(HeaderType.TINY, PayloadType(payload_type_value), [byte])
        # Check for UBX (0xB5)
        elif byte == UBX_SYNC1:
            self.state = ParserState.GOT_UBX_SYNC1
            self.buffer = [byte]
        # Check for Mavlink V1 (0xFE)
        elif byte == MAVLINK_V1_STX:
            self.header_type = HeaderType.MAVLINK_V1
            # TODO: Implement Mavlink V1 parsing
            self.reset()
        # Check for Mavlink V2 (0xFD)
        elif byte == MAVLINK_V2_STX:
            self.header_type = HeaderType.MAVLINK_V2
            # TODO: Implement Mavlink V2 parsing
            self.reset()
        # None frame (no start bytes) - treat as payload directly
        elif self.enable_none:
            self._start_payload_parsing(HeaderType.NONE, self.default_payload_type, [])
            return self._handle_parsing_header(byte)
        return FrameMsgInfo()

    def _handle_got_basic_start(self, byte: int) -> FrameMsgInfo:
        """Handle GOT_BASIC_START state - waiting for payload type byte"""
        if PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:
            payload_type_value = byte - PAYLOAD_TYPE_BASE
            self.buffer.append(byte)
            self._start_payload_parsing(HeaderType.BASIC, PayloadType(payload_type_value), self.buffer)
        else:
            # Invalid second byte, reset
            self.reset()
        return FrameMsgInfo()

    def _handle_got_ubx_sync1(self, byte: int) -> FrameMsgInfo:
        """Handle GOT_UBX_SYNC1 state - waiting for second sync byte"""
        if byte == UBX_SYNC2:
            self.buffer.append(byte)
            self.header_type = HeaderType.UBX
            # TODO: Implement UBX payload parsing
            self.reset()
        else:
            self.reset()
        return FrameMsgInfo()

    def _start_payload_parsing(self, header_type: HeaderType, payload_type: PayloadType, buffer: List[int]):
        """Initialize payload parsing after header detection"""
        self.header_type = header_type
        self.payload_type = payload_type
        self.payload_config = PAYLOAD_CONFIGS.get(payload_type)
        self.buffer = buffer.copy()
        self.header_field_index = 0
        self.state = ParserState.PARSING_HEADER

    def _handle_parsing_header(self, byte: int) -> FrameMsgInfo:
        """Parse payload header fields based on payload type"""
        self.buffer.append(byte)
        config = self.payload_config
        if config is None:
            self.reset()
            return FrameMsgInfo()

        # Parse header fields in order based on payload type
        # Order: [SEQ] [SYS_ID] [COMP_ID] [LEN/LEN16] [PKG_ID] [MSG_ID]
        field_order = []
        if config.has_sequence:
            field_order.append('sequence')
        if config.has_system_id:
            field_order.append('system_id')
        if config.has_component_id:
            field_order.append('component_id')
        if config.has_length:
            if config.length_bytes == 2:
                field_order.append('length_lo')
                field_order.append('length_hi')
            else:
                field_order.append('length')
        if config.has_package_id:
            field_order.append('package_id')
        field_order.append('msg_id')

        if self.header_field_index < len(field_order):
            field_name = field_order[self.header_field_index]
            if field_name == 'sequence':
                self.sequence = byte
            elif field_name == 'system_id':
                self.system_id = byte
            elif field_name == 'component_id':
                self.component_id = byte
            elif field_name == 'length':
                self.msg_len = byte
            elif field_name == 'length_lo':
                self.msg_len = byte
            elif field_name == 'length_hi':
                self.msg_len |= (byte << 8)
            elif field_name == 'package_id':
                self.package_id = byte
            elif field_name == 'msg_id':
                self.msg_id = byte
            self.header_field_index += 1

        # Check if header is complete
        if self.header_field_index >= len(field_order):
            # Determine payload length
            if config.has_length:
                self.payload_bytes_remaining = self.msg_len
            elif self.get_msg_length:
                self.payload_bytes_remaining = self.get_msg_length(self.msg_id)
            else:
                # No length field and no callback - can't determine length
                self.reset()
                return FrameMsgInfo()
            
            self.footer_bytes_remaining = config.footer_size
            self.state = ParserState.PARSING_PAYLOAD if self.payload_bytes_remaining > 0 else ParserState.PARSING_FOOTER

        return FrameMsgInfo()

    def _handle_parsing_payload(self, byte: int) -> FrameMsgInfo:
        """Parse message payload data"""
        self.buffer.append(byte)
        self.payload_bytes_remaining -= 1

        if self.payload_bytes_remaining <= 0:
            if self.footer_bytes_remaining > 0:
                self.state = ParserState.PARSING_FOOTER
            else:
                return self._complete_message()
        return FrameMsgInfo()

    def _handle_parsing_footer(self, byte: int) -> FrameMsgInfo:
        """Parse footer (CRC) bytes"""
        self.buffer.append(byte)
        self.footer_bytes_remaining -= 1

        if self.footer_bytes_remaining <= 0:
            return self._complete_message()
        return FrameMsgInfo()

    def _complete_message(self) -> FrameMsgInfo:
        """Validate and return completed message"""
        config = self.payload_config
        if config is None:
            self.reset()
            return FrameMsgInfo()

        # Validate CRC if present
        if config.has_crc:
            # CRC is calculated from after start bytes to before CRC
            header_size = 0
            if self.header_type == HeaderType.BASIC:
                header_size = 2
            elif self.header_type == HeaderType.TINY:
                header_size = 1
            crc_start = header_size
            crc_end = len(self.buffer) - config.crc_bytes
            calc_crc = fletcher_checksum(self.buffer, crc_start, crc_end)
            recv_crc = (self.buffer[-2], self.buffer[-1])
            if calc_crc != recv_crc:
                self.reset()
                return FrameMsgInfo()

        # Extract message data
        header_size = 0
        if self.header_type == HeaderType.BASIC:
            header_size = 2
        elif self.header_type == HeaderType.TINY:
            header_size = 1
        payload_header_size = config.header_size
        data_start = header_size + payload_header_size
        data_end = len(self.buffer) - config.footer_size
        msg_data = bytes(self.buffer[data_start:data_end])

        result = FrameMsgInfo(
            valid=True,
            header_type=self.header_type,
            payload_type=self.payload_type,
            msg_id=self.msg_id,
            msg_len=len(msg_data),
            msg_data=msg_data,
            package_id=self.package_id,
            sequence=self.sequence,
            system_id=self.system_id,
            component_id=self.component_id,
        )
        self.reset()
        return result

    def encode(self, msg_id: int, msg: bytes,
               header_type: HeaderType = HeaderType.BASIC,
               payload_type: PayloadType = PayloadType.DEFAULT,
               package_id: int = 0,
               sequence: int = 0,
               system_id: int = 0,
               component_id: int = 0) -> bytes:
        """
        Encode a message with specified header and payload type.
        
        Args:
            msg_id: Message ID (0-255)
            msg: Message data bytes
            header_type: Header type (BASIC, TINY, or NONE)
            payload_type: Payload type (MINIMAL, DEFAULT, etc.)
            package_id: Package ID for EXTENDED_MSG_IDS payloads
            sequence: Sequence number for SEQ payloads
            system_id: System ID for SYS_COMP payloads
            component_id: Component ID for SYS_COMP payloads
        
        Returns:
            Encoded frame bytes
        """
        config = PAYLOAD_CONFIGS.get(payload_type)
        if config is None:
            raise ValueError(f"Unknown payload type: {payload_type}")

        output = []

        # Add header start bytes
        if header_type == HeaderType.BASIC:
            output.append(BASIC_START_BYTE)
            output.append(PAYLOAD_TYPE_BASE + payload_type.value)
        elif header_type == HeaderType.TINY:
            output.append(PAYLOAD_TYPE_BASE + payload_type.value)
        # NONE has no start bytes

        # Add payload header fields in order
        if config.has_sequence:
            output.append(sequence & 0xFF)
        if config.has_system_id:
            output.append(system_id & 0xFF)
        if config.has_component_id:
            output.append(component_id & 0xFF)
        if config.has_length:
            if config.length_bytes == 2:
                output.append(len(msg) & 0xFF)
                output.append((len(msg) >> 8) & 0xFF)
            else:
                output.append(len(msg) & 0xFF)
        if config.has_package_id:
            output.append(package_id & 0xFF)
        output.append(msg_id & 0xFF)

        # Add message data
        output.extend(msg)

        # Add CRC if needed
        if config.has_crc:
            # CRC calculated from after start bytes
            crc_start = 0
            if header_type == HeaderType.BASIC:
                crc_start = 2
            elif header_type == HeaderType.TINY:
                crc_start = 1
            crc = fletcher_checksum(output, crc_start)
            output.append(crc[0])
            output.append(crc[1])

        return bytes(output)

    def encode_basic(self, msg_id: int, msg: bytes,
                     payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:
        """Encode with Basic header"""
        return self.encode(msg_id, msg, HeaderType.BASIC, payload_type, **kwargs)

    def encode_tiny(self, msg_id: int, msg: bytes,
                    payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:
        """Encode with Tiny header"""
        return self.encode(msg_id, msg, HeaderType.TINY, payload_type, **kwargs)

