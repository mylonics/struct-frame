# Automatically generated polyglot frame parser
# Generated by 0.0.1 at Fri Dec 19 18:24:29 2025.

from enum import Enum
from typing import Union, Optional, Callable
from dataclasses import dataclass
try:
    from .frame_base import (
        FrameFormatType,
        FrameMsgInfo,
        FrameParserConfig,
        GenericParserState,
    )
except ImportError:
    from frame_base import (
        FrameFormatType,
        FrameMsgInfo,
        FrameParserConfig,
        GenericParserState,
    )

try:
    from .tiny_minimal import TinyMinimal, TinyMinimalConfig
except ImportError:
    from tiny_minimal import TinyMinimal, TinyMinimalConfig
try:
    from .tiny_default import TinyDefault, TinyDefaultConfig
except ImportError:
    from tiny_default import TinyDefault, TinyDefaultConfig
try:
    from .tiny_extended_msg_ids import TinyExtendedMsgIds, TinyExtendedMsgIdsConfig
except ImportError:
    from tiny_extended_msg_ids import TinyExtendedMsgIds, TinyExtendedMsgIdsConfig
try:
    from .tiny_extended_length import TinyExtendedLength, TinyExtendedLengthConfig
except ImportError:
    from tiny_extended_length import TinyExtendedLength, TinyExtendedLengthConfig
try:
    from .tiny_extended import TinyExtended, TinyExtendedConfig
except ImportError:
    from tiny_extended import TinyExtended, TinyExtendedConfig
try:
    from .tiny_sys_comp import TinySysComp, TinySysCompConfig
except ImportError:
    from tiny_sys_comp import TinySysComp, TinySysCompConfig
try:
    from .tiny_seq import TinySeq, TinySeqConfig
except ImportError:
    from tiny_seq import TinySeq, TinySeqConfig
try:
    from .tiny_multi_system_stream import TinyMultiSystemStream, TinyMultiSystemStreamConfig
except ImportError:
    from tiny_multi_system_stream import TinyMultiSystemStream, TinyMultiSystemStreamConfig
try:
    from .tiny_extended_multi_system_stream import TinyExtendedMultiSystemStream, TinyExtendedMultiSystemStreamConfig
except ImportError:
    from tiny_extended_multi_system_stream import TinyExtendedMultiSystemStream, TinyExtendedMultiSystemStreamConfig
try:
    from .basic_minimal import BasicMinimal, BasicMinimalConfig
except ImportError:
    from basic_minimal import BasicMinimal, BasicMinimalConfig
try:
    from .basic_default import BasicDefault, BasicDefaultConfig
except ImportError:
    from basic_default import BasicDefault, BasicDefaultConfig
try:
    from .basic_extended_msg_ids import BasicExtendedMsgIds, BasicExtendedMsgIdsConfig
except ImportError:
    from basic_extended_msg_ids import BasicExtendedMsgIds, BasicExtendedMsgIdsConfig
try:
    from .basic_extended_length import BasicExtendedLength, BasicExtendedLengthConfig
except ImportError:
    from basic_extended_length import BasicExtendedLength, BasicExtendedLengthConfig
try:
    from .basic_extended import BasicExtended, BasicExtendedConfig
except ImportError:
    from basic_extended import BasicExtended, BasicExtendedConfig
try:
    from .basic_sys_comp import BasicSysComp, BasicSysCompConfig
except ImportError:
    from basic_sys_comp import BasicSysComp, BasicSysCompConfig
try:
    from .basic_seq import BasicSeq, BasicSeqConfig
except ImportError:
    from basic_seq import BasicSeq, BasicSeqConfig
try:
    from .basic_multi_system_stream import BasicMultiSystemStream, BasicMultiSystemStreamConfig
except ImportError:
    from basic_multi_system_stream import BasicMultiSystemStream, BasicMultiSystemStreamConfig
try:
    from .basic_extended_multi_system_stream import BasicExtendedMultiSystemStream, BasicExtendedMultiSystemStreamConfig
except ImportError:
    from basic_extended_multi_system_stream import BasicExtendedMultiSystemStream, BasicExtendedMultiSystemStreamConfig
try:
    from .ubx_frame import UbxFrame, UbxFrameConfig
except ImportError:
    from ubx_frame import UbxFrame, UbxFrameConfig
try:
    from .mavlink_v1_frame import MavlinkV1Frame, MavlinkV1FrameConfig
except ImportError:
    from mavlink_v1_frame import MavlinkV1Frame, MavlinkV1FrameConfig
try:
    from .mavlink_v2_frame import MavlinkV2Frame, MavlinkV2FrameConfig
except ImportError:
    from mavlink_v2_frame import MavlinkV2Frame, MavlinkV2FrameConfig
try:
    from .frame_format_config import FrameFormatConfig, FrameFormatConfigConfig
except ImportError:
    from frame_format_config import FrameFormatConfig, FrameFormatConfigConfig


# =============================================================================
# Polyglot Parser - Parse Multiple Frame Types in Same Stream
# =============================================================================

# Map start bytes to frame formats
BASIC_START_BYTE1 = 0x90
TINY_START_BYTE_BASE = 0x70  # Tiny frames: 0x70 + payload_type

# Payload type to format mapping
PAYLOAD_TYPE_TO_TINY_FORMAT = {
    0: TinyMinimal,  # 0x70
    1: TinyDefault,  # 0x71
    2: TinyExtendedMsgIds,  # 0x72
    3: TinyExtendedLength,  # 0x73
    4: TinyExtended,  # 0x74
    5: TinySysComp,  # 0x75
    6: TinySeq,  # 0x76
    7: TinyMultiSystemStream,  # 0x77
    8: TinyExtendedMultiSystemStream,  # 0x78
}

PAYLOAD_TYPE_TO_BASIC_FORMAT = {
    0: BasicMinimal,  # 0x90 0x70
    1: BasicDefault,  # 0x90 0x71
    2: BasicExtendedMsgIds,  # 0x90 0x72
    3: BasicExtendedLength,  # 0x90 0x73
    4: BasicExtended,  # 0x90 0x74
    5: BasicSysComp,  # 0x90 0x75
    6: BasicSeq,  # 0x90 0x76
    7: BasicMultiSystemStream,  # 0x90 0x77
    8: BasicExtendedMultiSystemStream,  # 0x90 0x78
}

PAYLOAD_TYPE_TO_NONE_FORMAT = {
}

@dataclass
class PolyglotParserResult:
    """Result from polyglot parser with frame type information"""
    valid: bool = False
    frame_type: Optional[str] = None  # "basic", "tiny", "none"
    payload_type: Optional[int] = None
    format_name: Optional[str] = None
    msg_id: int = 0
    msg_len: int = 0
    msg_data: bytes = b''

    @classmethod
    def from_frame_msg_info(cls, info: FrameMsgInfo, frame_type: str,
                           payload_type: int, format_name: str):
        """Create from FrameMsgInfo"""
        return cls(
            valid=info.valid,
            frame_type=frame_type,
            payload_type=payload_type,
            format_name=format_name,
            msg_id=info.msg_id,
            msg_len=info.msg_len,
            msg_data=info.msg_data
        )


class PolyglotParserState(Enum):
    """Parser state for polyglot parser"""
    LOOKING_FOR_START = 0
    DETECTED_BASIC = 1
    DETECTED_TINY = 2
    PARSING_NONE = 3


class PolyglotParser:
    """
    Polyglot frame parser that can detect and parse multiple frame types.
    
    The parser cascades through frame types:
    1. Check for Basic frame (0x90 start byte)
    2. Check for Tiny frame (0x70-0x78 start byte)
    3. Fall back to None frame (direct payload)
    
    The second start byte (Basic) or single start byte (Tiny) encodes the
    payload type (0x70 + payload_type_offset).
    """

    def __init__(self, get_msg_length: Callable[[int], int] = None,
                 enable_basic: bool = True,
                 enable_tiny: bool = True,
                 enable_none: bool = True,
                 default_none_format: Optional[str] = None):
        """
        Initialize polyglot parser.
        
        Args:
            get_msg_length: Callback to get message length from msg_id
            enable_basic: Enable Basic frame parsing (default: True)
            enable_tiny: Enable Tiny frame parsing (default: True)
            enable_none: Enable None frame parsing (default: True)
            default_none_format: Default format for None frames
        """
        self.get_msg_length = get_msg_length
        self.enable_basic = enable_basic
        self.enable_tiny = enable_tiny
        self.enable_none = enable_none
        self.default_none_format = default_none_format
        
        # Active parsers (created on-demand)
        self.active_parser = None
        self.active_parser_type = None  # "basic", "tiny", "none"
        self.active_payload_type = None
        
        self.reset()

    def reset(self):
        """Reset parser state"""
        self.state = PolyglotParserState.LOOKING_FOR_START
        self.active_parser = None
        self.active_parser_type = None
        self.active_payload_type = None
        self.buffer = []

    def parse_byte(self, byte: int) -> PolyglotParserResult:
        """
        Parse a single byte and detect frame type.
        
        Returns:
            PolyglotParserResult with valid=True when a complete message is received
        """
        result = PolyglotParserResult()
        
        if self.state == PolyglotParserState.LOOKING_FOR_START:
            # Check for Basic frame (0x90)
            if self.enable_basic and byte == BASIC_START_BYTE1:
                self.state = PolyglotParserState.DETECTED_BASIC
                self.buffer = [byte]
            # Check for Tiny frame (0x70-0x78)
            elif self.enable_tiny and 0x70 <= byte <= 0x78:
                payload_type = byte - TINY_START_BYTE_BASE
                if payload_type in PAYLOAD_TYPE_TO_TINY_FORMAT:
                    parser_class = PAYLOAD_TYPE_TO_TINY_FORMAT[payload_type]
                    self.active_parser = parser_class(self.get_msg_length)
                    self.active_parser_type = "tiny"
                    self.active_payload_type = payload_type
                    self.state = PolyglotParserState.DETECTED_TINY
                    # Feed the start byte to the parser
                    frame_info = self.active_parser.parse_byte(byte)
                    if frame_info.valid:
                        format_name = parser_class.__name__
                        result = PolyglotParserResult.from_frame_msg_info(
                            frame_info, "tiny", payload_type, format_name)
                        self.reset()
            # Fall back to None frame
            elif self.enable_none:
                # For None frames, we need to determine the format
                # This is tricky without external sync - we would need
                # the message ID to determine format
                self.state = PolyglotParserState.PARSING_NONE
                if self.default_none_format:
                    parser_class = globals().get(self.default_none_format)
                    if parser_class:
                        self.active_parser = parser_class(self.get_msg_length)
                        self.active_parser_type = "none"
                        self.active_payload_type = 0
                        frame_info = self.active_parser.parse_byte(byte)
                        if frame_info.valid:
                            format_name = parser_class.__name__
                            result = PolyglotParserResult.from_frame_msg_info(
                                frame_info, "none", 0, format_name)
                            self.reset()
        
        elif self.state == PolyglotParserState.DETECTED_BASIC:
            # Got 0x90, now check for second start byte (0x70-0x78)
            # Or continue parsing if we already have an active parser
            if self.active_parser:
                # Already detected frame type, continue parsing
                frame_info = self.active_parser.parse_byte(byte)
                if frame_info.valid:
                    format_name = self.active_parser.__class__.__name__
                    result = PolyglotParserResult.from_frame_msg_info(
                        frame_info, self.active_parser_type,
                        self.active_payload_type or 0, format_name)
                    self.reset()
            elif 0x70 <= byte <= 0x78:
                payload_type = byte - TINY_START_BYTE_BASE
                if payload_type in PAYLOAD_TYPE_TO_BASIC_FORMAT:
                    parser_class = PAYLOAD_TYPE_TO_BASIC_FORMAT[payload_type]
                    self.active_parser = parser_class(self.get_msg_length)
                    self.active_parser_type = "basic"
                    self.active_payload_type = payload_type
                    # Feed both start bytes to the parser
                    self.active_parser.parse_byte(0x90)
                    frame_info = self.active_parser.parse_byte(byte)
                    # Check if message is already complete (unlikely but possible)
                    if frame_info.valid:
                        format_name = parser_class.__name__
                        result = PolyglotParserResult.from_frame_msg_info(
                            frame_info, "basic", payload_type, format_name)
                        self.reset()
                else:
                    # Invalid payload type, reset
                    self.reset()
            else:
                # Not a valid Basic frame second byte, reset
                self.reset()
        
        # Continue parsing with active parser for Tiny, Basic (after start bytes), or None frames
        elif self.active_parser and not result.valid:
            # This handles:
            # - DETECTED_TINY: Continue parsing Tiny frame after start byte
            # - DETECTED_BASIC: Continue parsing Basic frame after both start bytes
            # - PARSING_NONE: Continue parsing None frame
            frame_info = self.active_parser.parse_byte(byte)
            if frame_info.valid:
                format_name = self.active_parser.__class__.__name__
                result = PolyglotParserResult.from_frame_msg_info(
                    frame_info, self.active_parser_type,
                    self.active_payload_type or 0, format_name)
                self.reset()
        
        return result

    def encode(self, msg_id: int, msg: bytes, frame_type: str = "basic",
               payload_type: int = 1) -> bytes:
        """
        Encode a message with specified frame type and payload type.
        
        Args:
            msg_id: Message ID
            msg: Message data
            frame_type: "basic", "tiny", or "none"
            payload_type: Payload type index (0-8)
        
        Returns:
            Encoded frame bytes
        """
        # Select format based on frame type and payload type
        if frame_type == "basic":
            format_map = PAYLOAD_TYPE_TO_BASIC_FORMAT
        elif frame_type == "tiny":
            format_map = PAYLOAD_TYPE_TO_TINY_FORMAT
        elif frame_type == "none":
            format_map = PAYLOAD_TYPE_TO_NONE_FORMAT
        else:
            raise ValueError(f"Unknown frame type: {frame_type}")
        
        parser_class = format_map.get(payload_type)
        if not parser_class:
            raise ValueError(f"Unknown payload type {payload_type} for {frame_type}")
        
        # Create temporary parser instance and encode
        parser = parser_class()
        return parser.encode(msg_id, msg)

