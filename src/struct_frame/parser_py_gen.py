#!/usr/bin/env python3
# kate: replace-tabs on; indent-width 4;

"""
Python Parser Generator

Generates Python code for parsers that can handle multiple frame types
in the same stream using the header + payload architecture.

Headers: Basic, Tiny, None (and third-party: UBX, MavlinkV1, MavlinkV2)
Payloads: Minimal, Default, Extended, etc.

The parser dynamically combines headers with payloads at runtime.
"""

from struct_frame import version
from struct_frame.frame_format import HeaderType, PayloadType
import time


def camel_to_snake(name):
    """Convert CamelCase to snake_case"""
    import re
    name = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    name = re.sub('([a-z0-9])([A-Z])', r'\1_\2', name)
    return name.lower()


def camel_to_upper_snake(name):
    """Convert CamelCase to UPPER_SNAKE_CASE"""
    return camel_to_snake(name).upper()


class ParserPyGen:
    """Generates Python code for parsers using header + payload architecture"""

    @staticmethod
    def generate_parser(collection):
        """Generate a parser from header and payload definitions - now modular"""
        yield '# Automatically generated frame parser\n'
        yield f'# Generated by {version} at {time.asctime()}.\n'
        yield '# Uses header + payload architecture for composable frame formats.\n'
        yield '# Now uses modular structure with frame_headers/ and payload_types/ submodules.\n\n'
        
        yield 'from typing import Optional, Callable, List\n'
        yield 'try:\n'
        yield '    # Try relative imports (when used as a package)\n'
        yield '    from .frame_headers import (\n'
        yield '        HeaderType, HeaderConfig,\n'
        yield '        BASIC_START_BYTE, PAYLOAD_TYPE_BASE, UBX_SYNC1, UBX_SYNC2,\n'
        yield '        MAVLINK_V1_STX, MAVLINK_V2_STX,\n'
        yield '        HEADER_NONE_CONFIG, HEADER_TINY_CONFIG, HEADER_BASIC_CONFIG,\n'
        yield '        HEADER_UBX_CONFIG, HEADER_MAVLINK_V1_CONFIG, HEADER_MAVLINK_V2_CONFIG,\n'
        yield '        is_tiny_start_byte, get_payload_type_from_tiny\n'
        yield '    )\n'
        yield '    from .payload_types import (\n'
        yield '        PayloadType, MAX_PAYLOAD_TYPE, PayloadConfig,\n'
        yield '        PAYLOAD_MINIMAL_CONFIG, PAYLOAD_DEFAULT_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_MSG_IDS_CONFIG, PAYLOAD_EXTENDED_LENGTH_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_CONFIG, PAYLOAD_SYS_COMP_CONFIG,\n'
        yield '        PAYLOAD_SEQ_CONFIG, PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG\n'
        yield '    )\n'
        yield '    from .utils import fletcher_checksum, FrameMsgInfo, ParserState, Profile\n'
        yield 'except ImportError:\n'
        yield '    # Fall back to absolute imports (when used as a standalone file)\n'
        yield '    from frame_headers import (\n'
        yield '        HeaderType, HeaderConfig,\n'
        yield '        BASIC_START_BYTE, PAYLOAD_TYPE_BASE, UBX_SYNC1, UBX_SYNC2,\n'
        yield '        MAVLINK_V1_STX, MAVLINK_V2_STX,\n'
        yield '        HEADER_NONE_CONFIG, HEADER_TINY_CONFIG, HEADER_BASIC_CONFIG,\n'
        yield '        HEADER_UBX_CONFIG, HEADER_MAVLINK_V1_CONFIG, HEADER_MAVLINK_V2_CONFIG,\n'
        yield '        is_tiny_start_byte, get_payload_type_from_tiny\n'
        yield '    )\n'
        yield '    from payload_types import (\n'
        yield '        PayloadType, MAX_PAYLOAD_TYPE, PayloadConfig,\n'
        yield '        PAYLOAD_MINIMAL_CONFIG, PAYLOAD_DEFAULT_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_MSG_IDS_CONFIG, PAYLOAD_EXTENDED_LENGTH_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_CONFIG, PAYLOAD_SYS_COMP_CONFIG,\n'
        yield '        PAYLOAD_SEQ_CONFIG, PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,\n'
        yield '        PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG\n'
        yield '    )\n'
        yield '    from utils import fletcher_checksum, FrameMsgInfo, ParserState, Profile\n\n'
        
        yield '# Payload configurations mapping\n'
        yield 'PAYLOAD_CONFIGS = {\n'
        yield '    PayloadType.MINIMAL: PAYLOAD_MINIMAL_CONFIG,\n'
        yield '    PayloadType.DEFAULT: PAYLOAD_DEFAULT_CONFIG,\n'
        yield '    PayloadType.EXTENDED_MSG_IDS: PAYLOAD_EXTENDED_MSG_IDS_CONFIG,\n'
        yield '    PayloadType.EXTENDED_LENGTH: PAYLOAD_EXTENDED_LENGTH_CONFIG,\n'
        yield '    PayloadType.EXTENDED: PAYLOAD_EXTENDED_CONFIG,\n'
        yield '    PayloadType.SYS_COMP: PAYLOAD_SYS_COMP_CONFIG,\n'
        yield '    PayloadType.SEQ: PAYLOAD_SEQ_CONFIG,\n'
        yield '    PayloadType.MULTI_SYSTEM_STREAM: PAYLOAD_MULTI_SYSTEM_STREAM_CONFIG,\n'
        yield '    PayloadType.EXTENDED_MULTI_SYSTEM_STREAM: PAYLOAD_EXTENDED_MULTI_SYSTEM_STREAM_CONFIG,\n'
        yield '}\n\n\n'
        
        # Generate the main Parser class
        yield '# =============================================================================\n'
        yield '# Parser\n'
        yield '# =============================================================================\n\n'

        yield 'class Parser:\n'
        yield '    """\n'
        yield '    Frame parser that can detect and parse multiple frame types.\n'
        yield '    \n'
        yield '    Supports:\n'
        yield '    - Basic frames: [0x90] [0x70+payload_type] [payload...]\n'
        yield '    - Tiny frames:  [0x70+payload_type] [payload...]\n'
        yield '    - None frames:  [payload...] (no start bytes)\n'
        yield '    \n'
        yield '    The payload type (0-8) determines the payload structure.\n'
        yield '    """\n\n'
        
        # Constructor
        yield '    def __init__(self,\n'
        yield '                 get_msg_length: Callable[[int], int] = None,\n'
        yield '                 enabled_headers: Optional[List[HeaderType]] = None,\n'
        yield '                 enabled_payloads: Optional[List[PayloadType]] = None,\n'
        yield '                 # Legacy parameters (deprecated):\n'
        yield '                 enable_basic: bool = True,\n'
        yield '                 enable_tiny: bool = True,\n'
        yield '                 enable_none: bool = False,\n'
        yield '                 default_payload_type: PayloadType = PayloadType.DEFAULT):\n'
        yield '        """\n'
        yield '        Initialize parser.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            get_msg_length: Callback to get message length from msg_id (required for Minimal payloads)\n'
        yield '            enabled_headers: List of header types to accept (None = all supported)\n'
        yield '            enabled_payloads: List of payload types to accept (None = all)\n'
        yield '            enable_basic: (Deprecated) Enable Basic frame parsing\n'
        yield '            enable_tiny: (Deprecated) Enable Tiny frame parsing\n'
        yield '            enable_none: (Deprecated) Enable None frame parsing\n'
        yield '            default_payload_type: Default payload type for None frames\n'
        yield '        """\n'
        yield '        self.get_msg_length = get_msg_length\n'
        yield '        \n'
        yield '        # Handle new registration API\n'
        yield '        if enabled_headers is not None:\n'
        yield '            self.enabled_headers = set(enabled_headers)\n'
        yield '        else:\n'
        yield '            # Use legacy parameters\n'
        yield '            self.enabled_headers = set()\n'
        yield '            if enable_basic:\n'
        yield '                self.enabled_headers.add(HeaderType.BASIC)\n'
        yield '            if enable_tiny:\n'
        yield '                self.enabled_headers.add(HeaderType.TINY)\n'
        yield '            if enable_none:\n'
        yield '                self.enabled_headers.add(HeaderType.NONE)\n'
        yield '        \n'
        yield '        if enabled_payloads is not None:\n'
        yield '            self.enabled_payloads = set(enabled_payloads)\n'
        yield '        else:\n'
        yield '            # Accept all payload types\n'
        yield '            self.enabled_payloads = set(PayloadType)\n'
        yield '        \n'
        yield '        self.default_payload_type = default_payload_type\n'
        yield '        self.reset()\n\n'
        
        # Reset method
        yield '    def reset(self):\n'
        yield '        """Reset parser state"""\n'
        yield '        self.state = ParserState.LOOKING_FOR_START\n'
        yield '        self.header_type: Optional[HeaderType] = None\n'
        yield '        self.payload_type: Optional[PayloadType] = None\n'
        yield '        self.payload_config: Optional[PayloadConfig] = None\n'
        yield '        self.buffer: List[int] = []\n'
        yield '        self.header_bytes_remaining = 0\n'
        yield '        self.payload_bytes_remaining = 0\n'
        yield '        self.footer_bytes_remaining = 0\n'
        yield '        # Parsed header fields\n'
        yield '        self.msg_id = 0\n'
        yield '        self.msg_len = 0\n'
        yield '        self.package_id = 0\n'
        yield '        self.sequence = 0\n'
        yield '        self.system_id = 0\n'
        yield '        self.component_id = 0\n'
        yield '        self.header_field_index = 0\n\n'
        
        # Parse byte method
        yield '    def parse_byte(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """\n'
        yield '        Parse a single byte.\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            FrameMsgInfo with valid=True when a complete message is received\n'
        yield '        """\n'
        yield '        result = FrameMsgInfo()\n\n'
        
        yield '        if self.state == ParserState.LOOKING_FOR_START:\n'
        yield '            result = self._handle_looking_for_start(byte)\n'
        yield '        elif self.state == ParserState.GOT_BASIC_START:\n'
        yield '            result = self._handle_got_basic_start(byte)\n'
        yield '        elif self.state == ParserState.GOT_UBX_SYNC1:\n'
        yield '            result = self._handle_got_ubx_sync1(byte)\n'
        yield '        elif self.state == ParserState.PARSING_HEADER:\n'
        yield '            result = self._handle_parsing_header(byte)\n'
        yield '        elif self.state == ParserState.PARSING_PAYLOAD:\n'
        yield '            result = self._handle_parsing_payload(byte)\n'
        yield '        elif self.state == ParserState.PARSING_FOOTER:\n'
        yield '            result = self._handle_parsing_footer(byte)\n\n'
        yield '        return result\n\n'
        
        # Handle looking for start
        yield '    def _handle_looking_for_start(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle LOOKING_FOR_START state"""\n'
        yield '        # Check for Basic frame (0x90)\n'
        yield '        if HeaderType.BASIC in self.enabled_headers and byte == BASIC_START_BYTE:\n'
        yield '            self.state = ParserState.GOT_BASIC_START\n'
        yield '            self.header_type = HeaderType.BASIC\n'
        yield '            self.buffer = [byte]\n'
        yield '        # Check for Tiny frame (0x70-0x78)\n'
        yield '        elif HeaderType.TINY in self.enabled_headers and PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:\n'
        yield '            payload_type_value = byte - PAYLOAD_TYPE_BASE\n'
        yield '            payload_type = PayloadType(payload_type_value)\n'
        yield '            if payload_type in self.enabled_payloads:\n'
        yield '                self._start_payload_parsing(HeaderType.TINY, payload_type, [byte])\n'
        yield '        # Check for UBX (0xB5)\n'
        yield '        elif HeaderType.UBX in self.enabled_headers and byte == UBX_SYNC1:\n'
        yield '            self.state = ParserState.GOT_UBX_SYNC1\n'
        yield '            self.buffer = [byte]\n'
        yield '        # Check for Mavlink V1 (0xFE)\n'
        yield '        elif HeaderType.MAVLINK_V1 in self.enabled_headers and byte == MAVLINK_V1_STX:\n'
        yield '            self.header_type = HeaderType.MAVLINK_V1\n'
        yield '            # TODO: Implement Mavlink V1 parsing\n'
        yield '            self.reset()\n'
        yield '        # Check for Mavlink V2 (0xFD)\n'
        yield '        elif HeaderType.MAVLINK_V2 in self.enabled_headers and byte == MAVLINK_V2_STX:\n'
        yield '            self.header_type = HeaderType.MAVLINK_V2\n'
        yield '            # TODO: Implement Mavlink V2 parsing\n'
        yield '            self.reset()\n'
        yield '        # None frame (no start bytes) - treat as payload directly\n'
        yield '        elif HeaderType.NONE in self.enabled_headers:\n'
        yield '            if self.default_payload_type in self.enabled_payloads:\n'
        yield '                self._start_payload_parsing(HeaderType.NONE, self.default_payload_type, [])\n'
        yield '                return self._handle_parsing_header(byte)\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle got basic start
        yield '    def _handle_got_basic_start(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle GOT_BASIC_START state - waiting for payload type byte"""\n'
        yield '        if PAYLOAD_TYPE_BASE <= byte <= PAYLOAD_TYPE_BASE + MAX_PAYLOAD_TYPE:\n'
        yield '            payload_type_value = byte - PAYLOAD_TYPE_BASE\n'
        yield '            payload_type = PayloadType(payload_type_value)\n'
        yield '            if payload_type in self.enabled_payloads:\n'
        yield '                self.buffer.append(byte)\n'
        yield '                self._start_payload_parsing(HeaderType.BASIC, payload_type, self.buffer)\n'
        yield '            else:\n'
        yield '                # Payload type not enabled, reset\n'
        yield '                self.reset()\n'
        yield '        else:\n'
        yield '            # Invalid second byte, reset\n'
        yield '            self.reset()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle got UBX sync1
        yield '    def _handle_got_ubx_sync1(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Handle GOT_UBX_SYNC1 state - waiting for second sync byte"""\n'
        yield '        if byte == UBX_SYNC2:\n'
        yield '            self.buffer.append(byte)\n'
        yield '            self.header_type = HeaderType.UBX\n'
        yield '            # TODO: Implement UBX payload parsing\n'
        yield '            self.reset()\n'
        yield '        else:\n'
        yield '            self.reset()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Start payload parsing
        yield '    def _start_payload_parsing(self, header_type: HeaderType, payload_type: PayloadType, buffer: List[int]):\n'
        yield '        """Initialize payload parsing after header detection"""\n'
        yield '        self.header_type = header_type\n'
        yield '        self.payload_type = payload_type\n'
        yield '        self.payload_config = PAYLOAD_CONFIGS.get(payload_type)\n'
        yield '        self.buffer = buffer.copy()\n'
        yield '        self.header_field_index = 0\n'
        yield '        self.state = ParserState.PARSING_HEADER\n\n'
        
        # Handle parsing header
        yield '    def _handle_parsing_header(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse payload header fields based on payload type"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        config = self.payload_config\n'
        yield '        if config is None:\n'
        yield '            self.reset()\n'
        yield '            return FrameMsgInfo()\n\n'
        yield '        # Parse header fields in order based on payload type\n'
        yield '        # Order: [SEQ] [SYS_ID] [COMP_ID] [LEN/LEN16] [PKG_ID] [MSG_ID]\n'
        yield '        field_order = []\n'
        yield '        if config.has_sequence:\n'
        yield '            field_order.append(\'sequence\')\n'
        yield '        if config.has_system_id:\n'
        yield '            field_order.append(\'system_id\')\n'
        yield '        if config.has_component_id:\n'
        yield '            field_order.append(\'component_id\')\n'
        yield '        if config.has_length:\n'
        yield '            if config.length_bytes == 2:\n'
        yield '                field_order.append(\'length_lo\')\n'
        yield '                field_order.append(\'length_hi\')\n'
        yield '            else:\n'
        yield '                field_order.append(\'length\')\n'
        yield '        if config.has_package_id:\n'
        yield '            field_order.append(\'package_id\')\n'
        yield '        field_order.append(\'msg_id\')\n\n'
        yield '        if self.header_field_index < len(field_order):\n'
        yield '            field_name = field_order[self.header_field_index]\n'
        yield '            if field_name == \'sequence\':\n'
        yield '                self.sequence = byte\n'
        yield '            elif field_name == \'system_id\':\n'
        yield '                self.system_id = byte\n'
        yield '            elif field_name == \'component_id\':\n'
        yield '                self.component_id = byte\n'
        yield '            elif field_name == \'length\':\n'
        yield '                self.msg_len = byte\n'
        yield '            elif field_name == \'length_lo\':\n'
        yield '                self.msg_len = byte\n'
        yield '            elif field_name == \'length_hi\':\n'
        yield '                self.msg_len |= (byte << 8)\n'
        yield '            elif field_name == \'package_id\':\n'
        yield '                self.package_id = byte\n'
        yield '            elif field_name == \'msg_id\':\n'
        yield '                self.msg_id = byte\n'
        yield '            self.header_field_index += 1\n\n'
        yield '        # Check if header is complete\n'
        yield '        if self.header_field_index >= len(field_order):\n'
        yield '            # Determine payload length\n'
        yield '            if config.has_length:\n'
        yield '                self.payload_bytes_remaining = self.msg_len\n'
        yield '            elif self.get_msg_length:\n'
        yield '                self.payload_bytes_remaining = self.get_msg_length(self.msg_id)\n'
        yield '            else:\n'
        yield '                # No length field and no callback - can\'t determine length\n'
        yield '                self.reset()\n'
        yield '                return FrameMsgInfo()\n'
        yield '            \n'
        yield '            self.footer_bytes_remaining = config.footer_size\n'
        yield '            self.state = ParserState.PARSING_PAYLOAD if self.payload_bytes_remaining > 0 else ParserState.PARSING_FOOTER\n\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle parsing payload
        yield '    def _handle_parsing_payload(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse message payload data"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        self.payload_bytes_remaining -= 1\n\n'
        yield '        if self.payload_bytes_remaining <= 0:\n'
        yield '            if self.footer_bytes_remaining > 0:\n'
        yield '                self.state = ParserState.PARSING_FOOTER\n'
        yield '            else:\n'
        yield '                return self._complete_message()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Handle parsing footer
        yield '    def _handle_parsing_footer(self, byte: int) -> FrameMsgInfo:\n'
        yield '        """Parse footer (CRC) bytes"""\n'
        yield '        self.buffer.append(byte)\n'
        yield '        self.footer_bytes_remaining -= 1\n\n'
        yield '        if self.footer_bytes_remaining <= 0:\n'
        yield '            return self._complete_message()\n'
        yield '        return FrameMsgInfo()\n\n'
        
        # Complete message
        yield '    def _complete_message(self) -> FrameMsgInfo:\n'
        yield '        """Validate and return completed message"""\n'
        yield '        config = self.payload_config\n'
        yield '        if config is None:\n'
        yield '            self.reset()\n'
        yield '            return FrameMsgInfo()\n\n'
        yield '        # Validate CRC if present\n'
        yield '        if config.has_crc:\n'
        yield '            # CRC is calculated from after start bytes to before CRC\n'
        yield '            header_size = 0\n'
        yield '            if self.header_type == HeaderType.BASIC:\n'
        yield '                header_size = 2\n'
        yield '            elif self.header_type == HeaderType.TINY:\n'
        yield '                header_size = 1\n'
        yield '            crc_start = header_size\n'
        yield '            crc_end = len(self.buffer) - config.crc_bytes\n'
        yield '            calc_crc = fletcher_checksum(self.buffer, crc_start, crc_end)\n'
        yield '            recv_crc = (self.buffer[-2], self.buffer[-1])\n'
        yield '            if calc_crc != recv_crc:\n'
        yield '                self.reset()\n'
        yield '                return FrameMsgInfo()\n\n'
        yield '        # Extract message data\n'
        yield '        header_size = 0\n'
        yield '        if self.header_type == HeaderType.BASIC:\n'
        yield '            header_size = 2\n'
        yield '        elif self.header_type == HeaderType.TINY:\n'
        yield '            header_size = 1\n'
        yield '        payload_header_size = config.header_size\n'
        yield '        data_start = header_size + payload_header_size\n'
        yield '        data_end = len(self.buffer) - config.footer_size\n'
        yield '        msg_data = bytes(self.buffer[data_start:data_end])\n\n'
        yield '        result = FrameMsgInfo(\n'
        yield '            valid=True,\n'
        yield '            header_type=self.header_type,\n'
        yield '            payload_type=self.payload_type,\n'
        yield '            msg_id=self.msg_id,\n'
        yield '            msg_len=len(msg_data),\n'
        yield '            msg_data=msg_data,\n'
        yield '            package_id=self.package_id,\n'
        yield '            sequence=self.sequence,\n'
        yield '            system_id=self.system_id,\n'
        yield '            component_id=self.component_id,\n'
        yield '        )\n'
        yield '        self.reset()\n'
        yield '        return result\n\n'
        
        # Encode method
        yield '    def encode(self, msg_id: int, msg: bytes,\n'
        yield '               header_type: HeaderType = HeaderType.BASIC,\n'
        yield '               payload_type: PayloadType = PayloadType.DEFAULT,\n'
        yield '               package_id: int = 0,\n'
        yield '               sequence: int = 0,\n'
        yield '               system_id: int = 0,\n'
        yield '               component_id: int = 0) -> bytes:\n'
        yield '        """\n'
        yield '        Encode a message with specified header and payload type.\n'
        yield '        \n'
        yield '        Args:\n'
        yield '            msg_id: Message ID (0-255)\n'
        yield '            msg: Message data bytes\n'
        yield '            header_type: Header type (BASIC, TINY, or NONE)\n'
        yield '            payload_type: Payload type (MINIMAL, DEFAULT, etc.)\n'
        yield '            package_id: Package ID for EXTENDED_MSG_IDS payloads\n'
        yield '            sequence: Sequence number for SEQ payloads\n'
        yield '            system_id: System ID for SYS_COMP payloads\n'
        yield '            component_id: Component ID for SYS_COMP payloads\n'
        yield '        \n'
        yield '        Returns:\n'
        yield '            Encoded frame bytes\n'
        yield '        """\n'
        yield '        config = PAYLOAD_CONFIGS.get(payload_type)\n'
        yield '        if config is None:\n'
        yield '            raise ValueError(f"Unknown payload type: {payload_type}")\n\n'
        yield '        output = []\n\n'
        yield '        # Add header start bytes\n'
        yield '        if header_type == HeaderType.BASIC:\n'
        yield '            output.append(BASIC_START_BYTE)\n'
        yield '            output.append(PAYLOAD_TYPE_BASE + payload_type.value)\n'
        yield '        elif header_type == HeaderType.TINY:\n'
        yield '            output.append(PAYLOAD_TYPE_BASE + payload_type.value)\n'
        yield '        # NONE has no start bytes\n\n'
        yield '        # Add payload header fields in order\n'
        yield '        if config.has_sequence:\n'
        yield '            output.append(sequence & 0xFF)\n'
        yield '        if config.has_system_id:\n'
        yield '            output.append(system_id & 0xFF)\n'
        yield '        if config.has_component_id:\n'
        yield '            output.append(component_id & 0xFF)\n'
        yield '        if config.has_length:\n'
        yield '            if config.length_bytes == 2:\n'
        yield '                output.append(len(msg) & 0xFF)\n'
        yield '                output.append((len(msg) >> 8) & 0xFF)\n'
        yield '            else:\n'
        yield '                output.append(len(msg) & 0xFF)\n'
        yield '        if config.has_package_id:\n'
        yield '            output.append(package_id & 0xFF)\n'
        yield '        output.append(msg_id & 0xFF)\n\n'
        yield '        # Add message data\n'
        yield '        output.extend(msg)\n\n'
        yield '        # Add CRC if needed\n'
        yield '        if config.has_crc:\n'
        yield '            # CRC calculated from after start bytes\n'
        yield '            crc_start = 0\n'
        yield '            if header_type == HeaderType.BASIC:\n'
        yield '                crc_start = 2\n'
        yield '            elif header_type == HeaderType.TINY:\n'
        yield '                crc_start = 1\n'
        yield '            crc = fletcher_checksum(output, crc_start)\n'
        yield '            output.append(crc[0])\n'
        yield '            output.append(crc[1])\n\n'
        yield '        return bytes(output)\n\n'
        
        # Convenience methods
        yield '    def encode_basic(self, msg_id: int, msg: bytes,\n'
        yield '                     payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:\n'
        yield '        """Encode with Basic header"""\n'
        yield '        return self.encode(msg_id, msg, HeaderType.BASIC, payload_type, **kwargs)\n\n'
        yield '    def encode_tiny(self, msg_id: int, msg: bytes,\n'
        yield '                    payload_type: PayloadType = PayloadType.DEFAULT, **kwargs) -> bytes:\n'
        yield '        """Encode with Tiny header"""\n'
        yield '        return self.encode(msg_id, msg, HeaderType.TINY, payload_type, **kwargs)\n\n'


def generate_py_parser(collection):
    """Generate Python parser code"""
    return ''.join(ParserPyGen.generate_parser(collection))
