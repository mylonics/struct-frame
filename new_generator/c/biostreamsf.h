/* Automatically generated struct frame header */
/* Generated by 0.0.1 at Fri Feb  7 19:15:30 2025. */

#pragma once
#pragma pack(1)
#include "serial_frame.h"
/* Enum definitions */
typedef enum adc_sampling_frequency
{
    FREQ_1000 = 0,
    FREQ_2000 = 1,
    FREQ_4000 = 2,
    FREQ_8000 = 3,
    FREQ_16000 = 4
} adc_sampling_frequency_tTy;
typedef uint8_t adc_sampling_frequency_t;

['//enum before comment'] typedef enum trans_impedance_gain {
    R_10 = 0,
    R_100 = 1,
    R_1K = 2,
    // Enum inside comment
    R_10K = 3
} trans_impedance_gain_tTy;
typedef uint8_t trans_impedance_gain_t;

/* Struct definitions */
// 2nd line comment
typedef struct raw_data2
{
    // In Message comment
    float ref_v;
    float drn_c;
    // Field comment
    float src_v;
    float drn_v;
    float gte_v;
    float phs_v;
    raw_data_t gte_c;
    float temp;
    float time;
} raw_data2_t;

#define raw_data2_t_max_size 68;
MESSAGE_HELPER(raw_data2_t, 68, 1);

typedef struct raw_data
{
    float ref_v;
    float drn_c;
    float src_v;
    float drn_v;
    float gte_v;
    float phs_v;
    float gte_c;
    float temp;
    float time;
} raw_data_t;

#define raw_data_t_max_size 36;
MESSAGE_HELPER(raw_data_t, 36, 1);

typedef struct adc_command
{
    boolean enable;
    adc_sampling_frequency_t samplig_freq;
    uint8_t over_sampling_rate;
    trans_impedance_gain_t drain_res;
    trans_impedance_gain_t gate_res;
} adc_command_t;

#define adc_command_t_max_size 5;
MESSAGE_HELPER(adc_command_t, 5, 112);

uint8_t get_message_length(uint8_t msg_id)
{
    switch (msg_id)
    {
    case raw_data2_t_msgid:
        return raw_data2_t_max_size;
    case raw_data_t_msgid:
        return raw_data_t_max_size;
    case adc_command_t_msgid:
        return adc_command_t_max_size;
    default:
        break;
    }
    return 0;
}
