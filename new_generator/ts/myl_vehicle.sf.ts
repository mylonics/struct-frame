/* Automatically generated struct frame header */
/* Generated by 0.0.1 at Fri Feb  7 20:16:38 2025. */

const typed_struct = require('typed-struct')
const ExtractType = typeof typed_struct.ExtractType;
const type = typeof typed_struct.ExtractType;

import { struct_frame_buffer } from './struct_frame_types';
import { msg_encode, msg_reserve, msg_finish } from './struct_frame';

/* Enum definitions */
export enum myl_vehiclevehicle_type {
    VEHICLE_TYPE_UNSPECIFIED = 0,
    VEHICLE_TYPE_ROVER = 1,
    VEHICLE_TYPE_BOAT = 2,
    VEHICLE_TYPE_FW = 3,
    VEHICLE_TYPE_MR = 4,
    VEHICLE_TYPE_CAR = 5
}

/* Struct definitions */
export const myl_vehicle_position_t = new typed_struct.Struct('myl_vehicle_position_t') 
    .Float64LE('lat')
    .Float64LE('lon')
    .Float32LE('alt')
    .compile();

export const myl_vehicle_position_t_max_size = 20;
export const position_msgid = 1
export function position_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, position_msgid)
}
export function position_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, position_msgid, position_max_size);
    if (msg_buffer){
        return new position(msg_buffer)
    }
    return;
}
export function position_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}


//Used for sending robot pose
export const myl_vehicle_pose_t = new typed_struct.Struct('myl_vehicle_pose_t') 
//Used for sending roll
    .Float32LE('roll')
// Used for sending pitch
    .Float32LE('pitch')
    .Float32LE('yaw')
    .Float32LE('roll_rate')
    .Float32LE('pitch_rate')
    .Float32LE('yaw_rate')
    .myl_vehicle_int16('test')
    .compile();

export const myl_vehicle_pose_t_max_size = 26;
export const pose_msgid = 2
export function pose_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, pose_msgid)
}
export function pose_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, pose_msgid, pose_max_size);
    if (msg_buffer){
        return new pose(msg_buffer)
    }
    return;
}
export function pose_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}


export const myl_vehicle_heartbeat_t = new typed_struct.Struct('myl_vehicle_heartbeat_t') 
    .myl_vehicle_vehicle_type('type')
    .myl_vehicle_int32('id')
    .compile();

export const myl_vehicle_heartbeat_t_max_size = 5;
export const heartbeat_msgid = 3
export function heartbeat_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, heartbeat_msgid)
}
export function heartbeat_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, heartbeat_msgid, heartbeat_max_size);
    if (msg_buffer){
        return new heartbeat(msg_buffer)
    }
    return;
}
export function heartbeat_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}


export const myl_vehicle_heartbeat2_t = new typed_struct.Struct('myl_vehicle_heartbeat2_t') 
    .Float32LE('test')
    .myl_vehicle_int32('id3')
    .compile();

export const myl_vehicle_heartbeat2_t_max_size = 8;
export const heartbeat2_msgid = 4
export function heartbeat2_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, heartbeat2_msgid)
}
export function heartbeat2_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, heartbeat2_msgid, heartbeat2_max_size);
    if (msg_buffer){
        return new heartbeat2(msg_buffer)
    }
    return;
}
export function heartbeat2_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}



export function get_message_length(msg_id : number){
 switch (msg_id)
 {
  case position_t_msgid: return position_t_max_size;
  case pose_t_msgid: return pose_t_max_size;
  case heartbeat_t_msgid: return heartbeat_t_max_size;
  case heartbeat2_t_msgid: return heartbeat2_t_max_size;
  default: break;
 } return 0;
}
