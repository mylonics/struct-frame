/* Automatically generated struct frame header */
/* Generated by 0.0.1 at Fri Feb  7 20:19:06 2025. */

const typed_struct = require('typed-struct')
const ExtractType = typeof typed_struct.ExtractType;
const type = typeof typed_struct.ExtractType;

import { struct_frame_buffer } from './struct_frame_types';
import { msg_encode, msg_reserve, msg_finish } from './struct_frame';

/* Enum definitions */
export enum biostreamadc_sampling_frequency {
    FREQ_1000 = 0,
    FREQ_2000 = 1,
    FREQ_4000 = 2,
    FREQ_8000 = 3,
    FREQ_16000 = 4
}

//enum before comment
export enum biostreamtrans_impedance_gain {
    R_10 = 0,
    R_100 = 1,
    R_1K = 2,
//Enum inside comment
    R_10K = 3
}

/* Struct definitions */
//2nd line comment
export const biostream_raw_data2_t = new typed_struct.Struct('biostream_raw_data2_t') 
//In Message comment
    .Float32LE('ref_v')
    .Float32LE('drn_c')
//Field comment
    .Float32LE('src_v')
    .Float32LE('drn_v')
    .Float32LE('gte_v')
    .Float32LE('phs_v')
    .biostream_raw_data('gte_c')
    .Float32LE('temp')
    .Float32LE('time')
    .compile();

export const biostream_raw_data2_t_max_size = 68;
export const RawData2_msgid = 1
export function RawData2_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, RawData2_msgid)
}
export function RawData2_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, RawData2_msgid, RawData2_max_size);
    if (msg_buffer){
        return new RawData2(msg_buffer)
    }
    return;
}
export function RawData2_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}


export const biostream_raw_data_t = new typed_struct.Struct('biostream_raw_data_t') 
    .Float32LE('ref_v')
    .Float32LE('drn_c')
    .Float32LE('src_v')
    .Float32LE('drn_v')
    .Float32LE('gte_v')
    .Float32LE('phs_v')
    .Float32LE('gte_c')
    .Float32LE('temp')
    .Float32LE('time')
    .compile();

export const biostream_raw_data_t_max_size = 36;
export const RawData_msgid = 1
export function RawData_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, RawData_msgid)
}
export function RawData_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, RawData_msgid, RawData_max_size);
    if (msg_buffer){
        return new RawData(msg_buffer)
    }
    return;
}
export function RawData_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}


export const biostream_adc_command_t = new typed_struct.Struct('biostream_adc_command_t') 
    .Boolean8('enable')
    .biostream_adc_sampling_frequency('samplig_freq')
    .biostream_uint8('over_sampling_rate')
    .biostream_trans_impedance_gain('drain_res')
    .biostream_trans_impedance_gain('gate_res')
    .compile();

export const biostream_adc_command_t_max_size = 5;
export const AdcCommand_msgid = 112
export function AdcCommand_encode(buffer: struct_frame_buffer, msg: any) {
    msg_encode(buffer, msg, AdcCommand_msgid)
}
export function AdcCommand_reserve(buffer: struct_frame_buffer) {
    const msg_buffer = msg_reserve(buffer, AdcCommand_msgid, AdcCommand_max_size);
    if (msg_buffer){
        return new AdcCommand(msg_buffer)
    }
    return;
}
export function AdcCommand_finish(buffer: struct_frame_buffer) {
    msg_finish(buffer);
}



export function get_message_length(msg_id : number){
 switch (msg_id)
 {
  case raw_data2_t_msgid: return raw_data2_t_max_size;
  case raw_data_t_msgid: return raw_data_t_max_size;
  case adc_command_t_msgid: return adc_command_t_max_size;
  default: break;
 } return 0;
}
